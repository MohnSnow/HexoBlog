---
title: Temp
date: 2017-07-18 19:28:57
tags: Temp
categories: "Temp"
---
```
放一些自己需要强制记忆、经常踩坑、特别重要、看书时候觉得重要的文字。
```
<!--more-->
1. 进程之间通过粗粒度的通信机制来交换数据:套接字、信号处理器、共享内存、信号量以及文件;
2. 无状态对象一定是线程安全的;
3. 凡是对成员变量或者本地变量(在方法中的或者代码块中的变量称为本地变量)声明为final的都叫作final变量。
4. mutable 可变的;
5. 一个对象是不是线程安全的,取决于他是否被多个线程访问;
6. 当多个线程访问某个类时,某个类始终都能表现出正确的行为,就称这个类是线程安全的;
7. 同步容器都是线程安全的: HashTable、Vector;
8. 系统负载System Load：系统CPU繁忙程度的度量，即有多少进程在等待被CPU调度;
9. 如果CPU是8核，load<8是不会有问题的;
10. Java 中的 instanceof 运算符是用来在运行时指出对象是否是特定类的一个实例。
12. 1.对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；如果作用于引用类型的变量，则比较的是所指向的对象的地址;
    2.对于equals方法，注意：equals方法不能作用于基本数据类型的变量,如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址,诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。
13. 对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象.
14. 进程让操作系统的并发性成为可能，而线程让进程的内部并发成为可能。
15. 进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位。
16. CPU密集型的使用多线程效果更好,I/O密集型的多线程线程数少一点更好,有一个公式的: ;
17. 线程从创建到最终的消亡，要经历若干个状态。一般来说，线程包括以下这几个状态：创建(new)、就绪(runnable)、运行(running)、阻塞(blocked)、time waiting、waiting、消亡（dead）。
18. sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象。
19. 原子操作（atomic operation）意为"不可被中断的一个或一系列操作" 。
20. Java的对象序列化是指将那些实现了Serializable接口的对象转换成一个字符序列，并能够在以后将这个字节序列完全恢复为原来的对象。
21. 你会发现Timeout是个非常难处理的事情，因为网络上的Timeout在很多时候让你无所事从，你也不知道对方是做了还是没有做。于是你好好的一个状态机就因为Timeout成了个摆设。
22. 一个网络服务会有三种状态：1）Success，2）Failure，3）Timeout，第三个绝对是恶梦，尤其在你需要维护状态的时候。
23. 同步、异步、阻塞、非阻塞
* 同步 ： 自己亲自出马持银行卡到银行取钱（使用同步IO时，Java自己处理IO读写）。
* 异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS需要支持异步IO操作API）。
* 阻塞 ： ATM排队取款，你只能等待（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）。
* 非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器会通知可读写时再继续进行读写，不断循环直到读写完成）。
25. 网络IO的实现方式有:BIO(Block IO采用阻塞的方式实现)、NIO(Nonblocking IO基于事件驱动思想,采用Reactor方式,一个线程可以处理多个socket)、AIO(AsynchronousIO 异步IO,采用Proactor模式)
26. 事务处理:2PC、3PC、最终一致、BASE、CAP、Paxos
27. 在java中应为不同的目的可以将java划分为两种内存模型：gc内存模型,并发内存模型。



