{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/README","path":"README","modified":1,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"themes/maupassant/source/css/donate.scss","path":"css/donate.scss","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","path":"css/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"a47d25dfadc4f7908f63d18cb3e634d0885a6db8","modified":1488369365000},{"_id":"source/README","hash":"6690336aa81cb7eaf88da65f9f5015142b37f7b8","modified":1543391853963},{"_id":"themes/maupassant/README.md","hash":"75d8c42569809961953d1934de445418c00ab94c","modified":1486722094000},{"_id":"themes/maupassant/package.json","hash":"81fb4e2ac051ecfb9a93f37b28910291b939771a","modified":1486722094000},{"_id":"themes/maupassant/LICENSE","hash":"019dc6a9aba02ae3aaabca45f39aecd6e8e7f1d8","modified":1486722094000},{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1486722094000},{"_id":"themes/maupassant/_config.yml","hash":"8e545a3dccb8f8d0d413bc3c5af86b831a3cb339","modified":1543392655812},{"_id":"source/favicon.ico","hash":"6dd2c0a614be7aa3574355db08ee2c540bcac129","modified":1543393004000},{"_id":"source/about/index.md","hash":"42a5d10e50842d0a45243d4eb2b05987370b7d30","modified":1515754663868},{"_id":"source/_posts/13常见Jar包简介.md","hash":"209cb552e5863564fad0c8e01def8d4fdffca0df","modified":1543463595985},{"_id":"source/_posts/14JAVA反射详解和优化.md","hash":"5cb86d531df69048be0622ee7e5d7cdb8d8131a4","modified":1500539452000},{"_id":"source/_posts/10Temp.md","hash":"443fe6704a02caeb0b60915894572ce2f073c34b","modified":1508901920000},{"_id":"source/_posts/11面试题.md","hash":"acb1078d190d81e5203e4f1bd51fb6100de95c04","modified":1500538343000},{"_id":"source/_posts/12深入理解Java虚拟机知识点.md","hash":"a4f35aff3d9cd85b0d521f1289da0223dfe395a0","modified":1500541378000},{"_id":"source/_posts/15Java编程实战知识点.md","hash":"581a9c7077a0b38491b2fea05258b63e3d064991","modified":1500625460000},{"_id":"source/_posts/16String-StringBuffer-StringBuilder性能对比.md","hash":"b4cf47095231f688e2b1f429d4cbd9ee573538c2","modified":1500638050000},{"_id":"source/_posts/19一些专业术语解析.md","hash":"9e04c6123743a4772cca83b7593724e7afe2d16b","modified":1505741163000},{"_id":"source/_posts/17Guava初探.md","hash":"abd336466f3143faeb389b8b0e0b0755841fa754","modified":1500968962000},{"_id":"source/_posts/18从Paxos到Zookeeper分布式一致性原理与实践.md","hash":"5301fa639b1efc391b82e696fa8aaceb74b92ad6","modified":1505739878000},{"_id":"source/_posts/20一致性哈希算法.md","hash":"82847f320a76264c26d44d0c2487c8b2d5df4ce8","modified":1505741085000},{"_id":"source/_posts/21程序员最核心的竞争力是什么？.md","hash":"7c631c30cf2f96dd917ad7826258f7a7ee2ee938","modified":1506499316000},{"_id":"source/_posts/22史上最全的Java-新手问题汇总.md","hash":"02127fb758bf3f9c7ad35b5932b8dccc88558335","modified":1506761071000},{"_id":"source/_posts/23RPC框架学习.md","hash":"d3d33574593890e0a3c8e3715fcd2031df18e77d","modified":1507796218000},{"_id":"source/_posts/1Hello.md","hash":"56c6399bdc8ae0be62513d436acd224ace5d4884","modified":1543390998940},{"_id":"source/_posts/24大型网站系统与Java中间件实战.md","hash":"e9170f0b8c45ce748cdc66c235a7e9c637d3f426","modified":1507796218000},{"_id":"source/_posts/25高并发服务设计——缓存.md","hash":"197b2df8cc21b4eb3958711a0f5c23d2b6ec2fce","modified":1516073705957},{"_id":"source/_posts/27web-xml详解.md","hash":"4d99f68d930852684dd55965934e5b6507c095b2","modified":1516073705950},{"_id":"source/_posts/2HelloMarkdown.md","hash":"b6252a432d73c9a72f486cfae1663bfae01f8761","modified":1543392917563},{"_id":"source/_posts/29ni真的了解TCP三次握手么？.md","hash":"20df739bbc650615ebebebfc4bb37dc37eee0bb9","modified":1543463595971},{"_id":"source/_posts/28POM文件详解.md","hash":"4343261c835615c0bc8d998f32a9b990e32ffece","modified":1517281268357},{"_id":"source/_posts/26Java面试题.md","hash":"b84e4edb95cda80d058c4bafa1da310f2cc2d279","modified":1544692617057},{"_id":"source/_posts/30IntegerCache-ByteCache-CharacterCache-LongCache-ShortCache.md","hash":"adb0697993010cb226651eabd76fb600dddd359b","modified":1543463595976},{"_id":"source/_posts/32java-web会话管理.md","hash":"fa7129950e59a47afaa5558512a9c1116ca35aae","modified":1543463595979},{"_id":"source/_posts/31git-ignore.md","hash":"293fcd760b2681035e45e2d4269efc04eb87454e","modified":1543390641396},{"_id":"source/_posts/4HashMap不同遍历方式性能比较.md","hash":"ca55e8d659bf3b8b7ac873d330d2b751c552bd70","modified":1500519338000},{"_id":"source/_posts/6Paxos算法.md","hash":"4287feeebae04506f66cef5451a5a540073738ea","modified":1543399158911},{"_id":"source/_posts/5技术框架入门.md","hash":"3e5f43e9389385e276a023ee57b3e8cc7fa7acaf","modified":1543459826821},{"_id":"source/_posts/3HashMap的循环方式性能对比.md","hash":"a98e9c933df65b8b92c05f8c2e0e3b4073d4fd6a","modified":1543397104571},{"_id":"source/_posts/7Java技术栈.md","hash":"4471bb5ede93003c3302fd3a1978e1c3bba4fad4","modified":1500538319000},{"_id":"source/_posts/8网络互连参考模型.md","hash":"82a59b6d2dcc8871bea444c4062377b7b1626f3c","modified":1500537999000},{"_id":"source/_posts/9Java集合.md","hash":"e0ed4a9551076b1077fa7d1fbab08dc998d97714","modified":1500538094000},{"_id":"source/book/index.md","hash":"d9d5b1eb12b78875e3701b4cdbcdbd553090ad09","modified":1535006677462},{"_id":"source/history/index.md","hash":"d7390473b91381d7c0c9124f60d6fc97de8d9b72","modified":1515754809422},{"_id":"themes/maupassant/.git/COMMIT_EDITMSG","hash":"e88c285cf9cc76731afa4eab4ac163515e9ce7d8","modified":1488595420000},{"_id":"themes/maupassant/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1486722094000},{"_id":"source/guestbook/index.md","hash":"0556ed40081fda72d0970d8eb00ec6b8f5db7afa","modified":1506070777000},{"_id":"themes/maupassant/.git/FETCH_HEAD","hash":"d4164d7ea2bf8baea20c51518e2f617507d9e22b","modified":1488595447000},{"_id":"themes/maupassant/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1486722068000},{"_id":"themes/maupassant/.git/ORIG_HEAD","hash":"e7de97753d00149057ca0ae9ed395fd347042cbf","modified":1488505369000},{"_id":"themes/maupassant/.git/config","hash":"2a740874e6d9e1117e31182fe7c5f52929651f1f","modified":1488595363000},{"_id":"themes/maupassant/.git/index","hash":"0fd845c7f798918a291766252fe406e55b56e096","modified":1488595420000},{"_id":"themes/maupassant/.git/packed-refs","hash":"965458983a3bb3e282036aa5812345d6370fe31d","modified":1486722094000},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1486722094000},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1486722094000},{"_id":"themes/maupassant/languages/en.yml","hash":"e13ab1a2d2f1edbe67b4c035fd4667cb6a31db8e","modified":1486722094000},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1486722094000},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1486722094000},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"7af6cb40860346e39a2aca30575dbf046d86eb4d","modified":1488511805000},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"56b65995c60e99dcebbf00168447fd225d28e5b2","modified":1486722094000},{"_id":"themes/maupassant/layout/archive.jade","hash":"0050c883b4f202add71c8664d65e6072179e7190","modified":1486722094000},{"_id":"themes/maupassant/layout/base-without-sidebar.jade","hash":"779c736a61a999292156ed23625b46e4ad69af86","modified":1488505369000},{"_id":"themes/maupassant/layout/base.jade","hash":"cf45b1ef9ffcb10973c7a79c2d5fc0318dc46ca6","modified":1488506072000},{"_id":"themes/maupassant/layout/index.jade","hash":"f842164f6cba007c1dfcd7fe7bba24736bc886a9","modified":1486722094000},{"_id":"themes/maupassant/layout/page.jade","hash":"8d70fd3b93f2c9087a9ea7ec538dcc1d413bea01","modified":1486722094000},{"_id":"themes/maupassant/layout/post.jade","hash":"82f6cfb792be98f09e33be4dcf11e3193dddee35","modified":1488506941000},{"_id":"themes/maupassant/layout/single-column.jade","hash":"c35fff4d9b331a41af5bc10f4278ec3d9da503db","modified":1486722094000},{"_id":"themes/maupassant/layout/timeline.jade","hash":"f03d8df63a188543cfe4e85e76194abe081411a1","modified":1486722094000},{"_id":"themes/maupassant/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1486722068000},{"_id":"themes/maupassant/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1486722068000},{"_id":"themes/maupassant/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1486722068000},{"_id":"themes/maupassant/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1486722068000},{"_id":"themes/maupassant/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1486722068000},{"_id":"themes/maupassant/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1486722068000},{"_id":"themes/maupassant/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1486722068000},{"_id":"themes/maupassant/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1486722068000},{"_id":"themes/maupassant/.git/logs/HEAD","hash":"22cd0eedd31c04ebfc5a3d4803654d600b12e67e","modified":1488595420000},{"_id":"themes/maupassant/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1486722068000},{"_id":"themes/maupassant/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1486722068000},{"_id":"themes/maupassant/layout/_partial/comments.jade","hash":"6c7f63ba04a4d28323ba31e79a4927f3d3fcc56e","modified":1486722094000},{"_id":"themes/maupassant/layout/_partial/after_footer.jade","hash":"3dbcc9a9f0d6e55da191d3393c18bbfcfe99fa69","modified":1486722094000},{"_id":"themes/maupassant/layout/_partial/donate.jade","hash":"f5b7870af16d56fedc84a282623123d84046d981","modified":1488506015000},{"_id":"themes/maupassant/layout/_partial/helpers.jade","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1486722094000},{"_id":"themes/maupassant/layout/_partial/footer.jade","hash":"aa020b794e697e8e9612530c97c6295efde469fe","modified":1486722094000},{"_id":"themes/maupassant/layout/_partial/mathjax2.jade","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1486722094000},{"_id":"themes/maupassant/layout/_partial/mathjax.jade","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1486722094000},{"_id":"themes/maupassant/layout/_partial/paginator.jade","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1486722094000},{"_id":"themes/maupassant/layout/_widget/category.jade","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1486722094000},{"_id":"themes/maupassant/layout/_partial/post_nav.jade","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1486722094000},{"_id":"themes/maupassant/layout/_partial/totop.jade","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1486722094000},{"_id":"themes/maupassant/layout/_partial/tag.jade","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1486722094000},{"_id":"themes/maupassant/layout/_widget/links.jade","hash":"f57a0c76d243882b2b77330132bdb43bc648948b","modified":1486722094000},{"_id":"themes/maupassant/layout/_widget/recent_comments.jade","hash":"e119c5afa85abc60d139e2da99b0bfcd7a6530f8","modified":1486722094000},{"_id":"themes/maupassant/layout/_widget/recent_posts.jade","hash":"19431336d724d2118e46da43683bce9063176541","modified":1486722094000},{"_id":"themes/maupassant/layout/_widget/search.jade","hash":"193546282908e499813534f86d27ef6e0a1357b3","modified":1486722094000},{"_id":"themes/maupassant/layout/_widget/tag.jade","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1486722094000},{"_id":"themes/maupassant/source/css/donate.scss","hash":"0b8d462a7914b6b1de8a1a3e60a71a5efa566f2b","modified":1488505957000},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","hash":"f42f761157f26244673eb2f4a9215c70956f80dc","modified":1486722094000},{"_id":"themes/maupassant/source/css/style.scss","hash":"158f1ebecf7b994ffae5332a627465f6bf38113b","modified":1486722094000},{"_id":"themes/maupassant/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1486722094000},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1486722094000},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1486722094000},{"_id":"themes/maupassant/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1486722094000},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1486722094000},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1486722094000},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1486722094000},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1486722094000},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1486722094000},{"_id":"themes/maupassant/source/js/share.js","hash":"f49776e0baa2b913ddc7a20db24b3edd469c8343","modified":1486722094000},{"_id":"themes/maupassant/source/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1486722094000},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1486722094000},{"_id":"themes/maupassant/.git/objects/0d/fdb25a5f9507325e44d45badead832b5647b5c","hash":"4e4cf65496de718d028456585007ee6324489abe","modified":1488595439000},{"_id":"themes/maupassant/.git/objects/3a/1e1e22de876b5065bc3a135ed75fe6f8fd1c7b","hash":"77218254237ad6ca56c3b4c65867129808284176","modified":1488595439000},{"_id":"themes/maupassant/.git/objects/47/1e11f671dd1e880019f292749b56f8aa7b8a31","hash":"c9c300c1c9ad3ecb77aadb69f2c8325f6503e492","modified":1488595420000},{"_id":"themes/maupassant/.git/objects/22/2fd90b62b188bc7434a67f7258ececd7cd78f9","hash":"7b319a6618f10fd3da98d3bdb2e338153292eeef","modified":1488595420000},{"_id":"themes/maupassant/.git/objects/20/8be15d19d2ee8613ade8c5a023fc5990ebf9fd","hash":"a9b46e2f56948672f00ab96d446e26aa63c464be","modified":1488595420000},{"_id":"themes/maupassant/.git/objects/20/fb037382a22e9f452a928f525b0fcfb07d8b9d","hash":"9fe6fca2c47c6775b5359bfcc14879f6c10561fd","modified":1488505369000},{"_id":"themes/maupassant/.git/objects/49/86718054760a46a89833155ab6e0527fa3d08d","hash":"2ede6031a3297e3579cd985e52a0c2c213436136","modified":1488595420000},{"_id":"themes/maupassant/.git/objects/54/52b895f8b786d93fc4fc760c11901a5208777c","hash":"8ff4bac280aad54691f723d851feac5041b6780f","modified":1488595420000},{"_id":"themes/maupassant/.git/objects/65/07abf46752580d9a91db0b47b5fc3113b06a24","hash":"8ab6bc63d72329fe4ef0257ab8ba63068e52fc30","modified":1488595439000},{"_id":"themes/maupassant/.git/objects/7c/4e6381892a5160f736768197a5e244da2ac05b","hash":"b37e431733375068c0369bb4c79dde69ac0d2e29","modified":1488595420000},{"_id":"themes/maupassant/.git/objects/6a/1bbbc32a566956dafbaf22eee62a517eb98bce","hash":"b1aee6912a448ec275d65d3b2ee4e545fb0a8dac","modified":1488595420000},{"_id":"themes/maupassant/.git/objects/85/45c393e8a54b961d9a545b5de4e67577d3ee6f","hash":"5bc586cb5c543ed748da1d4be362eb2f562d499c","modified":1488595420000},{"_id":"themes/maupassant/.git/objects/9c/f2fc51c5a1fb80a041a878a46251d971b76ff2","hash":"608bcac0ec1df07bfba7d9c29bdd02134fc02067","modified":1488505369000},{"_id":"themes/maupassant/.git/objects/99/c29024f2cd3fa82f7fb7fe14560490ddd33a93","hash":"f077dd5071426e3f2679fe30addbf9c5b72d81ed","modified":1488595420000},{"_id":"themes/maupassant/.git/objects/a9/fe43371d8b165f5699ab51948abfd84ae14443","hash":"b2a2e8f34ae70504a7c4837a738ab54ce31ecc0b","modified":1488505369000},{"_id":"themes/maupassant/.git/objects/b4/cd7c9d8c269d34604b408d085c54429b88d7e4","hash":"a612806b0d47d13fc79a7343fe0efdc9deaab22b","modified":1488595420000},{"_id":"themes/maupassant/.git/objects/b3/45124e1d06b16ce23c1b46df0c3eec99c23b6a","hash":"e7c8cadeed9b38fe730c8b22b51ab71d86f0271e","modified":1488595420000},{"_id":"themes/maupassant/.git/objects/bc/443b543828a59a0374b1353136806bbbb436dd","hash":"1ae3cc79e7d0123be0fe766ebb8330bca5e895b9","modified":1488595420000},{"_id":"themes/maupassant/.git/objects/b5/93d6b312b7852d92c93525948af6d60ad3cd2f","hash":"ce939409f45774d5f1c89fd8c2caeab790f659d1","modified":1488505369000},{"_id":"themes/maupassant/.git/objects/ed/edde910c79c7e2cc5a4233492fa8f4aae12cc9","hash":"d68a194dfd8b848d7d65c66c5bacca0af370215f","modified":1488595420000},{"_id":"themes/maupassant/.git/refs/heads/master","hash":"8613a9193deabd182f629be2fd88d4f84d1e5583","modified":1488595420000},{"_id":"themes/maupassant/.git/objects/pack/pack-c70ed9a27f076e153e10a9401c5b7b658b463745.idx","hash":"707d56b387a3799f8fdf471c051d10d5b5a63488","modified":1486722094000},{"_id":"themes/maupassant/.git/objects/bf/8fbcfd40200ad0e0ca4f7fa4810dc4b0a5a56e","hash":"f6b49a2a8d583ba8c30f87643382db23dc118a2f","modified":1488505369000},{"_id":"themes/maupassant/.git/logs/refs/heads/master","hash":"22cd0eedd31c04ebfc5a3d4803654d600b12e67e","modified":1488595420000},{"_id":"themes/maupassant/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1486722094000},{"_id":"themes/maupassant/.git/refs/remotes/icylogic/master","hash":"f5ca39c2b2b2c8aed470a2a6b7b26ee8caf0a0e5","modified":1488595439000},{"_id":"themes/maupassant/.git/refs/remotes/origin/master","hash":"77e07bd7afcad178079617a76eac285e03d4a873","modified":1488505369000},{"_id":"themes/maupassant/.git/logs/refs/remotes/origin/HEAD","hash":"20c32561730793adf861ff50067bc027afb1ee4a","modified":1486722094000},{"_id":"themes/maupassant/.git/logs/refs/remotes/icylogic/master","hash":"cb3582cfbe10bd4f81c41afbf038d130dd7e4716","modified":1488595439000},{"_id":"themes/maupassant/.git/logs/refs/remotes/origin/master","hash":"c643230c4cca555a3d1b3a9d8321d1d0da19b482","modified":1488505369000},{"_id":"themes/maupassant/.git/objects/pack/pack-c70ed9a27f076e153e10a9401c5b7b658b463745.pack","hash":"67c6d6a28e6efa3ec20dd6cb62c9ac7699b1cba1","modified":1486722094000},{"_id":"public/atom.xml","hash":"1638127f042aeff21345272bbd3a26ff031218dd","modified":1545221220452},{"_id":"public/about/index.html","hash":"43f33923b1df57201948c0b41134fcef9c0066ba","modified":1545221220487},{"_id":"public/history/index.html","hash":"f3008e50bdc5d5eacbb3df730cdb6876400135ec","modified":1545221220487},{"_id":"public/guestbook/index.html","hash":"cb518a1353acd990a80eaf7a88f8ea32b31740cb","modified":1545221220487},{"_id":"public/2018/08/30/32java-web会话管理/index.html","hash":"ef04188980a9fcb2d6ef8dfb9efb1ce86eb0755c","modified":1545221220487},{"_id":"public/2018/08/30/31git-ignore/index.html","hash":"a7eb65cfab9cccd8472e9d379c927fd996dc4189","modified":1545221220487},{"_id":"public/2018/08/30/30IntegerCache-ByteCache-CharacterCache-LongCache-ShortCache/index.html","hash":"1499fb197378aa183d1a4fabe5248138d6893264","modified":1545221220487},{"_id":"public/2017/10/12/24大型网站系统与Java中间件实战/index.html","hash":"33c3d3eed8ac1be31c0b96469c97130731814f6a","modified":1545221220487},{"_id":"public/2017/10/12/23RPC框架学习/index.html","hash":"eab424ac6473fd3170830cfc5b44cac5577769f2","modified":1545221220488},{"_id":"public/2017/09/15/19一些专业术语解析/index.html","hash":"3e34fd5c88060c47080ab76cfb5fdd6711e55026","modified":1545221220488},{"_id":"public/2017/07/25/17Guava初探/index.html","hash":"7f9199e1b14b588d9a13e3ed27bb4f6578779519","modified":1545221220488},{"_id":"public/2017/07/21/15Java编程实战知识点/index.html","hash":"013d81e929808bbb8c999691e96cae4c464107fd","modified":1545221220488},{"_id":"public/2017/07/19/13常见Jar包简介/index.html","hash":"b49bb8eafcd7ed8fe6b9c905f16e6d2c5f991b57","modified":1545221220488},{"_id":"public/2017/07/18/10Temp/index.html","hash":"196109c57b256eae41aede398dd8ed4a40747ef2","modified":1545221220488},{"_id":"public/2017/05/12/8网络互连参考模型/index.html","hash":"7c72808971cda61aace92b2f2e9077e7638f6be5","modified":1545221220488},{"_id":"public/2017/03/07/6Paxos算法/index.html","hash":"c2af8db571e3583a91f402973597ed94220a4c12","modified":1545221220488},{"_id":"public/2017/01/19/2HelloMarkdown/index.html","hash":"43fa4c0dfbe9351c13d5cad1b3609fd802e19996","modified":1545221220488},{"_id":"public/2016/12/09/1Hello/index.html","hash":"6420acc588ce018b571ab91131b9ad178fda751f","modified":1545221220488},{"_id":"public/categories/Temp/index.html","hash":"b73f31b0246be4685f4bcaf830e4bad489b761ba","modified":1545221220488},{"_id":"public/categories/Java/index.html","hash":"325546c55ce0ea496b04b096b115f09ce7d802b0","modified":1545221220488},{"_id":"public/categories/面试/index.html","hash":"e0ee2a1a0e61b6b060506ee5f73ce377c55580e4","modified":1545221220488},{"_id":"public/categories/技术/index.html","hash":"9b7b5a0026ee30223d8762850a58c52ea503c609","modified":1545221220488},{"_id":"public/categories/分布式/index.html","hash":"6f8dcf862ddc2ab26b00468ad8121eab29fc9e1b","modified":1545221220488},{"_id":"public/categories/Guava/index.html","hash":"e771862d028b875df6c233a720bb4ab63cd02890","modified":1545221220488},{"_id":"public/categories/职业规划/index.html","hash":"856832527f6318d69733f6465bd6a3f60a3dd330","modified":1545221220488},{"_id":"public/categories/RPC/index.html","hash":"35daa97d021a4f22d16d3035e5529e959fff9307","modified":1545221220488},{"_id":"public/categories/Book/index.html","hash":"c39b9c1d75991566fca751b53ee313432890896e","modified":1545221220488},{"_id":"public/categories/缓存/index.html","hash":"6bda8b83a4de4bb4b81454eae75ddc1ba6f3e822","modified":1545221220488},{"_id":"public/categories/博客技术/index.html","hash":"3e60c3d72e7c40761dce43000b700f12742deb92","modified":1545221220489},{"_id":"public/categories/计算机网络/index.html","hash":"2c43d91d97a6e578b758958c4d7e7b6c774d817f","modified":1545221220489},{"_id":"public/archives/index.html","hash":"1440f0501951668f174ec6820fc24282a2ebda32","modified":1545221220489},{"_id":"public/archives/page/2/index.html","hash":"186017ea610643b30d3d94f1066778a8f5c58d81","modified":1545221220489},{"_id":"public/archives/2016/index.html","hash":"ccc480f054aa5761893caf5451cf7f4fc96f0a94","modified":1545221220489},{"_id":"public/archives/2016/12/index.html","hash":"ccc480f054aa5761893caf5451cf7f4fc96f0a94","modified":1545221220489},{"_id":"public/archives/2017/index.html","hash":"4e35a7b5ee0fa445b0fef4704a357e2ebd9caa63","modified":1545221220489},{"_id":"public/archives/2017/page/2/index.html","hash":"7497ab35cfb5e792524d0f43a9a6b80595a82390","modified":1545221220489},{"_id":"public/archives/2017/01/index.html","hash":"bf59b2caae187e12cced2d343aaa6fe723796fe8","modified":1545221220489},{"_id":"public/archives/2017/02/index.html","hash":"5e940cf069a96d6c78546c0c39c094e75774fe51","modified":1545221220489},{"_id":"public/archives/2017/03/index.html","hash":"b78e239b20e1f43a56436f15a970d9f59ecfcd7b","modified":1545221220489},{"_id":"public/archives/2017/05/index.html","hash":"b66980b51acf495c89512af129317278d598adf5","modified":1545221220489},{"_id":"public/archives/2017/07/index.html","hash":"f3a9a4ba5fd15c734ef925331f464d3196e74552","modified":1545221220489},{"_id":"public/archives/2017/08/index.html","hash":"da6f6d0049ee5998a61cd4f713ce54c89172485c","modified":1545221220489},{"_id":"public/archives/2017/09/index.html","hash":"0b28792d8d7601a52afff01c4cb5ea8e6cbc3452","modified":1545221220489},{"_id":"public/archives/2017/10/index.html","hash":"a2342a959859eb693184446d50f22192b5db13b1","modified":1545221220489},{"_id":"public/archives/2017/11/index.html","hash":"39ee5b32f125c562136074df4fd55ea8f051bd38","modified":1545221220489},{"_id":"public/archives/2017/12/index.html","hash":"af754da74e48a7ff3d7606aacf27faa2322b4a53","modified":1545221220489},{"_id":"public/archives/2018/index.html","hash":"4296be6370695edbe1a483d0d2fecbcb637be4f6","modified":1545221220489},{"_id":"public/archives/2018/01/index.html","hash":"c9e6b4b8081ad9eedb56844acc973648eacde3b5","modified":1545221220489},{"_id":"public/archives/2018/07/index.html","hash":"9ce26238a14b8929d28d5d5e18d00d6dd37f5f82","modified":1545221220489},{"_id":"public/archives/2018/08/index.html","hash":"5d9e0636979bae009089015ae64877d1b014a3e6","modified":1545221220490},{"_id":"public/tags/Temp/index.html","hash":"b73f31b0246be4685f4bcaf830e4bad489b761ba","modified":1545221220490},{"_id":"public/tags/Java/index.html","hash":"e6ef0b878f20cd07f7cd6f6ee6108953e56ba617","modified":1545221220490},{"_id":"public/tags/面试-Java/index.html","hash":"97db23e6c1fbe7290dfee901217885cadfc5c987","modified":1545221220490},{"_id":"public/tags/Java-JVM-虚拟机/index.html","hash":"3dd16b6ac77448202964d82cc7e22daff99a579b","modified":1545221220490},{"_id":"public/tags/Java-专业术语/index.html","hash":"fcd2ef68fefef2f0c37c14c9b0ddfa8a445a7ba0","modified":1545221220490},{"_id":"public/tags/Java-Paxos-Zookeeper/index.html","hash":"344760bcb2b3d2ddc144b1b6b2679cc4a9948158","modified":1545221220490},{"_id":"public/tags/Java-Guava/index.html","hash":"7f4681833664b3de72bbb38351ccfb29b7e6a18c","modified":1545221220490},{"_id":"public/tags/算法/index.html","hash":"b751fdc3f11048b0fcd715a1b3787334c5ae544d","modified":1545221220490},{"_id":"public/tags/RPC/index.html","hash":"35daa97d021a4f22d16d3035e5529e959fff9307","modified":1545221220490},{"_id":"public/tags/Book/index.html","hash":"c39b9c1d75991566fca751b53ee313432890896e","modified":1545221220490},{"_id":"public/tags/Tech/index.html","hash":"67bf1c0458a9327bd530bff64480d8a028a51564","modified":1545221220490},{"_id":"public/tags/缓存-架构/index.html","hash":"c4f9b6630e41ec89c1512032c73b853a39c2f960","modified":1545221220490},{"_id":"public/tags/Paxos/index.html","hash":"3f6ec492874bc9beca261b8adbd890ea72732dac","modified":1545221220490},{"_id":"public/tags/Java-对比/index.html","hash":"ec33bdd64f034a58f0f666e030ebe237108e0545","modified":1545221220490},{"_id":"public/tags/Markdown/index.html","hash":"86833567b29b947653a2738d3ce5eb084cb8fc5b","modified":1545221220490},{"_id":"public/tags/Java-面试/index.html","hash":"cf65132e8906a1b2574a9677a244f8c57a24ea47","modified":1545221220490},{"_id":"public/tags/计算机网络/index.html","hash":"2c43d91d97a6e578b758958c4d7e7b6c774d817f","modified":1545221220490},{"_id":"public/book/index.html","hash":"0a89fa6418cc9e92020e7cf8f0a2ce70e4b0b37d","modified":1545221220490},{"_id":"public/2018/07/13/29ni真的了解TCP三次握手么？/index.html","hash":"646b692bbaae3db2aa6d8298ea8b62afac2ce5f8","modified":1545221220490},{"_id":"public/2018/01/15/28POM文件详解/index.html","hash":"0529ba5dde3a10fe204c1c68bf2760332c5c387d","modified":1545221220490},{"_id":"public/2017/12/27/27web-xml详解/index.html","hash":"21a62b24cf748444ffc9bf59bf311d9126f03674","modified":1545221220491},{"_id":"public/2017/11/16/26Java面试题/index.html","hash":"08def9094608cd3ab2c3821b9fb9d94f05d81938","modified":1545221220491},{"_id":"public/2017/10/12/25高并发服务设计——缓存/index.html","hash":"b8aa44c8c6354d66e431a28319237cd4489c3e3c","modified":1545221220491},{"_id":"public/2017/09/30/22史上最全的Java-新手问题汇总/index.html","hash":"7273a8572713fa627c74df39ac6158e59157e32a","modified":1545221220491},{"_id":"public/2017/09/27/21程序员最核心的竞争力是什么？/index.html","hash":"f777a3e18cdfb2b6150edc4cf50ed909ca698b74","modified":1545221220491},{"_id":"public/2017/09/18/20一致性哈希算法/index.html","hash":"b9bcc917372984fae15eb2ba285b5a0b85020b0b","modified":1545221220491},{"_id":"public/2017/08/14/18从Paxos到Zookeeper分布式一致性原理与实践/index.html","hash":"a8c9f17bc7563849351f95bfcc2d3b45db078e4b","modified":1545221220491},{"_id":"public/2017/07/21/16String-StringBuffer-StringBuilder性能对比/index.html","hash":"0cc61a799edcb754cdc03ba3c88caa3b8f520d58","modified":1545221220491},{"_id":"public/2017/07/19/14JAVA反射详解和优化/index.html","hash":"856c3c1674599e0250048439778863d5fd0c0bb4","modified":1545221220491},{"_id":"public/2017/07/19/12深入理解Java虚拟机知识点/index.html","hash":"1b5890d557a4d5af59cf0bf446221d645fe7d031","modified":1545221220491},{"_id":"public/2017/07/19/11面试题/index.html","hash":"c7c463880d657c495cfdc427b8225cd2c65b5668","modified":1545221220491},{"_id":"public/2017/07/18/9Java集合/index.html","hash":"754154a3823d7fa40e46bfb1b4768e6fbc1ea43a","modified":1545221220491},{"_id":"public/2017/03/09/7Java技术栈/index.html","hash":"9eb4f9a31239c8237c221c80e289a9605bda9a01","modified":1545221220491},{"_id":"public/2017/03/01/5技术框架入门/index.html","hash":"5833a8b67681db1555a56d405d59a5113c81eb61","modified":1545221220491},{"_id":"public/2017/02/11/4HashMap不同遍历方式性能比较/index.html","hash":"5d6d7e3aff29a3e761e5983fd680654fb40e384a","modified":1545221220492},{"_id":"public/2017/02/10/3HashMap的循环方式性能对比/index.html","hash":"d8b720517bec0efeb388f7e06eb7281dfff04910","modified":1545221220492},{"_id":"public/index.html","hash":"03f43a94a8c5a3f35abacc2a8f3bf8ec5d0a0e72","modified":1545221220492},{"_id":"public/page/2/index.html","hash":"65f81aefcf54ed8806c512ee35d8a15745adbff9","modified":1545221220492},{"_id":"public/CNAME","hash":"a47d25dfadc4f7908f63d18cb3e634d0885a6db8","modified":1545221220495},{"_id":"public/README","hash":"6690336aa81cb7eaf88da65f9f5015142b37f7b8","modified":1545221220495},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1545221220495},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1545221220496},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1545221220496},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1545221220496},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1545221220496},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1545221220496},{"_id":"public/favicon.ico","hash":"6dd2c0a614be7aa3574355db08ee2c540bcac129","modified":1545221220509},{"_id":"public/css/donate.css","hash":"f3baf114310d4706ececd2f887336a0c0636fc68","modified":1545221220537},{"_id":"public/css/jquery.fancybox.css","hash":"f42f761157f26244673eb2f4a9215c70956f80dc","modified":1545221220547},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1545221220547},{"_id":"public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1545221220547},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1545221220548},{"_id":"public/js/share.js","hash":"f49776e0baa2b913ddc7a20db24b3edd469c8343","modified":1545221220548},{"_id":"public/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1545221220548},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1545221220548},{"_id":"public/css/style.css","hash":"2afb6e7e24abf81c8b7b7d472fb0bb9b9a1eac16","modified":1545221220548}],"Category":[{"name":"Temp","_id":"cjpv4tc9g0004a7xwzidsscpq"},{"name":"Java","_id":"cjpv4tc9r0009a7xw0lii1r53"},{"name":"面试","_id":"cjpv4tc9w000fa7xwxx7mwsqh"},{"name":"技术","_id":"cjpv4tca70011a7xwbqzyrcrn"},{"name":"分布式","_id":"cjpv4tcaa0018a7xwxjhdsoej"},{"name":"Guava","_id":"cjpv4tcae001ga7xwmlxepqrj"},{"name":"职业规划","_id":"cjpv4tcam001ta7xw6bqjw4ii"},{"name":"RPC","_id":"cjpv4tcap001za7xw65b1r0tu"},{"name":"Book","_id":"cjpv4tcas0025a7xw7hodrfaf"},{"name":"博客技术","_id":"cjpv4tcaw002ca7xwzwtq2wr9"},{"name":"缓存","_id":"cjpv4tcb0002ja7xwb1xnfoaf"},{"name":"计算机网络","_id":"cjpv4tcb3002va7xwn2zs3a5x"}],"Data":[],"Page":[{"title":"关于我","date":"1990-08-21T22:23:23.000Z","tags":"我","categories":"我","layout":"single-column","_content":"***\n#### 基本信息\n姓名: 孟德鑫\n邮箱: mengdexin_work@163.com\n毕业院校: 南京邮电大学\n个人简介: 目前在美团点评任后端开发工程师\nCSDN博客: http://blog.csdn.net/bingbing8219 (已不更新)\n***","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 1990-08-22 07:23:23\ntags: 我\ncategories: \"我\"\nlayout: single-column\n---\n***\n#### 基本信息\n姓名: 孟德鑫\n邮箱: mengdexin_work@163.com\n毕业院校: 南京邮电大学\n个人简介: 目前在美团点评任后端开发工程师\nCSDN博客: http://blog.csdn.net/bingbing8219 (已不更新)\n***","updated":"2018-01-12T10:57:43.868Z","path":"about/index.html","comments":1,"_id":"cjpv4tc940000a7xwxoc93496","content":"<hr>\n<h4 id=\"基本信息\"><a href=\"#基本信息\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h4><p>姓名: 孟德鑫<br>邮箱: mengdexin_work@163.com<br>毕业院校: 南京邮电大学<br>个人简介: 目前在美团点评任后端开发工程师<br>CSDN博客: <a href=\"http://blog.csdn.net/bingbing8219\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/bingbing8219</a> (已不更新)</p>\n<hr>\n","excerpt":"","more":"<hr>\n<h4 id=\"基本信息\"><a href=\"#基本信息\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h4><p>姓名: 孟德鑫<br>邮箱: mengdexin_work@163.com<br>毕业院校: 南京邮电大学<br>个人简介: 目前在美团点评任后端开发工程师<br>CSDN博客: <a href=\"http://blog.csdn.net/bingbing8219\">http://blog.csdn.net/bingbing8219</a> (已不更新)</p>\n<hr>\n"},{"title":"书单","date":"2016-05-09T01:00:00.000Z","tags":"书单","categories":"书单","layout":"single-column","_content":"***\n#### 技术\n##### [鸟哥的linux私房菜(基础学习篇)](https://book.douban.com/subject/4889838/)---Done\n##### [大型网站技术架构(李智慧)](https://book.douban.com/subject/25723064/)---Done\n##### [分布式Java应用基础与实践(林昊)](https://book.douban.com/subject/4848587/)---Done\n##### [Java核心技术(卷一)](https://book.douban.com/subject/25762168/)---Done\n##### [Java编程思想(Thinking in Java)](https://book.douban.com/subject/1313042/)---Done\n##### [深入理解Java虚拟机(周志明)](https://book.douban.com/subject/24722612/)---Done\n##### [Java技术手册](https://book.douban.com/subject/26674131/)---Done\n##### [Spring MVC学习指南](https://book.douban.com/subject/26411275/)---Done\n##### [Java并发编程的艺术](https://book.douban.com/subject/26591326/)---Doing\n##### [大型网站系统与Java中间件实战(曾贤杰)](https://book.douban.com/subject/25867042/)---Doing\n##### [Java并发编程实战](https://book.douban.com/subject/10484692/)---Doing\n##### [Java性能优化权威指南](https://book.douban.com/subject/25828043/)---Doing\n##### [Java程序员修炼之道](https://book.douban.com/subject/24841235/)---Doing\n##### [Java虚拟机规范(JavaSE8/JavaSE7)](https://book.douban.com/subject/26418340/)---Have\n##### [Effective Java 中文版](https://book.douban.com/subject/3360807/)---Doing\n##### [重构:改善既有代码的设计](https://book.douban.com/subject/4262627/)---Doing\n##### [深入浅出MyBatis技术原理与实战](https://book.douban.com/subject/26858114/)---Doing\n##### [代码的未来](https://book.douban.com/subject/24536403/)---Doing\n##### [性能之巅](https://book.douban.com/subject/26586598/)---Have\n##### [Redis实战](https://book.douban.com/subject/26612779/)---Have\n##### [高性能MySQL](https://book.douban.com/subject/23008813/)---Have\n##### [从Paxos到Zookeeper分布式一致性原理与实践](https://book.douban.com/subject/26292004/)---Have\n##### [Maven实战(徐晓斌)](https://book.douban.com/subject/5345682/)---Have\n##### [大型网站系统与Java中间件开发实践(曾宪杰)](https://book.douban.com/subject/25867042/)---Have\n##### [Redis设计与实现(黄建宏)](https://book.douban.com/subject/25900156/)---Have\n##### [深入剖析Tomcat](https://book.douban.com/subject/10426640/)---Have\n##### [Maven实战(许晓斌)](https://book.douban.com/subject/5345682/)---Have\n##### [深入理解Nginx 模块开发与架构解析](https://book.douban.com/subject/22793675/)---Have\n##### [Netty权威指南](https://book.douban.com/subject/25897245/)---Have\n##### [Netty实战](https://book.douban.com/subject/27038538/)---Have\n##### [JavaEE开发的颠覆者 Spring Boot实战](https://book.douban.com/subject/26762595/)---Doing\n##### [深入理解Elastic Search](https://book.douban.com/subject/26733541/)---Doing\n##### [ElasticSearch服务器开发](https://book.douban.com/subject/26318087/)---Doing\n##### [改变未来的九大算法](https://book.douban.com/subject/24529132/)---Doing\n***\n#### 科技\n##### [浪潮之巅(吴军)](https://book.douban.com/subject/6709783/)---Have\n##### [数学之美(吴军)](https://book.douban.com/subject/26163454/)---Doing\n***\n#### 人文\n##### [活着(余华)](https://book.douban.com/subject/4913064/)---Done\n##### [小王子(安托万·德·圣·埃克苏佩里)](https://book.douban.com/subject/1084336/)---Done\n##### [白鹿原(陈忠实)](https://book.douban.com/subject/1085799/)---Doing\n##### [解忧杂货店(东野圭吾)](https://book.douban.com/subject/25862578/)---Doing\n##### [人类简史(尤瓦尔·赫拉利)](https://book.douban.com/subject/25985021/)---Doing\n##### [未来简史(尤瓦尔·赫拉利)](https://book.douban.com/subject/26943161/)---Doing\n##### [三体(刘慈欣)](https://book.douban.com/subject/2567698/)---Doing\n##### [枪炮、病菌与钢铁(贾雷德·戴蒙德 )](https://book.douban.com/subject/1813841/)---Doing\n***\n#### 推荐电影:IMBD上面很火的电影大家基本都看过,推荐一些相对小众的电影\n##### [当爱来临的时候](https://movie.douban.com/subject/4304212/)(原来，我喜欢阳光的感觉.)\n***\n#### 经济\n##### [国富论(亚当.斯密)](https://book.douban.com/subject/1261560/)\n***\n#### other\nftp://ftp1.linuxidc.com\nftp1.linuxidc.com\nwww.linuxidc.com","source":"book/index.md","raw":"---\ntitle: 书单\ndate: 2016-05-09 09:00:00\ntags: 书单\ncategories: \"书单\"\nlayout: single-column\n---\n***\n#### 技术\n##### [鸟哥的linux私房菜(基础学习篇)](https://book.douban.com/subject/4889838/)---Done\n##### [大型网站技术架构(李智慧)](https://book.douban.com/subject/25723064/)---Done\n##### [分布式Java应用基础与实践(林昊)](https://book.douban.com/subject/4848587/)---Done\n##### [Java核心技术(卷一)](https://book.douban.com/subject/25762168/)---Done\n##### [Java编程思想(Thinking in Java)](https://book.douban.com/subject/1313042/)---Done\n##### [深入理解Java虚拟机(周志明)](https://book.douban.com/subject/24722612/)---Done\n##### [Java技术手册](https://book.douban.com/subject/26674131/)---Done\n##### [Spring MVC学习指南](https://book.douban.com/subject/26411275/)---Done\n##### [Java并发编程的艺术](https://book.douban.com/subject/26591326/)---Doing\n##### [大型网站系统与Java中间件实战(曾贤杰)](https://book.douban.com/subject/25867042/)---Doing\n##### [Java并发编程实战](https://book.douban.com/subject/10484692/)---Doing\n##### [Java性能优化权威指南](https://book.douban.com/subject/25828043/)---Doing\n##### [Java程序员修炼之道](https://book.douban.com/subject/24841235/)---Doing\n##### [Java虚拟机规范(JavaSE8/JavaSE7)](https://book.douban.com/subject/26418340/)---Have\n##### [Effective Java 中文版](https://book.douban.com/subject/3360807/)---Doing\n##### [重构:改善既有代码的设计](https://book.douban.com/subject/4262627/)---Doing\n##### [深入浅出MyBatis技术原理与实战](https://book.douban.com/subject/26858114/)---Doing\n##### [代码的未来](https://book.douban.com/subject/24536403/)---Doing\n##### [性能之巅](https://book.douban.com/subject/26586598/)---Have\n##### [Redis实战](https://book.douban.com/subject/26612779/)---Have\n##### [高性能MySQL](https://book.douban.com/subject/23008813/)---Have\n##### [从Paxos到Zookeeper分布式一致性原理与实践](https://book.douban.com/subject/26292004/)---Have\n##### [Maven实战(徐晓斌)](https://book.douban.com/subject/5345682/)---Have\n##### [大型网站系统与Java中间件开发实践(曾宪杰)](https://book.douban.com/subject/25867042/)---Have\n##### [Redis设计与实现(黄建宏)](https://book.douban.com/subject/25900156/)---Have\n##### [深入剖析Tomcat](https://book.douban.com/subject/10426640/)---Have\n##### [Maven实战(许晓斌)](https://book.douban.com/subject/5345682/)---Have\n##### [深入理解Nginx 模块开发与架构解析](https://book.douban.com/subject/22793675/)---Have\n##### [Netty权威指南](https://book.douban.com/subject/25897245/)---Have\n##### [Netty实战](https://book.douban.com/subject/27038538/)---Have\n##### [JavaEE开发的颠覆者 Spring Boot实战](https://book.douban.com/subject/26762595/)---Doing\n##### [深入理解Elastic Search](https://book.douban.com/subject/26733541/)---Doing\n##### [ElasticSearch服务器开发](https://book.douban.com/subject/26318087/)---Doing\n##### [改变未来的九大算法](https://book.douban.com/subject/24529132/)---Doing\n***\n#### 科技\n##### [浪潮之巅(吴军)](https://book.douban.com/subject/6709783/)---Have\n##### [数学之美(吴军)](https://book.douban.com/subject/26163454/)---Doing\n***\n#### 人文\n##### [活着(余华)](https://book.douban.com/subject/4913064/)---Done\n##### [小王子(安托万·德·圣·埃克苏佩里)](https://book.douban.com/subject/1084336/)---Done\n##### [白鹿原(陈忠实)](https://book.douban.com/subject/1085799/)---Doing\n##### [解忧杂货店(东野圭吾)](https://book.douban.com/subject/25862578/)---Doing\n##### [人类简史(尤瓦尔·赫拉利)](https://book.douban.com/subject/25985021/)---Doing\n##### [未来简史(尤瓦尔·赫拉利)](https://book.douban.com/subject/26943161/)---Doing\n##### [三体(刘慈欣)](https://book.douban.com/subject/2567698/)---Doing\n##### [枪炮、病菌与钢铁(贾雷德·戴蒙德 )](https://book.douban.com/subject/1813841/)---Doing\n***\n#### 推荐电影:IMBD上面很火的电影大家基本都看过,推荐一些相对小众的电影\n##### [当爱来临的时候](https://movie.douban.com/subject/4304212/)(原来，我喜欢阳光的感觉.)\n***\n#### 经济\n##### [国富论(亚当.斯密)](https://book.douban.com/subject/1261560/)\n***\n#### other\nftp://ftp1.linuxidc.com\nftp1.linuxidc.com\nwww.linuxidc.com","updated":"2018-08-23T06:44:37.462Z","path":"book/index.html","comments":1,"_id":"cjpv4tc9a0002a7xwhj8f2s91","content":"<hr>\n<h4 id=\"技术\"><a href=\"#技术\" class=\"headerlink\" title=\"技术\"></a>技术</h4><h5 id=\"鸟哥的linux私房菜-基础学习篇-—Done\"><a href=\"#鸟哥的linux私房菜-基础学习篇-—Done\" class=\"headerlink\" title=\"鸟哥的linux私房菜(基础学习篇)—Done\"></a><a href=\"https://book.douban.com/subject/4889838/\" target=\"_blank\" rel=\"external\">鸟哥的linux私房菜(基础学习篇)</a>—Done</h5><h5 id=\"大型网站技术架构-李智慧-—Done\"><a href=\"#大型网站技术架构-李智慧-—Done\" class=\"headerlink\" title=\"大型网站技术架构(李智慧)—Done\"></a><a href=\"https://book.douban.com/subject/25723064/\" target=\"_blank\" rel=\"external\">大型网站技术架构(李智慧)</a>—Done</h5><h5 id=\"分布式Java应用基础与实践-林昊-—Done\"><a href=\"#分布式Java应用基础与实践-林昊-—Done\" class=\"headerlink\" title=\"分布式Java应用基础与实践(林昊)—Done\"></a><a href=\"https://book.douban.com/subject/4848587/\" target=\"_blank\" rel=\"external\">分布式Java应用基础与实践(林昊)</a>—Done</h5><h5 id=\"Java核心技术-卷一-—Done\"><a href=\"#Java核心技术-卷一-—Done\" class=\"headerlink\" title=\"Java核心技术(卷一)—Done\"></a><a href=\"https://book.douban.com/subject/25762168/\" target=\"_blank\" rel=\"external\">Java核心技术(卷一)</a>—Done</h5><h5 id=\"Java编程思想-Thinking-in-Java-—Done\"><a href=\"#Java编程思想-Thinking-in-Java-—Done\" class=\"headerlink\" title=\"Java编程思想(Thinking in Java)—Done\"></a><a href=\"https://book.douban.com/subject/1313042/\" target=\"_blank\" rel=\"external\">Java编程思想(Thinking in Java)</a>—Done</h5><h5 id=\"深入理解Java虚拟机-周志明-—Done\"><a href=\"#深入理解Java虚拟机-周志明-—Done\" class=\"headerlink\" title=\"深入理解Java虚拟机(周志明)—Done\"></a><a href=\"https://book.douban.com/subject/24722612/\" target=\"_blank\" rel=\"external\">深入理解Java虚拟机(周志明)</a>—Done</h5><h5 id=\"Java技术手册—Done\"><a href=\"#Java技术手册—Done\" class=\"headerlink\" title=\"Java技术手册—Done\"></a><a href=\"https://book.douban.com/subject/26674131/\" target=\"_blank\" rel=\"external\">Java技术手册</a>—Done</h5><h5 id=\"Spring-MVC学习指南—Done\"><a href=\"#Spring-MVC学习指南—Done\" class=\"headerlink\" title=\"Spring MVC学习指南—Done\"></a><a href=\"https://book.douban.com/subject/26411275/\" target=\"_blank\" rel=\"external\">Spring MVC学习指南</a>—Done</h5><h5 id=\"Java并发编程的艺术—Doing\"><a href=\"#Java并发编程的艺术—Doing\" class=\"headerlink\" title=\"Java并发编程的艺术—Doing\"></a><a href=\"https://book.douban.com/subject/26591326/\" target=\"_blank\" rel=\"external\">Java并发编程的艺术</a>—Doing</h5><h5 id=\"大型网站系统与Java中间件实战-曾贤杰-—Doing\"><a href=\"#大型网站系统与Java中间件实战-曾贤杰-—Doing\" class=\"headerlink\" title=\"大型网站系统与Java中间件实战(曾贤杰)—Doing\"></a><a href=\"https://book.douban.com/subject/25867042/\" target=\"_blank\" rel=\"external\">大型网站系统与Java中间件实战(曾贤杰)</a>—Doing</h5><h5 id=\"Java并发编程实战—Doing\"><a href=\"#Java并发编程实战—Doing\" class=\"headerlink\" title=\"Java并发编程实战—Doing\"></a><a href=\"https://book.douban.com/subject/10484692/\" target=\"_blank\" rel=\"external\">Java并发编程实战</a>—Doing</h5><h5 id=\"Java性能优化权威指南—Doing\"><a href=\"#Java性能优化权威指南—Doing\" class=\"headerlink\" title=\"Java性能优化权威指南—Doing\"></a><a href=\"https://book.douban.com/subject/25828043/\" target=\"_blank\" rel=\"external\">Java性能优化权威指南</a>—Doing</h5><h5 id=\"Java程序员修炼之道—Doing\"><a href=\"#Java程序员修炼之道—Doing\" class=\"headerlink\" title=\"Java程序员修炼之道—Doing\"></a><a href=\"https://book.douban.com/subject/24841235/\" target=\"_blank\" rel=\"external\">Java程序员修炼之道</a>—Doing</h5><h5 id=\"Java虚拟机规范-JavaSE8-JavaSE7-—Have\"><a href=\"#Java虚拟机规范-JavaSE8-JavaSE7-—Have\" class=\"headerlink\" title=\"Java虚拟机规范(JavaSE8/JavaSE7)—Have\"></a><a href=\"https://book.douban.com/subject/26418340/\" target=\"_blank\" rel=\"external\">Java虚拟机规范(JavaSE8/JavaSE7)</a>—Have</h5><h5 id=\"Effective-Java-中文版—Doing\"><a href=\"#Effective-Java-中文版—Doing\" class=\"headerlink\" title=\"Effective Java 中文版—Doing\"></a><a href=\"https://book.douban.com/subject/3360807/\" target=\"_blank\" rel=\"external\">Effective Java 中文版</a>—Doing</h5><h5 id=\"重构-改善既有代码的设计—Doing\"><a href=\"#重构-改善既有代码的设计—Doing\" class=\"headerlink\" title=\"重构:改善既有代码的设计—Doing\"></a><a href=\"https://book.douban.com/subject/4262627/\" target=\"_blank\" rel=\"external\">重构:改善既有代码的设计</a>—Doing</h5><h5 id=\"深入浅出MyBatis技术原理与实战—Doing\"><a href=\"#深入浅出MyBatis技术原理与实战—Doing\" class=\"headerlink\" title=\"深入浅出MyBatis技术原理与实战—Doing\"></a><a href=\"https://book.douban.com/subject/26858114/\" target=\"_blank\" rel=\"external\">深入浅出MyBatis技术原理与实战</a>—Doing</h5><h5 id=\"代码的未来—Doing\"><a href=\"#代码的未来—Doing\" class=\"headerlink\" title=\"代码的未来—Doing\"></a><a href=\"https://book.douban.com/subject/24536403/\" target=\"_blank\" rel=\"external\">代码的未来</a>—Doing</h5><h5 id=\"性能之巅—Have\"><a href=\"#性能之巅—Have\" class=\"headerlink\" title=\"性能之巅—Have\"></a><a href=\"https://book.douban.com/subject/26586598/\" target=\"_blank\" rel=\"external\">性能之巅</a>—Have</h5><h5 id=\"Redis实战—Have\"><a href=\"#Redis实战—Have\" class=\"headerlink\" title=\"Redis实战—Have\"></a><a href=\"https://book.douban.com/subject/26612779/\" target=\"_blank\" rel=\"external\">Redis实战</a>—Have</h5><h5 id=\"高性能MySQL—Have\"><a href=\"#高性能MySQL—Have\" class=\"headerlink\" title=\"高性能MySQL—Have\"></a><a href=\"https://book.douban.com/subject/23008813/\" target=\"_blank\" rel=\"external\">高性能MySQL</a>—Have</h5><h5 id=\"从Paxos到Zookeeper分布式一致性原理与实践—Have\"><a href=\"#从Paxos到Zookeeper分布式一致性原理与实践—Have\" class=\"headerlink\" title=\"从Paxos到Zookeeper分布式一致性原理与实践—Have\"></a><a href=\"https://book.douban.com/subject/26292004/\" target=\"_blank\" rel=\"external\">从Paxos到Zookeeper分布式一致性原理与实践</a>—Have</h5><h5 id=\"Maven实战-徐晓斌-—Have\"><a href=\"#Maven实战-徐晓斌-—Have\" class=\"headerlink\" title=\"Maven实战(徐晓斌)—Have\"></a><a href=\"https://book.douban.com/subject/5345682/\" target=\"_blank\" rel=\"external\">Maven实战(徐晓斌)</a>—Have</h5><h5 id=\"大型网站系统与Java中间件开发实践-曾宪杰-—Have\"><a href=\"#大型网站系统与Java中间件开发实践-曾宪杰-—Have\" class=\"headerlink\" title=\"大型网站系统与Java中间件开发实践(曾宪杰)—Have\"></a><a href=\"https://book.douban.com/subject/25867042/\" target=\"_blank\" rel=\"external\">大型网站系统与Java中间件开发实践(曾宪杰)</a>—Have</h5><h5 id=\"Redis设计与实现-黄建宏-—Have\"><a href=\"#Redis设计与实现-黄建宏-—Have\" class=\"headerlink\" title=\"Redis设计与实现(黄建宏)—Have\"></a><a href=\"https://book.douban.com/subject/25900156/\" target=\"_blank\" rel=\"external\">Redis设计与实现(黄建宏)</a>—Have</h5><h5 id=\"深入剖析Tomcat—Have\"><a href=\"#深入剖析Tomcat—Have\" class=\"headerlink\" title=\"深入剖析Tomcat—Have\"></a><a href=\"https://book.douban.com/subject/10426640/\" target=\"_blank\" rel=\"external\">深入剖析Tomcat</a>—Have</h5><h5 id=\"Maven实战-许晓斌-—Have\"><a href=\"#Maven实战-许晓斌-—Have\" class=\"headerlink\" title=\"Maven实战(许晓斌)—Have\"></a><a href=\"https://book.douban.com/subject/5345682/\" target=\"_blank\" rel=\"external\">Maven实战(许晓斌)</a>—Have</h5><h5 id=\"深入理解Nginx-模块开发与架构解析—Have\"><a href=\"#深入理解Nginx-模块开发与架构解析—Have\" class=\"headerlink\" title=\"深入理解Nginx 模块开发与架构解析—Have\"></a><a href=\"https://book.douban.com/subject/22793675/\" target=\"_blank\" rel=\"external\">深入理解Nginx 模块开发与架构解析</a>—Have</h5><h5 id=\"Netty权威指南—Have\"><a href=\"#Netty权威指南—Have\" class=\"headerlink\" title=\"Netty权威指南—Have\"></a><a href=\"https://book.douban.com/subject/25897245/\" target=\"_blank\" rel=\"external\">Netty权威指南</a>—Have</h5><h5 id=\"Netty实战—Have\"><a href=\"#Netty实战—Have\" class=\"headerlink\" title=\"Netty实战—Have\"></a><a href=\"https://book.douban.com/subject/27038538/\" target=\"_blank\" rel=\"external\">Netty实战</a>—Have</h5><h5 id=\"JavaEE开发的颠覆者-Spring-Boot实战—Doing\"><a href=\"#JavaEE开发的颠覆者-Spring-Boot实战—Doing\" class=\"headerlink\" title=\"JavaEE开发的颠覆者 Spring Boot实战—Doing\"></a><a href=\"https://book.douban.com/subject/26762595/\" target=\"_blank\" rel=\"external\">JavaEE开发的颠覆者 Spring Boot实战</a>—Doing</h5><h5 id=\"深入理解Elastic-Search—Doing\"><a href=\"#深入理解Elastic-Search—Doing\" class=\"headerlink\" title=\"深入理解Elastic Search—Doing\"></a><a href=\"https://book.douban.com/subject/26733541/\" target=\"_blank\" rel=\"external\">深入理解Elastic Search</a>—Doing</h5><h5 id=\"ElasticSearch服务器开发—Doing\"><a href=\"#ElasticSearch服务器开发—Doing\" class=\"headerlink\" title=\"ElasticSearch服务器开发—Doing\"></a><a href=\"https://book.douban.com/subject/26318087/\" target=\"_blank\" rel=\"external\">ElasticSearch服务器开发</a>—Doing</h5><h5 id=\"改变未来的九大算法—Doing\"><a href=\"#改变未来的九大算法—Doing\" class=\"headerlink\" title=\"改变未来的九大算法—Doing\"></a><a href=\"https://book.douban.com/subject/24529132/\" target=\"_blank\" rel=\"external\">改变未来的九大算法</a>—Doing</h5><hr>\n<h4 id=\"科技\"><a href=\"#科技\" class=\"headerlink\" title=\"科技\"></a>科技</h4><h5 id=\"浪潮之巅-吴军-—Have\"><a href=\"#浪潮之巅-吴军-—Have\" class=\"headerlink\" title=\"浪潮之巅(吴军)—Have\"></a><a href=\"https://book.douban.com/subject/6709783/\" target=\"_blank\" rel=\"external\">浪潮之巅(吴军)</a>—Have</h5><h5 id=\"数学之美-吴军-—Doing\"><a href=\"#数学之美-吴军-—Doing\" class=\"headerlink\" title=\"数学之美(吴军)—Doing\"></a><a href=\"https://book.douban.com/subject/26163454/\" target=\"_blank\" rel=\"external\">数学之美(吴军)</a>—Doing</h5><hr>\n<h4 id=\"人文\"><a href=\"#人文\" class=\"headerlink\" title=\"人文\"></a>人文</h4><h5 id=\"活着-余华-—Done\"><a href=\"#活着-余华-—Done\" class=\"headerlink\" title=\"活着(余华)—Done\"></a><a href=\"https://book.douban.com/subject/4913064/\" target=\"_blank\" rel=\"external\">活着(余华)</a>—Done</h5><h5 id=\"小王子-安托万·德·圣·埃克苏佩里-—Done\"><a href=\"#小王子-安托万·德·圣·埃克苏佩里-—Done\" class=\"headerlink\" title=\"小王子(安托万·德·圣·埃克苏佩里)—Done\"></a><a href=\"https://book.douban.com/subject/1084336/\" target=\"_blank\" rel=\"external\">小王子(安托万·德·圣·埃克苏佩里)</a>—Done</h5><h5 id=\"白鹿原-陈忠实-—Doing\"><a href=\"#白鹿原-陈忠实-—Doing\" class=\"headerlink\" title=\"白鹿原(陈忠实)—Doing\"></a><a href=\"https://book.douban.com/subject/1085799/\" target=\"_blank\" rel=\"external\">白鹿原(陈忠实)</a>—Doing</h5><h5 id=\"解忧杂货店-东野圭吾-—Doing\"><a href=\"#解忧杂货店-东野圭吾-—Doing\" class=\"headerlink\" title=\"解忧杂货店(东野圭吾)—Doing\"></a><a href=\"https://book.douban.com/subject/25862578/\" target=\"_blank\" rel=\"external\">解忧杂货店(东野圭吾)</a>—Doing</h5><h5 id=\"人类简史-尤瓦尔·赫拉利-—Doing\"><a href=\"#人类简史-尤瓦尔·赫拉利-—Doing\" class=\"headerlink\" title=\"人类简史(尤瓦尔·赫拉利)—Doing\"></a><a href=\"https://book.douban.com/subject/25985021/\" target=\"_blank\" rel=\"external\">人类简史(尤瓦尔·赫拉利)</a>—Doing</h5><h5 id=\"未来简史-尤瓦尔·赫拉利-—Doing\"><a href=\"#未来简史-尤瓦尔·赫拉利-—Doing\" class=\"headerlink\" title=\"未来简史(尤瓦尔·赫拉利)—Doing\"></a><a href=\"https://book.douban.com/subject/26943161/\" target=\"_blank\" rel=\"external\">未来简史(尤瓦尔·赫拉利)</a>—Doing</h5><h5 id=\"三体-刘慈欣-—Doing\"><a href=\"#三体-刘慈欣-—Doing\" class=\"headerlink\" title=\"三体(刘慈欣)—Doing\"></a><a href=\"https://book.douban.com/subject/2567698/\" target=\"_blank\" rel=\"external\">三体(刘慈欣)</a>—Doing</h5><h5 id=\"枪炮、病菌与钢铁-贾雷德·戴蒙德-—Doing\"><a href=\"#枪炮、病菌与钢铁-贾雷德·戴蒙德-—Doing\" class=\"headerlink\" title=\"枪炮、病菌与钢铁(贾雷德·戴蒙德 )—Doing\"></a><a href=\"https://book.douban.com/subject/1813841/\" target=\"_blank\" rel=\"external\">枪炮、病菌与钢铁(贾雷德·戴蒙德 )</a>—Doing</h5><hr>\n<h4 id=\"推荐电影-IMBD上面很火的电影大家基本都看过-推荐一些相对小众的电影\"><a href=\"#推荐电影-IMBD上面很火的电影大家基本都看过-推荐一些相对小众的电影\" class=\"headerlink\" title=\"推荐电影:IMBD上面很火的电影大家基本都看过,推荐一些相对小众的电影\"></a>推荐电影:IMBD上面很火的电影大家基本都看过,推荐一些相对小众的电影</h4><h5 id=\"当爱来临的时候-原来，我喜欢阳光的感觉\"><a href=\"#当爱来临的时候-原来，我喜欢阳光的感觉\" class=\"headerlink\" title=\"当爱来临的时候(原来，我喜欢阳光的感觉.)\"></a><a href=\"https://movie.douban.com/subject/4304212/\" target=\"_blank\" rel=\"external\">当爱来临的时候</a>(原来，我喜欢阳光的感觉.)</h5><hr>\n<h4 id=\"经济\"><a href=\"#经济\" class=\"headerlink\" title=\"经济\"></a>经济</h4><h5 id=\"国富论-亚当-斯密\"><a href=\"#国富论-亚当-斯密\" class=\"headerlink\" title=\"国富论(亚当.斯密)\"></a><a href=\"https://book.douban.com/subject/1261560/\" target=\"_blank\" rel=\"external\">国富论(亚当.斯密)</a></h5><hr>\n<h4 id=\"other\"><a href=\"#other\" class=\"headerlink\" title=\"other\"></a>other</h4><p>ftp://ftp1.linuxidc.com<br>ftp1.linuxidc.com<br>www.linuxidc.com</p>\n","excerpt":"","more":"<hr>\n<h4 id=\"技术\"><a href=\"#技术\" class=\"headerlink\" title=\"技术\"></a>技术</h4><h5 id=\"鸟哥的linux私房菜-基础学习篇-—Done\"><a href=\"#鸟哥的linux私房菜-基础学习篇-—Done\" class=\"headerlink\" title=\"鸟哥的linux私房菜(基础学习篇)—Done\"></a><a href=\"https://book.douban.com/subject/4889838/\">鸟哥的linux私房菜(基础学习篇)</a>—Done</h5><h5 id=\"大型网站技术架构-李智慧-—Done\"><a href=\"#大型网站技术架构-李智慧-—Done\" class=\"headerlink\" title=\"大型网站技术架构(李智慧)—Done\"></a><a href=\"https://book.douban.com/subject/25723064/\">大型网站技术架构(李智慧)</a>—Done</h5><h5 id=\"分布式Java应用基础与实践-林昊-—Done\"><a href=\"#分布式Java应用基础与实践-林昊-—Done\" class=\"headerlink\" title=\"分布式Java应用基础与实践(林昊)—Done\"></a><a href=\"https://book.douban.com/subject/4848587/\">分布式Java应用基础与实践(林昊)</a>—Done</h5><h5 id=\"Java核心技术-卷一-—Done\"><a href=\"#Java核心技术-卷一-—Done\" class=\"headerlink\" title=\"Java核心技术(卷一)—Done\"></a><a href=\"https://book.douban.com/subject/25762168/\">Java核心技术(卷一)</a>—Done</h5><h5 id=\"Java编程思想-Thinking-in-Java-—Done\"><a href=\"#Java编程思想-Thinking-in-Java-—Done\" class=\"headerlink\" title=\"Java编程思想(Thinking in Java)—Done\"></a><a href=\"https://book.douban.com/subject/1313042/\">Java编程思想(Thinking in Java)</a>—Done</h5><h5 id=\"深入理解Java虚拟机-周志明-—Done\"><a href=\"#深入理解Java虚拟机-周志明-—Done\" class=\"headerlink\" title=\"深入理解Java虚拟机(周志明)—Done\"></a><a href=\"https://book.douban.com/subject/24722612/\">深入理解Java虚拟机(周志明)</a>—Done</h5><h5 id=\"Java技术手册—Done\"><a href=\"#Java技术手册—Done\" class=\"headerlink\" title=\"Java技术手册—Done\"></a><a href=\"https://book.douban.com/subject/26674131/\">Java技术手册</a>—Done</h5><h5 id=\"Spring-MVC学习指南—Done\"><a href=\"#Spring-MVC学习指南—Done\" class=\"headerlink\" title=\"Spring MVC学习指南—Done\"></a><a href=\"https://book.douban.com/subject/26411275/\">Spring MVC学习指南</a>—Done</h5><h5 id=\"Java并发编程的艺术—Doing\"><a href=\"#Java并发编程的艺术—Doing\" class=\"headerlink\" title=\"Java并发编程的艺术—Doing\"></a><a href=\"https://book.douban.com/subject/26591326/\">Java并发编程的艺术</a>—Doing</h5><h5 id=\"大型网站系统与Java中间件实战-曾贤杰-—Doing\"><a href=\"#大型网站系统与Java中间件实战-曾贤杰-—Doing\" class=\"headerlink\" title=\"大型网站系统与Java中间件实战(曾贤杰)—Doing\"></a><a href=\"https://book.douban.com/subject/25867042/\">大型网站系统与Java中间件实战(曾贤杰)</a>—Doing</h5><h5 id=\"Java并发编程实战—Doing\"><a href=\"#Java并发编程实战—Doing\" class=\"headerlink\" title=\"Java并发编程实战—Doing\"></a><a href=\"https://book.douban.com/subject/10484692/\">Java并发编程实战</a>—Doing</h5><h5 id=\"Java性能优化权威指南—Doing\"><a href=\"#Java性能优化权威指南—Doing\" class=\"headerlink\" title=\"Java性能优化权威指南—Doing\"></a><a href=\"https://book.douban.com/subject/25828043/\">Java性能优化权威指南</a>—Doing</h5><h5 id=\"Java程序员修炼之道—Doing\"><a href=\"#Java程序员修炼之道—Doing\" class=\"headerlink\" title=\"Java程序员修炼之道—Doing\"></a><a href=\"https://book.douban.com/subject/24841235/\">Java程序员修炼之道</a>—Doing</h5><h5 id=\"Java虚拟机规范-JavaSE8-JavaSE7-—Have\"><a href=\"#Java虚拟机规范-JavaSE8-JavaSE7-—Have\" class=\"headerlink\" title=\"Java虚拟机规范(JavaSE8/JavaSE7)—Have\"></a><a href=\"https://book.douban.com/subject/26418340/\">Java虚拟机规范(JavaSE8/JavaSE7)</a>—Have</h5><h5 id=\"Effective-Java-中文版—Doing\"><a href=\"#Effective-Java-中文版—Doing\" class=\"headerlink\" title=\"Effective Java 中文版—Doing\"></a><a href=\"https://book.douban.com/subject/3360807/\">Effective Java 中文版</a>—Doing</h5><h5 id=\"重构-改善既有代码的设计—Doing\"><a href=\"#重构-改善既有代码的设计—Doing\" class=\"headerlink\" title=\"重构:改善既有代码的设计—Doing\"></a><a href=\"https://book.douban.com/subject/4262627/\">重构:改善既有代码的设计</a>—Doing</h5><h5 id=\"深入浅出MyBatis技术原理与实战—Doing\"><a href=\"#深入浅出MyBatis技术原理与实战—Doing\" class=\"headerlink\" title=\"深入浅出MyBatis技术原理与实战—Doing\"></a><a href=\"https://book.douban.com/subject/26858114/\">深入浅出MyBatis技术原理与实战</a>—Doing</h5><h5 id=\"代码的未来—Doing\"><a href=\"#代码的未来—Doing\" class=\"headerlink\" title=\"代码的未来—Doing\"></a><a href=\"https://book.douban.com/subject/24536403/\">代码的未来</a>—Doing</h5><h5 id=\"性能之巅—Have\"><a href=\"#性能之巅—Have\" class=\"headerlink\" title=\"性能之巅—Have\"></a><a href=\"https://book.douban.com/subject/26586598/\">性能之巅</a>—Have</h5><h5 id=\"Redis实战—Have\"><a href=\"#Redis实战—Have\" class=\"headerlink\" title=\"Redis实战—Have\"></a><a href=\"https://book.douban.com/subject/26612779/\">Redis实战</a>—Have</h5><h5 id=\"高性能MySQL—Have\"><a href=\"#高性能MySQL—Have\" class=\"headerlink\" title=\"高性能MySQL—Have\"></a><a href=\"https://book.douban.com/subject/23008813/\">高性能MySQL</a>—Have</h5><h5 id=\"从Paxos到Zookeeper分布式一致性原理与实践—Have\"><a href=\"#从Paxos到Zookeeper分布式一致性原理与实践—Have\" class=\"headerlink\" title=\"从Paxos到Zookeeper分布式一致性原理与实践—Have\"></a><a href=\"https://book.douban.com/subject/26292004/\">从Paxos到Zookeeper分布式一致性原理与实践</a>—Have</h5><h5 id=\"Maven实战-徐晓斌-—Have\"><a href=\"#Maven实战-徐晓斌-—Have\" class=\"headerlink\" title=\"Maven实战(徐晓斌)—Have\"></a><a href=\"https://book.douban.com/subject/5345682/\">Maven实战(徐晓斌)</a>—Have</h5><h5 id=\"大型网站系统与Java中间件开发实践-曾宪杰-—Have\"><a href=\"#大型网站系统与Java中间件开发实践-曾宪杰-—Have\" class=\"headerlink\" title=\"大型网站系统与Java中间件开发实践(曾宪杰)—Have\"></a><a href=\"https://book.douban.com/subject/25867042/\">大型网站系统与Java中间件开发实践(曾宪杰)</a>—Have</h5><h5 id=\"Redis设计与实现-黄建宏-—Have\"><a href=\"#Redis设计与实现-黄建宏-—Have\" class=\"headerlink\" title=\"Redis设计与实现(黄建宏)—Have\"></a><a href=\"https://book.douban.com/subject/25900156/\">Redis设计与实现(黄建宏)</a>—Have</h5><h5 id=\"深入剖析Tomcat—Have\"><a href=\"#深入剖析Tomcat—Have\" class=\"headerlink\" title=\"深入剖析Tomcat—Have\"></a><a href=\"https://book.douban.com/subject/10426640/\">深入剖析Tomcat</a>—Have</h5><h5 id=\"Maven实战-许晓斌-—Have\"><a href=\"#Maven实战-许晓斌-—Have\" class=\"headerlink\" title=\"Maven实战(许晓斌)—Have\"></a><a href=\"https://book.douban.com/subject/5345682/\">Maven实战(许晓斌)</a>—Have</h5><h5 id=\"深入理解Nginx-模块开发与架构解析—Have\"><a href=\"#深入理解Nginx-模块开发与架构解析—Have\" class=\"headerlink\" title=\"深入理解Nginx 模块开发与架构解析—Have\"></a><a href=\"https://book.douban.com/subject/22793675/\">深入理解Nginx 模块开发与架构解析</a>—Have</h5><h5 id=\"Netty权威指南—Have\"><a href=\"#Netty权威指南—Have\" class=\"headerlink\" title=\"Netty权威指南—Have\"></a><a href=\"https://book.douban.com/subject/25897245/\">Netty权威指南</a>—Have</h5><h5 id=\"Netty实战—Have\"><a href=\"#Netty实战—Have\" class=\"headerlink\" title=\"Netty实战—Have\"></a><a href=\"https://book.douban.com/subject/27038538/\">Netty实战</a>—Have</h5><h5 id=\"JavaEE开发的颠覆者-Spring-Boot实战—Doing\"><a href=\"#JavaEE开发的颠覆者-Spring-Boot实战—Doing\" class=\"headerlink\" title=\"JavaEE开发的颠覆者 Spring Boot实战—Doing\"></a><a href=\"https://book.douban.com/subject/26762595/\">JavaEE开发的颠覆者 Spring Boot实战</a>—Doing</h5><h5 id=\"深入理解Elastic-Search—Doing\"><a href=\"#深入理解Elastic-Search—Doing\" class=\"headerlink\" title=\"深入理解Elastic Search—Doing\"></a><a href=\"https://book.douban.com/subject/26733541/\">深入理解Elastic Search</a>—Doing</h5><h5 id=\"ElasticSearch服务器开发—Doing\"><a href=\"#ElasticSearch服务器开发—Doing\" class=\"headerlink\" title=\"ElasticSearch服务器开发—Doing\"></a><a href=\"https://book.douban.com/subject/26318087/\">ElasticSearch服务器开发</a>—Doing</h5><h5 id=\"改变未来的九大算法—Doing\"><a href=\"#改变未来的九大算法—Doing\" class=\"headerlink\" title=\"改变未来的九大算法—Doing\"></a><a href=\"https://book.douban.com/subject/24529132/\">改变未来的九大算法</a>—Doing</h5><hr>\n<h4 id=\"科技\"><a href=\"#科技\" class=\"headerlink\" title=\"科技\"></a>科技</h4><h5 id=\"浪潮之巅-吴军-—Have\"><a href=\"#浪潮之巅-吴军-—Have\" class=\"headerlink\" title=\"浪潮之巅(吴军)—Have\"></a><a href=\"https://book.douban.com/subject/6709783/\">浪潮之巅(吴军)</a>—Have</h5><h5 id=\"数学之美-吴军-—Doing\"><a href=\"#数学之美-吴军-—Doing\" class=\"headerlink\" title=\"数学之美(吴军)—Doing\"></a><a href=\"https://book.douban.com/subject/26163454/\">数学之美(吴军)</a>—Doing</h5><hr>\n<h4 id=\"人文\"><a href=\"#人文\" class=\"headerlink\" title=\"人文\"></a>人文</h4><h5 id=\"活着-余华-—Done\"><a href=\"#活着-余华-—Done\" class=\"headerlink\" title=\"活着(余华)—Done\"></a><a href=\"https://book.douban.com/subject/4913064/\">活着(余华)</a>—Done</h5><h5 id=\"小王子-安托万·德·圣·埃克苏佩里-—Done\"><a href=\"#小王子-安托万·德·圣·埃克苏佩里-—Done\" class=\"headerlink\" title=\"小王子(安托万·德·圣·埃克苏佩里)—Done\"></a><a href=\"https://book.douban.com/subject/1084336/\">小王子(安托万·德·圣·埃克苏佩里)</a>—Done</h5><h5 id=\"白鹿原-陈忠实-—Doing\"><a href=\"#白鹿原-陈忠实-—Doing\" class=\"headerlink\" title=\"白鹿原(陈忠实)—Doing\"></a><a href=\"https://book.douban.com/subject/1085799/\">白鹿原(陈忠实)</a>—Doing</h5><h5 id=\"解忧杂货店-东野圭吾-—Doing\"><a href=\"#解忧杂货店-东野圭吾-—Doing\" class=\"headerlink\" title=\"解忧杂货店(东野圭吾)—Doing\"></a><a href=\"https://book.douban.com/subject/25862578/\">解忧杂货店(东野圭吾)</a>—Doing</h5><h5 id=\"人类简史-尤瓦尔·赫拉利-—Doing\"><a href=\"#人类简史-尤瓦尔·赫拉利-—Doing\" class=\"headerlink\" title=\"人类简史(尤瓦尔·赫拉利)—Doing\"></a><a href=\"https://book.douban.com/subject/25985021/\">人类简史(尤瓦尔·赫拉利)</a>—Doing</h5><h5 id=\"未来简史-尤瓦尔·赫拉利-—Doing\"><a href=\"#未来简史-尤瓦尔·赫拉利-—Doing\" class=\"headerlink\" title=\"未来简史(尤瓦尔·赫拉利)—Doing\"></a><a href=\"https://book.douban.com/subject/26943161/\">未来简史(尤瓦尔·赫拉利)</a>—Doing</h5><h5 id=\"三体-刘慈欣-—Doing\"><a href=\"#三体-刘慈欣-—Doing\" class=\"headerlink\" title=\"三体(刘慈欣)—Doing\"></a><a href=\"https://book.douban.com/subject/2567698/\">三体(刘慈欣)</a>—Doing</h5><h5 id=\"枪炮、病菌与钢铁-贾雷德·戴蒙德-—Doing\"><a href=\"#枪炮、病菌与钢铁-贾雷德·戴蒙德-—Doing\" class=\"headerlink\" title=\"枪炮、病菌与钢铁(贾雷德·戴蒙德 )—Doing\"></a><a href=\"https://book.douban.com/subject/1813841/\">枪炮、病菌与钢铁(贾雷德·戴蒙德 )</a>—Doing</h5><hr>\n<h4 id=\"推荐电影-IMBD上面很火的电影大家基本都看过-推荐一些相对小众的电影\"><a href=\"#推荐电影-IMBD上面很火的电影大家基本都看过-推荐一些相对小众的电影\" class=\"headerlink\" title=\"推荐电影:IMBD上面很火的电影大家基本都看过,推荐一些相对小众的电影\"></a>推荐电影:IMBD上面很火的电影大家基本都看过,推荐一些相对小众的电影</h4><h5 id=\"当爱来临的时候-原来，我喜欢阳光的感觉\"><a href=\"#当爱来临的时候-原来，我喜欢阳光的感觉\" class=\"headerlink\" title=\"当爱来临的时候(原来，我喜欢阳光的感觉.)\"></a><a href=\"https://movie.douban.com/subject/4304212/\">当爱来临的时候</a>(原来，我喜欢阳光的感觉.)</h5><hr>\n<h4 id=\"经济\"><a href=\"#经济\" class=\"headerlink\" title=\"经济\"></a>经济</h4><h5 id=\"国富论-亚当-斯密\"><a href=\"#国富论-亚当-斯密\" class=\"headerlink\" title=\"国富论(亚当.斯密)\"></a><a href=\"https://book.douban.com/subject/1261560/\">国富论(亚当.斯密)</a></h5><hr>\n<h4 id=\"other\"><a href=\"#other\" class=\"headerlink\" title=\"other\"></a>other</h4><p>ftp://ftp1.linuxidc.com<br>ftp1.linuxidc.com<br>www.linuxidc.com</p>\n"},{"title":"历史","date":"1990-08-21T22:23:23.000Z","tags":"历史","categories":"历史","layout":"single-column","_content":"\n***\n2013.09.18 ~ 2016.05.09 南京邮电大学(研究生)\n~2014.08.09 ~ 2015.03.09 途牛旅游网(实习)\n~2015.03.09 ~ 2015.09.09 富士通南大软件技术有限公司(实习)\n2016.05.09 ~ 至今 美团点评(工作)\n***","source":"history/index.md","raw":"---\ntitle: 历史\ndate: 1990-08-22 07:23:23\ntags: 历史\ncategories: \"历史\"\nlayout: single-column\n---\n\n***\n2013.09.18 ~ 2016.05.09 南京邮电大学(研究生)\n~2014.08.09 ~ 2015.03.09 途牛旅游网(实习)\n~2015.03.09 ~ 2015.09.09 富士通南大软件技术有限公司(实习)\n2016.05.09 ~ 至今 美团点评(工作)\n***","updated":"2018-01-12T11:00:09.422Z","path":"history/index.html","comments":1,"_id":"cjpv4tcu3003ca7xw4sevpoo0","content":"<hr>\n<p>2013.09.18 ~ 2016.05.09 南京邮电大学(研究生)<br>~2014.08.09 ~ 2015.03.09 途牛旅游网(实习)<br>~2015.03.09 ~ 2015.09.09 富士通南大软件技术有限公司(实习)<br>2016.05.09 ~ 至今 美团点评(工作)</p>\n<hr>\n","excerpt":"","more":"<hr>\n<p>2013.09.18 ~ 2016.05.09 南京邮电大学(研究生)<br>~2014.08.09 ~ 2015.03.09 途牛旅游网(实习)<br>~2015.03.09 ~ 2015.09.09 富士通南大软件技术有限公司(实习)<br>2016.05.09 ~ 至今 美团点评(工作)</p>\n<hr>\n"},{"title":"留言板","date":"2016-05-09T01:00:00.000Z","tags":"留言板","categories":"留言板","layout":"single-column","_content":"(暂时关闭)\n\n大家一起交流~~~","source":"guestbook/index.md","raw":"---\ntitle: 留言板\ndate: 2016-05-09 09:00:00\ntags: 留言板\ncategories: \"留言板\"\nlayout: single-column\n---\n(暂时关闭)\n\n大家一起交流~~~","updated":"2017-09-22T08:59:37.000Z","path":"guestbook/index.html","comments":1,"_id":"cjpv4tcu4003da7xwpff0ekz2","content":"<p>(暂时关闭)</p>\n<p>大家一起交流~~~</p>\n","excerpt":"","more":"<p>(暂时关闭)</p>\n<p>大家一起交流~~~</p>\n"}],"Post":[{"title":"Temp","date":"2017-07-18T11:28:57.000Z","_content":"```\n放一些自己需要强制记忆、经常踩坑、特别重要、看书时候觉得重要的文字。\n```\n<!--more-->\n1. 进程之间通过粗粒度的通信机制来交换数据:套接字、信号处理器、共享内存、信号量以及文件;\n2. 无状态对象一定是线程安全的;\n3. 凡是对成员变量或者本地变量(在方法中的或者代码块中的变量称为本地变量)声明为final的都叫作final变量。\n4. mutable 可变的;\n5. 一个对象是不是线程安全的,取决于他是否被多个线程访问;\n6. 当多个线程访问某个类时,某个类始终都能表现出正确的行为,就称这个类是线程安全的;\n7. 同步容器都是线程安全的: HashTable、Vector;\n8. 系统负载System Load：系统CPU繁忙程度的度量，即有多少进程在等待被CPU调度;\n9. 如果CPU是8核，load<8是不会有问题的;\n10. Java 中的 instanceof 运算符是用来在运行时指出对象是否是特定类的一个实例。\n12. 1.对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；如果作用于引用类型的变量，则比较的是所指向的对象的地址;\n    2.对于equals方法，注意：equals方法不能作用于基本数据类型的变量,如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址,诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。\n13. 对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象.\n14. 进程让操作系统的并发性成为可能，而线程让进程的内部并发成为可能。\n15. 进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位。\n16. CPU密集型的使用多线程效果更好,I/O密集型的多线程线程数少一点更好,有一个公式的: ;\n17. 线程从创建到最终的消亡，要经历若干个状态。一般来说，线程包括以下这几个状态：创建(new)、就绪(runnable)、运行(running)、阻塞(blocked)、time waiting、waiting、消亡（dead）。\n18. sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象。\n19. 原子操作（atomic operation）意为\"不可被中断的一个或一系列操作\" 。\n20. Java的对象序列化是指将那些实现了Serializable接口的对象转换成一个字符序列，并能够在以后将这个字节序列完全恢复为原来的对象。\n21. 你会发现Timeout是个非常难处理的事情，因为网络上的Timeout在很多时候让你无所事从，你也不知道对方是做了还是没有做。于是你好好的一个状态机就因为Timeout成了个摆设。\n22. 一个网络服务会有三种状态：1）Success，2）Failure，3）Timeout，第三个绝对是恶梦，尤其在你需要维护状态的时候。\n23. 同步、异步、阻塞、非阻塞\n* 同步 ： 自己亲自出马持银行卡到银行取钱（使用同步IO时，Java自己处理IO读写）。\n* 异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS需要支持异步IO操作API）。\n* 阻塞 ： ATM排队取款，你只能等待（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）。\n* 非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器会通知可读写时再继续进行读写，不断循环直到读写完成）。\n25. 网络IO的实现方式有:BIO(Block IO采用阻塞的方式实现)、NIO(Nonblocking IO基于事件驱动思想,采用Reactor方式,一个线程可以处理多个socket)、AIO(AsynchronousIO 异步IO,采用Proactor模式)\n26. 事务处理:2PC、3PC、最终一致、BASE、CAP、Paxos\n27. 在java中应为不同的目的可以将java划分为两种内存模型：gc内存模型,并发内存模型。\n\n\n\n","source":"_posts/10Temp.md","raw":"---\ntitle: Temp\ndate: 2017-07-18 19:28:57\ntags: Temp\ncategories: \"Temp\"\n---\n```\n放一些自己需要强制记忆、经常踩坑、特别重要、看书时候觉得重要的文字。\n```\n<!--more-->\n1. 进程之间通过粗粒度的通信机制来交换数据:套接字、信号处理器、共享内存、信号量以及文件;\n2. 无状态对象一定是线程安全的;\n3. 凡是对成员变量或者本地变量(在方法中的或者代码块中的变量称为本地变量)声明为final的都叫作final变量。\n4. mutable 可变的;\n5. 一个对象是不是线程安全的,取决于他是否被多个线程访问;\n6. 当多个线程访问某个类时,某个类始终都能表现出正确的行为,就称这个类是线程安全的;\n7. 同步容器都是线程安全的: HashTable、Vector;\n8. 系统负载System Load：系统CPU繁忙程度的度量，即有多少进程在等待被CPU调度;\n9. 如果CPU是8核，load<8是不会有问题的;\n10. Java 中的 instanceof 运算符是用来在运行时指出对象是否是特定类的一个实例。\n12. 1.对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；如果作用于引用类型的变量，则比较的是所指向的对象的地址;\n    2.对于equals方法，注意：equals方法不能作用于基本数据类型的变量,如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址,诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。\n13. 对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象.\n14. 进程让操作系统的并发性成为可能，而线程让进程的内部并发成为可能。\n15. 进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位。\n16. CPU密集型的使用多线程效果更好,I/O密集型的多线程线程数少一点更好,有一个公式的: ;\n17. 线程从创建到最终的消亡，要经历若干个状态。一般来说，线程包括以下这几个状态：创建(new)、就绪(runnable)、运行(running)、阻塞(blocked)、time waiting、waiting、消亡（dead）。\n18. sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象。\n19. 原子操作（atomic operation）意为\"不可被中断的一个或一系列操作\" 。\n20. Java的对象序列化是指将那些实现了Serializable接口的对象转换成一个字符序列，并能够在以后将这个字节序列完全恢复为原来的对象。\n21. 你会发现Timeout是个非常难处理的事情，因为网络上的Timeout在很多时候让你无所事从，你也不知道对方是做了还是没有做。于是你好好的一个状态机就因为Timeout成了个摆设。\n22. 一个网络服务会有三种状态：1）Success，2）Failure，3）Timeout，第三个绝对是恶梦，尤其在你需要维护状态的时候。\n23. 同步、异步、阻塞、非阻塞\n* 同步 ： 自己亲自出马持银行卡到银行取钱（使用同步IO时，Java自己处理IO读写）。\n* 异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS需要支持异步IO操作API）。\n* 阻塞 ： ATM排队取款，你只能等待（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）。\n* 非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器会通知可读写时再继续进行读写，不断循环直到读写完成）。\n25. 网络IO的实现方式有:BIO(Block IO采用阻塞的方式实现)、NIO(Nonblocking IO基于事件驱动思想,采用Reactor方式,一个线程可以处理多个socket)、AIO(AsynchronousIO 异步IO,采用Proactor模式)\n26. 事务处理:2PC、3PC、最终一致、BASE、CAP、Paxos\n27. 在java中应为不同的目的可以将java划分为两种内存模型：gc内存模型,并发内存模型。\n\n\n\n","slug":"10Temp","published":1,"updated":"2017-10-25T03:25:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tc960001a7xw8sbeduqi","content":"<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">放一些自己需要强制记忆、经常踩坑、特别重要、看书时候觉得重要的文字。</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<ol>\n<li>进程之间通过粗粒度的通信机制来交换数据:套接字、信号处理器、共享内存、信号量以及文件;</li>\n<li>无状态对象一定是线程安全的;</li>\n<li>凡是对成员变量或者本地变量(在方法中的或者代码块中的变量称为本地变量)声明为final的都叫作final变量。</li>\n<li>mutable 可变的;</li>\n<li>一个对象是不是线程安全的,取决于他是否被多个线程访问;</li>\n<li>当多个线程访问某个类时,某个类始终都能表现出正确的行为,就称这个类是线程安全的;</li>\n<li>同步容器都是线程安全的: HashTable、Vector;</li>\n<li>系统负载System Load：系统CPU繁忙程度的度量，即有多少进程在等待被CPU调度;</li>\n<li>如果CPU是8核，load&lt;8是不会有问题的;</li>\n<li>Java 中的 instanceof 运算符是用来在运行时指出对象是否是特定类的一个实例。</li>\n<li>1.对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；如果作用于引用类型的变量，则比较的是所指向的对象的地址;<br>2.对于equals方法，注意：equals方法不能作用于基本数据类型的变量,如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址,诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。</li>\n<li>对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象.</li>\n<li>进程让操作系统的并发性成为可能，而线程让进程的内部并发成为可能。</li>\n<li>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位。</li>\n<li>CPU密集型的使用多线程效果更好,I/O密集型的多线程线程数少一点更好,有一个公式的: ;</li>\n<li>线程从创建到最终的消亡，要经历若干个状态。一般来说，线程包括以下这几个状态：创建(new)、就绪(runnable)、运行(running)、阻塞(blocked)、time waiting、waiting、消亡（dead）。</li>\n<li>sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象。</li>\n<li>原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。</li>\n<li>Java的对象序列化是指将那些实现了Serializable接口的对象转换成一个字符序列，并能够在以后将这个字节序列完全恢复为原来的对象。</li>\n<li>你会发现Timeout是个非常难处理的事情，因为网络上的Timeout在很多时候让你无所事从，你也不知道对方是做了还是没有做。于是你好好的一个状态机就因为Timeout成了个摆设。</li>\n<li>一个网络服务会有三种状态：1）Success，2）Failure，3）Timeout，第三个绝对是恶梦，尤其在你需要维护状态的时候。</li>\n<li>同步、异步、阻塞、非阻塞</li>\n</ol>\n<ul>\n<li>同步 ： 自己亲自出马持银行卡到银行取钱（使用同步IO时，Java自己处理IO读写）。</li>\n<li>异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS需要支持异步IO操作API）。</li>\n<li>阻塞 ： ATM排队取款，你只能等待（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）。</li>\n<li>非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器会通知可读写时再继续进行读写，不断循环直到读写完成）。</li>\n</ul>\n<ol>\n<li>网络IO的实现方式有:BIO(Block IO采用阻塞的方式实现)、NIO(Nonblocking IO基于事件驱动思想,采用Reactor方式,一个线程可以处理多个socket)、AIO(AsynchronousIO 异步IO,采用Proactor模式)</li>\n<li>事务处理:2PC、3PC、最终一致、BASE、CAP、Paxos</li>\n<li>在java中应为不同的目的可以将java划分为两种内存模型：gc内存模型,并发内存模型。</li>\n</ol>\n","excerpt":"<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">放一些自己需要强制记忆、经常踩坑、特别重要、看书时候觉得重要的文字。</div></pre></td></tr></table></figure>","more":"<ol>\n<li>进程之间通过粗粒度的通信机制来交换数据:套接字、信号处理器、共享内存、信号量以及文件;</li>\n<li>无状态对象一定是线程安全的;</li>\n<li>凡是对成员变量或者本地变量(在方法中的或者代码块中的变量称为本地变量)声明为final的都叫作final变量。</li>\n<li>mutable 可变的;</li>\n<li>一个对象是不是线程安全的,取决于他是否被多个线程访问;</li>\n<li>当多个线程访问某个类时,某个类始终都能表现出正确的行为,就称这个类是线程安全的;</li>\n<li>同步容器都是线程安全的: HashTable、Vector;</li>\n<li>系统负载System Load：系统CPU繁忙程度的度量，即有多少进程在等待被CPU调度;</li>\n<li>如果CPU是8核，load&lt;8是不会有问题的;</li>\n<li>Java 中的 instanceof 运算符是用来在运行时指出对象是否是特定类的一个实例。</li>\n<li>1.对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；如果作用于引用类型的变量，则比较的是所指向的对象的地址;<br>2.对于equals方法，注意：equals方法不能作用于基本数据类型的变量,如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址,诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。</li>\n<li>对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象.</li>\n<li>进程让操作系统的并发性成为可能，而线程让进程的内部并发成为可能。</li>\n<li>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位。</li>\n<li>CPU密集型的使用多线程效果更好,I/O密集型的多线程线程数少一点更好,有一个公式的: ;</li>\n<li>线程从创建到最终的消亡，要经历若干个状态。一般来说，线程包括以下这几个状态：创建(new)、就绪(runnable)、运行(running)、阻塞(blocked)、time waiting、waiting、消亡（dead）。</li>\n<li>sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象。</li>\n<li>原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。</li>\n<li>Java的对象序列化是指将那些实现了Serializable接口的对象转换成一个字符序列，并能够在以后将这个字节序列完全恢复为原来的对象。</li>\n<li>你会发现Timeout是个非常难处理的事情，因为网络上的Timeout在很多时候让你无所事从，你也不知道对方是做了还是没有做。于是你好好的一个状态机就因为Timeout成了个摆设。</li>\n<li>一个网络服务会有三种状态：1）Success，2）Failure，3）Timeout，第三个绝对是恶梦，尤其在你需要维护状态的时候。</li>\n<li>同步、异步、阻塞、非阻塞</li>\n</ol>\n<ul>\n<li>同步 ： 自己亲自出马持银行卡到银行取钱（使用同步IO时，Java自己处理IO读写）。</li>\n<li>异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS需要支持异步IO操作API）。</li>\n<li>阻塞 ： ATM排队取款，你只能等待（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）。</li>\n<li>非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器会通知可读写时再继续进行读写，不断循环直到读写完成）。</li>\n</ul>\n<ol>\n<li>网络IO的实现方式有:BIO(Block IO采用阻塞的方式实现)、NIO(Nonblocking IO基于事件驱动思想,采用Reactor方式,一个线程可以处理多个socket)、AIO(AsynchronousIO 异步IO,采用Proactor模式)</li>\n<li>事务处理:2PC、3PC、最终一致、BASE、CAP、Paxos</li>\n<li>在java中应为不同的目的可以将java划分为两种内存模型：gc内存模型,并发内存模型。</li>\n</ol>"},{"title":"JAVA反射详解和优化","date":"2017-07-19T11:32:28.000Z","toc":true,"_content":"### 1.何为反射机制\n反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。\n<!--more-->\n\n### 2.反射的应用场景\n1. 在运行时判断任意一个对象所属的类；\n2. 在运行时构造任意一个类的对象；\n3. 在运行时判断任意一个类所具有的成员变量和方法；\n4. 在运行时调用任意一个对象的方法；\n5. 生成动态代理；\n\n### 3.反射机制相关API\n1. 通过一个对象获得完整的包名和类名\n```\npublic class TestReflect {\n    public static void main(String[] args) throws Exception {\n        TestReflect testReflect = new TestReflect();\n        System.out.println(testReflect.getClass().getName());\n        // 结果 com.gemini.test.TestReflect\n    }\n}\n```\n2. 实例化Class类对象\n```\npublic class TestReflect {\n    public static void main(String[] args) throws Exception {\n        Class<?> class1 = null;\n        Class<?> class2 = null;\n        Class<?> class3 = null;\n        // 一般采用这种形式\n        class1 = Class.forName(\"com.gemini.test.TestReflect\");\n        class2 = new TestReflect().getClass();\n        class3 = TestReflect.class;\n        System.out.println(\"类名称   \" + class1.getName());\n        System.out.println(\"类名称   \" + class2.getName());\n        System.out.println(\"类名称   \" + class3.getName());\n    }\n}\n```\n3. 获取一个对象的父类与实现的接口\n```\nimport java.io.Serializable;\npublic class TestReflect implements Serializable {\n    private static final long serialVersionUID = -2862585049955236662L;\n    public static void main(String[] args) throws Exception {\n        Class<?> clazz = Class.forName(\"net.xsoftlab.baike.TestReflect\");\n        // 取得父类\n        Class<?> parentClass = clazz.getSuperclass();\n        System.out.println(\"clazz的父类为：\" + parentClass.getName());\n        // clazz的父类为： java.lang.Object\n        // 获取所有的接口\n        Class<?> intes[] = clazz.getInterfaces();\n        System.out.println(\"clazz实现的接口有：\");\n        for (int i = 0; i < intes.length; i++) {\n            System.out.println((i + 1) + \"：\" + intes[i].getName());\n        }\n        // clazz实现的接口有：\n        // 1：java.io.Serializable\n    }\n}\n\n```\n4. 通过反射机制实例化一个类的对象\n```\nimport java.lang.reflect.Constructor;\npublic class TestReflect {\n    public static void main(String[] args) throws Exception {\n        Class<?> class1 = null;\n        class1 = Class.forName(\"com.gemini.test.User\");\n        // 第一种方法，实例化默认构造方法，调用set赋值\n        User user = (User) class1.newInstance();\n        user.setAge(20);\n        user.setName(\"Rollen\");\n        System.out.println(user); // 结果 User [age=20, name=Rollen]\n\n        // 第二种方法 取得全部的构造函数 使用构造函数赋值\n        Constructor<?> cons[] = class1.getConstructors();\n        // 查看每个构造方法需要的参数\n        for (int i = 0; i < cons.length; i++) {\n            Class<?> clazzs[] = cons[i].getParameterTypes();\n            System.out.print(\"cons[\" + i + \"] (\");\n            for (int j = 0; j < clazzs.length; j++) {\n                if (j == clazzs.length - 1)\n                    System.out.print(clazzs[j].getName());\n                else\n                    System.out.print(clazzs[j].getName() + \",\");\n            }\n            System.out.println(\")\");\n        }\n        // 结果\n        // cons[0] (java.lang.String)\n        // cons[1] (int,java.lang.String)\n        // cons[2] ()\n        user = (User) cons[0].newInstance(\"Rollen\");\n        System.out.println(user);\n        // 结果 User [age=0, name=Rollen]\n        user = (User) cons[1].newInstance(20, \"Rollen\");\n        System.out.println(user);\n        // 结果 User [age=20, name=Rollen]\n    }\n}\nclass User {\n    private int age;\n    private String name;\n    public User() {\n        super();\n    }\n    public User(String name) {\n        super();\n        this.name = name;\n    }\n    public User(int age, String name) {\n        super();\n        this.age = age;\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    @Override\n    public String toString() {\n        return \"User [age=\" + age + \", name=\" + name + \"]\";\n    }\n}\n```\n4. 获取某个类的全部属性\n```\nimport java.io.Serializable;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\npublic class TestReflect implements Serializable {\n    private static final long serialVersionUID = -2862585049955236662L;\n    public static void main(String[] args) throws Exception {\n        Class<?> clazz = Class.forName(\"com.gemini.test.TestReflect\");\n        System.out.println(\"===============本类属性===============\");\n        Field[] field = clazz.getDeclaredFields(); // 取得本类的全部属性\n        for (int i = 0; i < field.length; i++) {\n            int mo = field[i].getModifiers();// 权限修饰符\n            String priv = Modifier.toString(mo);\n            Class<?> type = field[i].getType();// 属性类型\n            System.out.println(priv + \" \" + type.getName() + \" \" + field[i].getName() + \";\");\n        }\n        System.out.println(\"==========实现的接口或者父类的属性==========\");\n        Field[] filed1 = clazz.getFields(); // 取得实现的接口或者父类的属性\n        for (int j = 0; j < filed1.length; j++) {\n            int mo = filed1[j].getModifiers();// 权限修饰符\n            String priv = Modifier.toString(mo);\n            Class<?> type = filed1[j].getType();// 属性类型\n            System.out.println(priv + \" \" + type.getName() + \" \" + filed1[j].getName() + \";\");\n        }\n    }\n}\n```\n5. 获取某个类的全部方法\n```\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\npublic class TestReflect implements Serializable {\n    private static final long serialVersionUID = -2862585049955236662L;\n    public static void main(String[] args) throws Exception {\n        Class<?> clazz = Class.forName(\"com.gemini.test.TestReflect\");\n        Method method[] = clazz.getMethods();\n        for (int i = 0; i < method.length; ++i) {\n            Class<?> returnType = method[i].getReturnType();\n            Class<?> para[] = method[i].getParameterTypes();\n            int temp = method[i].getModifiers();\n            System.out.print(Modifier.toString(temp) + \" \");\n            System.out.print(returnType.getName() + \"  \");\n            System.out.print(method[i].getName() + \" \");\n            System.out.print(\"(\");\n            for (int j = 0; j < para.length; ++j) {\n                System.out.print(para[j].getName() + \" \" + \"arg\" + j);\n                if (j < para.length - 1) {\n                    System.out.print(\",\");\n                }\n            }\n            Class<?> exce[] = method[i].getExceptionTypes();\n            if (exce.length > 0) {\n                System.out.print(\") throws \");\n                for (int k = 0; k < exce.length; ++k) {\n                    System.out.print(exce[k].getName() + \" \");\n                    if (k < exce.length - 1) {\n                        System.out.print(\",\");\n                    }\n                }\n            } else {\n                System.out.print(\")\");\n            }\n            System.out.println();\n        }\n    }\n}\n```\n6. 通过反射机制调用某个类的方法\n```\nimport java.lang.reflect.Method;\npublic class TestReflect {\n    public static void main(String[] args) throws Exception {\n        Class<?> clazz = Class.forName(\"net.xsoftlab.baike.TestReflect\");\n        // 调用TestReflect类中的reflect1方法\n        Method method = clazz.getMethod(\"reflect1\");\n        method.invoke(clazz.newInstance());\n        // Java 反射机制 - 调用某个类的方法1.\n        // 调用TestReflect的reflect2方法\n        method = clazz.getMethod(\"reflect2\", int.class, String.class);\n        method.invoke(clazz.newInstance(), 20, \"张三\");\n        // Java 反射机制 - 调用某个类的方法2.\n        // age -> 20. name -> 张三\n    }\n    public void reflect1() {\n        System.out.println(\"Java 反射机制 - 调用某个类的方法1.\");\n    }\n    public void reflect2(int age, String name) {\n        System.out.println(\"Java 反射机制 - 调用某个类的方法2.\");\n        System.out.println(\"age -> \" + age + \". name -> \" + name);\n    }\n}\n```\n7. 通过反射机制操作某个类的属性\n```\nimport java.lang.reflect.Field;\npublic class TestReflect {\n    private String proprety = null;\n    public static void main(String[] args) throws Exception {\n        Class<?> clazz = Class.forName(\"net.xsoftlab.baike.TestReflect\");\n        Object obj = clazz.newInstance();\n        // 可以直接对 private 的属性赋值\n        Field field = clazz.getDeclaredField(\"proprety\");\n        field.setAccessible(true);\n        field.set(obj, \"Java反射机制\");\n        System.out.println(field.get(obj));\n    }\n}\n```\n8. 反射机制的动态代理\n```\n// 获取类加载器的方法\nTestReflect testReflect = new TestReflect();\n        System.out.println(\"类加载器  \" + testReflect.getClass().getClassLoader().getClass().getName());\npackage com.gemini.test;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n//定义项目接口\ninterface Subject {\n    public String say(String name, int age);\n}\n// 定义真实项目\nclass RealSubject implements Subject {\n    public String say(String name, int age) {\n        return name + \"  \" + age;\n    }\n}\nclass MyInvocationHandler implements InvocationHandler {\n    private Object obj = null;\n    public Object bind(Object obj) {\n        this.obj = obj;\n        return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), this);\n    }\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        Object temp = method.invoke(this.obj, args);\n        return temp;\n    }\n}\n/**\n * 在java中有三种类类加载器。\n *\n * 1）Bootstrap ClassLoader 此加载器采用c++编写，一般开发中很少见。\n *\n * 2）Extension ClassLoader 用来进行扩展类的加载，一般对应的是jrelibext目录中的类\n *\n * 3）AppClassLoader 加载classpath指定的类，是最常用的加载器。同时也是java中默认的加载器。\n *\n * 如果想要完成动态代理，首先需要定义一个InvocationHandler接口的子类，已完成代理的具体操作。\n *\n * @author xsoftlab.net\n *\n */\npublic class TestReflect {\n    public static void main(String[] args) throws Exception {\n        MyInvocationHandler demo = new MyInvocationHandler();\n        Subject sub = (Subject) demo.bind(new RealSubject());\n        String info = sub.say(\"Rollen\", 20);\n        System.out.println(info);\n    }\n}\n```\n9. 将反射机制应用于工厂模式\n```\ninterface fruit {\n    public abstract void eat();\n}\nclass  Apple implements fruit {\n    public void eat() {\n        System.out.println(\"Apple\");\n    }\n}\nclass Orange implements fruit {\n    public void eat() {\n        System.out.println(\"Orange\");\n    }\n}\nclass Factory {\n    public static fruit getInstance(String ClassName) {\n        fruit f = null;\n        try {\n            f = (fruit) Class.forName(ClassName).newInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return f;\n    }\n}\n/**\n * 对于普通的工厂模式当我们在添加一个子类的时候，就需要对应的修改工厂类。 当我们添加很多的子类的时候，会很麻烦。\n * Java 工厂模式可以参考\n * http://baike.xsoftlab.net/view/java-factory-pattern\n *\n * 现在我们利用反射机制实现工厂模式，可以在不修改工厂类的情况下添加任意多个子类。\n * 但是有一点仍然很麻烦，就是需要知道完整的包名和类名，这里可以使用properties配置文件来完成。\n */\npublic class TestReflect {\n    public static void main(String[] args) throws Exception {\n        fruit f = Factory.getInstance(\"com.gemini.test.Apple\");\n        if (f != null) {\n            f.eat();\n        }\n    }\n}\n```\n### 4.反射机制优化\n1. 描述\n从事java开发的都知道反射的运行速度慢，所以很多java的开发者都对反射机制的使用望而却步(包括BME组件SDO)。我想知道，究竟反射机制慢在哪里？有没有改进方法，让我们可以继续使用它？如果一个好东西因为其自身的一些缺陷而不使用它，那么实在可惜，反射也是这样。我想说的是：我们应该一点点的改进它。\n2. 错误的使用方法\n错误的使用方法是每次需要获取Class的对象时都使用Class.forName方法，或者需要调用Class对象上的方法时都调用getDeclaredMethod(String name, Class<?>... parameterTypes)或getMethod(String name, Class<?>... parameterTypes)方法获取Method对象，再调用其上的invoke(Object obj, Object... args)方法。\n这里存在两个容易造成性能损耗的地方：\nClass.forName方法的调用会执行Class类文件在整个类路径下的搜索，频繁调用比较影响性能。\nClass对象上的getDeclaredMethod (String, Class<?>...)或getMethod(String, Class<?>...)方法的调用会执行Method对象在Class对象上的搜索。有些同事还使用getMethods()方法获取Method数组，然后执行搜索任务，实际上getMethods()还会执行方法对象的集体Copy比直接使用(String, Class<?>...)或getMethod(String, Class<?>...)方法还要消耗时间及空间。\n3. Cache思想\nCache的思想是将需要的反射中间件给存储下来，以便以后使用。不管使用什么方法获取Class对象上的Method对象，返回的都是Method对象的copy对象。这些copy对象有的只是使用一次就被回收了，未免有些可惜。我们可这以将这些对象给缓存下来，以便以后使用。而在存储数据结构中，无疑HashMap的查找速度是最快的，它主要是通过对象的Hash码进行一次查找，速度超快。但是HashMap上的操作不是线程安全的，需要改进方法实现同步。\n4. 具体实现\n需要两个组件ClassInfo和ReflectionCache。\nClassInfo主要保存Class对象的信息，主要是方法Map。其中ClassInfo中包括三部分方法的Map: Getter, Setter, Other。Getter是Class的属性的获取方法，Setter是Class的属性的设置方法，Other是其它方法。需要注意的是Getter和Setter的方法需要完全符合Javabean规范(isXXX方法属于Getter方法范围内)，其key值是方法对应的属性名。Other方法是除Getter和Setter以外的其它方法。\nReflectionCache组件主要是通过HashMap对ClassInfo进行缓存。缓存的键值是ClassInfo中Class对象的全称。如一个String对象，它缓存的键值就是java.lang.String。并且ReflectionCache提供了几种不同get和put方法来方便用户的操作。\n另外ClassInfo的生成需要用到ClassInfoUtils工具。它的主要工作是创建ClassInfo对象，其中创建ClassInfo时可以提供Method Type信息来指定缓存的方法类型（如：所有方法-All、存取器方法-Access、获取方法-Getter和设置方法-Setter）。\n5. 同步控制\nReflectionCache中ClassInfoMap是一个静变量，那么随之而来的就是HashMap的同步问题。我对ReflectionCache的做了些改进，主要是对put方法的处理。首先HashMap的获取操作（get操作）没有加入同步操作，因此获取的操作是可以并发的。现在的问题在于如果获取不了ClassInfo对象时会要执行设置操作（set操作），此时并发问题随之而来。可能在同一时刻会有很多线程去设置ClassInfo，在第一个设置完ClassInfo的线程结束后，第二个线程应该停止设置ClassInfo。在此需求之上，我们需要对ReflectionCache的put操作上加上同步块，并且让put操作再执行一个额外的操作：返回添加到ClassInfoMap中的ClassInfo，不管它是不是其它线程添加的。因此我们在设置ClassInfo时，可以这样操作：\nClassInfo classInfo = ReflectionCache.putClassInfo(String.class);\n6. 改进效率\n改进之后的效率的提高是明显的。主要是节省了中间变量创建及反射数据的查找时间。测试数据:\n100000次，20个线程，无Class.forName操作\n一般用法: 11375 milliseconds\nReflectionCache: 2562 milliseconds\n100000次，20个线程，有Class.forName操作\n一般用法: 16125 milliseconds\nReflectionCache: 4187 milliseconds\n可见使用ReflectionCache明显提高了效率。\n\n伪代码如下：\n```\n1.默认方式\nClass clazz = Class.forName(\"com.dianping.csc.page_config.view.entity.ViewConfig\");\nclazz.newInstance();\n2.Cache加载Class\nCachedClass classInfo = ReflectionCache.getCachedClass(ViewConfig.class);\nClass clazz = classInfo.getTheClass();\n3.Cache加载Method\nMethodAccess methodAccess = MethodAccess.get(classInfo.getTheClass());\nmethodAccess.invoke();\nclazz.newInstance();\n```\n引用用包如下：\n```\n<dependency>\n <groupId>org.codehaus.groovy</groupId>\n <artifactId>groovy-all</artifactId>\n <version>2.4.7</version>\n</dependency>\n\n<dependency>\n <groupId>com.esotericsoftware</groupId>\n <artifactId>reflectasm</artifactId>\n <version>1.11.3</version>\n</dependency>\n```\n程序示例：\n```\n/**\n *根据Body字符串，自动封装\n * @param issueBody\n * @param obj\n * @return\n * @throws CscConfigException\n */\npublic static Object setJavaBeanByRequestBody(String issueBody, Object obj) throws CscConfigException {\n    try {\n        JsonParser jsonParser = new JsonParser();\n JsonObject jsonObject = jsonParser.parse(issueBody).getAsJsonObject();\n Map<String, String> map = ObjectUtil.getObjectPro(obj.getClass());\n Set<Map.Entry<String, String>> mapping = map.entrySet();\n MethodAccess methodAccess = MethodAccess.get(obj.getClass());\n for (Map.Entry<String, String> me : mapping) {\n            String name = me.getKey();\n String type = me.getValue();\n try{\n                int index_ = methodAccess.getIndex(\"set\" + StringUtil.toFirstUp(name));\n if (type.contains(\"String\")) {\n                    if (jsonObject.get(name) != null) {\n                        String setValue = \"\";\n try{\n                            setValue = jsonObject.get(name).getAsString();\n }catch(Exception e){\n                            setValue = jsonObject.get(name).toString();\n }\n                        if (setValue == null) {\n                            setValue = \"\";\n }\n                        setValue = setValue.replace(\"&quot;\", \"\").replace(\"&nbsp;\", \"\");\n methodAccess.invoke(obj,index_,setValue);\n }\n                } else if (type.contains(\"Long\")) {\n                    if (jsonObject.get(name) != null) {\n                        methodAccess.invoke(obj,index_,jsonObject.get(name).getAsLong());\n }\n                } else if (type.contains(\"Date\")) {\n                    if (jsonObject.get(name) != null) {\n                        DateFormat dateformat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n Date date = dateformat.parse(jsonObject.get(name).toString());\n\n }\n                } else if (type.contains(\"Integer\")) {\n                    if (jsonObject.get(name) != null) {\n                        methodAccess.invoke(obj,index_,jsonObject.get(name).getAsInt());\n }\n                } else {\n                }\n            }catch (Exception e){\n                continue;\n }\n\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n throw new CscConfigException(100001,\"信息获取异常\");\n }\n    return obj;\n}\n```\n\n","source":"_posts/14JAVA反射详解和优化.md","raw":"---\ntitle: JAVA反射详解和优化\ndate: 2017-07-19 19:32:28\ntags: Java\ncategories: \"Java\"\ntoc: true\n---\n### 1.何为反射机制\n反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。\n<!--more-->\n\n### 2.反射的应用场景\n1. 在运行时判断任意一个对象所属的类；\n2. 在运行时构造任意一个类的对象；\n3. 在运行时判断任意一个类所具有的成员变量和方法；\n4. 在运行时调用任意一个对象的方法；\n5. 生成动态代理；\n\n### 3.反射机制相关API\n1. 通过一个对象获得完整的包名和类名\n```\npublic class TestReflect {\n    public static void main(String[] args) throws Exception {\n        TestReflect testReflect = new TestReflect();\n        System.out.println(testReflect.getClass().getName());\n        // 结果 com.gemini.test.TestReflect\n    }\n}\n```\n2. 实例化Class类对象\n```\npublic class TestReflect {\n    public static void main(String[] args) throws Exception {\n        Class<?> class1 = null;\n        Class<?> class2 = null;\n        Class<?> class3 = null;\n        // 一般采用这种形式\n        class1 = Class.forName(\"com.gemini.test.TestReflect\");\n        class2 = new TestReflect().getClass();\n        class3 = TestReflect.class;\n        System.out.println(\"类名称   \" + class1.getName());\n        System.out.println(\"类名称   \" + class2.getName());\n        System.out.println(\"类名称   \" + class3.getName());\n    }\n}\n```\n3. 获取一个对象的父类与实现的接口\n```\nimport java.io.Serializable;\npublic class TestReflect implements Serializable {\n    private static final long serialVersionUID = -2862585049955236662L;\n    public static void main(String[] args) throws Exception {\n        Class<?> clazz = Class.forName(\"net.xsoftlab.baike.TestReflect\");\n        // 取得父类\n        Class<?> parentClass = clazz.getSuperclass();\n        System.out.println(\"clazz的父类为：\" + parentClass.getName());\n        // clazz的父类为： java.lang.Object\n        // 获取所有的接口\n        Class<?> intes[] = clazz.getInterfaces();\n        System.out.println(\"clazz实现的接口有：\");\n        for (int i = 0; i < intes.length; i++) {\n            System.out.println((i + 1) + \"：\" + intes[i].getName());\n        }\n        // clazz实现的接口有：\n        // 1：java.io.Serializable\n    }\n}\n\n```\n4. 通过反射机制实例化一个类的对象\n```\nimport java.lang.reflect.Constructor;\npublic class TestReflect {\n    public static void main(String[] args) throws Exception {\n        Class<?> class1 = null;\n        class1 = Class.forName(\"com.gemini.test.User\");\n        // 第一种方法，实例化默认构造方法，调用set赋值\n        User user = (User) class1.newInstance();\n        user.setAge(20);\n        user.setName(\"Rollen\");\n        System.out.println(user); // 结果 User [age=20, name=Rollen]\n\n        // 第二种方法 取得全部的构造函数 使用构造函数赋值\n        Constructor<?> cons[] = class1.getConstructors();\n        // 查看每个构造方法需要的参数\n        for (int i = 0; i < cons.length; i++) {\n            Class<?> clazzs[] = cons[i].getParameterTypes();\n            System.out.print(\"cons[\" + i + \"] (\");\n            for (int j = 0; j < clazzs.length; j++) {\n                if (j == clazzs.length - 1)\n                    System.out.print(clazzs[j].getName());\n                else\n                    System.out.print(clazzs[j].getName() + \",\");\n            }\n            System.out.println(\")\");\n        }\n        // 结果\n        // cons[0] (java.lang.String)\n        // cons[1] (int,java.lang.String)\n        // cons[2] ()\n        user = (User) cons[0].newInstance(\"Rollen\");\n        System.out.println(user);\n        // 结果 User [age=0, name=Rollen]\n        user = (User) cons[1].newInstance(20, \"Rollen\");\n        System.out.println(user);\n        // 结果 User [age=20, name=Rollen]\n    }\n}\nclass User {\n    private int age;\n    private String name;\n    public User() {\n        super();\n    }\n    public User(String name) {\n        super();\n        this.name = name;\n    }\n    public User(int age, String name) {\n        super();\n        this.age = age;\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    @Override\n    public String toString() {\n        return \"User [age=\" + age + \", name=\" + name + \"]\";\n    }\n}\n```\n4. 获取某个类的全部属性\n```\nimport java.io.Serializable;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\npublic class TestReflect implements Serializable {\n    private static final long serialVersionUID = -2862585049955236662L;\n    public static void main(String[] args) throws Exception {\n        Class<?> clazz = Class.forName(\"com.gemini.test.TestReflect\");\n        System.out.println(\"===============本类属性===============\");\n        Field[] field = clazz.getDeclaredFields(); // 取得本类的全部属性\n        for (int i = 0; i < field.length; i++) {\n            int mo = field[i].getModifiers();// 权限修饰符\n            String priv = Modifier.toString(mo);\n            Class<?> type = field[i].getType();// 属性类型\n            System.out.println(priv + \" \" + type.getName() + \" \" + field[i].getName() + \";\");\n        }\n        System.out.println(\"==========实现的接口或者父类的属性==========\");\n        Field[] filed1 = clazz.getFields(); // 取得实现的接口或者父类的属性\n        for (int j = 0; j < filed1.length; j++) {\n            int mo = filed1[j].getModifiers();// 权限修饰符\n            String priv = Modifier.toString(mo);\n            Class<?> type = filed1[j].getType();// 属性类型\n            System.out.println(priv + \" \" + type.getName() + \" \" + filed1[j].getName() + \";\");\n        }\n    }\n}\n```\n5. 获取某个类的全部方法\n```\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\npublic class TestReflect implements Serializable {\n    private static final long serialVersionUID = -2862585049955236662L;\n    public static void main(String[] args) throws Exception {\n        Class<?> clazz = Class.forName(\"com.gemini.test.TestReflect\");\n        Method method[] = clazz.getMethods();\n        for (int i = 0; i < method.length; ++i) {\n            Class<?> returnType = method[i].getReturnType();\n            Class<?> para[] = method[i].getParameterTypes();\n            int temp = method[i].getModifiers();\n            System.out.print(Modifier.toString(temp) + \" \");\n            System.out.print(returnType.getName() + \"  \");\n            System.out.print(method[i].getName() + \" \");\n            System.out.print(\"(\");\n            for (int j = 0; j < para.length; ++j) {\n                System.out.print(para[j].getName() + \" \" + \"arg\" + j);\n                if (j < para.length - 1) {\n                    System.out.print(\",\");\n                }\n            }\n            Class<?> exce[] = method[i].getExceptionTypes();\n            if (exce.length > 0) {\n                System.out.print(\") throws \");\n                for (int k = 0; k < exce.length; ++k) {\n                    System.out.print(exce[k].getName() + \" \");\n                    if (k < exce.length - 1) {\n                        System.out.print(\",\");\n                    }\n                }\n            } else {\n                System.out.print(\")\");\n            }\n            System.out.println();\n        }\n    }\n}\n```\n6. 通过反射机制调用某个类的方法\n```\nimport java.lang.reflect.Method;\npublic class TestReflect {\n    public static void main(String[] args) throws Exception {\n        Class<?> clazz = Class.forName(\"net.xsoftlab.baike.TestReflect\");\n        // 调用TestReflect类中的reflect1方法\n        Method method = clazz.getMethod(\"reflect1\");\n        method.invoke(clazz.newInstance());\n        // Java 反射机制 - 调用某个类的方法1.\n        // 调用TestReflect的reflect2方法\n        method = clazz.getMethod(\"reflect2\", int.class, String.class);\n        method.invoke(clazz.newInstance(), 20, \"张三\");\n        // Java 反射机制 - 调用某个类的方法2.\n        // age -> 20. name -> 张三\n    }\n    public void reflect1() {\n        System.out.println(\"Java 反射机制 - 调用某个类的方法1.\");\n    }\n    public void reflect2(int age, String name) {\n        System.out.println(\"Java 反射机制 - 调用某个类的方法2.\");\n        System.out.println(\"age -> \" + age + \". name -> \" + name);\n    }\n}\n```\n7. 通过反射机制操作某个类的属性\n```\nimport java.lang.reflect.Field;\npublic class TestReflect {\n    private String proprety = null;\n    public static void main(String[] args) throws Exception {\n        Class<?> clazz = Class.forName(\"net.xsoftlab.baike.TestReflect\");\n        Object obj = clazz.newInstance();\n        // 可以直接对 private 的属性赋值\n        Field field = clazz.getDeclaredField(\"proprety\");\n        field.setAccessible(true);\n        field.set(obj, \"Java反射机制\");\n        System.out.println(field.get(obj));\n    }\n}\n```\n8. 反射机制的动态代理\n```\n// 获取类加载器的方法\nTestReflect testReflect = new TestReflect();\n        System.out.println(\"类加载器  \" + testReflect.getClass().getClassLoader().getClass().getName());\npackage com.gemini.test;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n//定义项目接口\ninterface Subject {\n    public String say(String name, int age);\n}\n// 定义真实项目\nclass RealSubject implements Subject {\n    public String say(String name, int age) {\n        return name + \"  \" + age;\n    }\n}\nclass MyInvocationHandler implements InvocationHandler {\n    private Object obj = null;\n    public Object bind(Object obj) {\n        this.obj = obj;\n        return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), this);\n    }\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        Object temp = method.invoke(this.obj, args);\n        return temp;\n    }\n}\n/**\n * 在java中有三种类类加载器。\n *\n * 1）Bootstrap ClassLoader 此加载器采用c++编写，一般开发中很少见。\n *\n * 2）Extension ClassLoader 用来进行扩展类的加载，一般对应的是jrelibext目录中的类\n *\n * 3）AppClassLoader 加载classpath指定的类，是最常用的加载器。同时也是java中默认的加载器。\n *\n * 如果想要完成动态代理，首先需要定义一个InvocationHandler接口的子类，已完成代理的具体操作。\n *\n * @author xsoftlab.net\n *\n */\npublic class TestReflect {\n    public static void main(String[] args) throws Exception {\n        MyInvocationHandler demo = new MyInvocationHandler();\n        Subject sub = (Subject) demo.bind(new RealSubject());\n        String info = sub.say(\"Rollen\", 20);\n        System.out.println(info);\n    }\n}\n```\n9. 将反射机制应用于工厂模式\n```\ninterface fruit {\n    public abstract void eat();\n}\nclass  Apple implements fruit {\n    public void eat() {\n        System.out.println(\"Apple\");\n    }\n}\nclass Orange implements fruit {\n    public void eat() {\n        System.out.println(\"Orange\");\n    }\n}\nclass Factory {\n    public static fruit getInstance(String ClassName) {\n        fruit f = null;\n        try {\n            f = (fruit) Class.forName(ClassName).newInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return f;\n    }\n}\n/**\n * 对于普通的工厂模式当我们在添加一个子类的时候，就需要对应的修改工厂类。 当我们添加很多的子类的时候，会很麻烦。\n * Java 工厂模式可以参考\n * http://baike.xsoftlab.net/view/java-factory-pattern\n *\n * 现在我们利用反射机制实现工厂模式，可以在不修改工厂类的情况下添加任意多个子类。\n * 但是有一点仍然很麻烦，就是需要知道完整的包名和类名，这里可以使用properties配置文件来完成。\n */\npublic class TestReflect {\n    public static void main(String[] args) throws Exception {\n        fruit f = Factory.getInstance(\"com.gemini.test.Apple\");\n        if (f != null) {\n            f.eat();\n        }\n    }\n}\n```\n### 4.反射机制优化\n1. 描述\n从事java开发的都知道反射的运行速度慢，所以很多java的开发者都对反射机制的使用望而却步(包括BME组件SDO)。我想知道，究竟反射机制慢在哪里？有没有改进方法，让我们可以继续使用它？如果一个好东西因为其自身的一些缺陷而不使用它，那么实在可惜，反射也是这样。我想说的是：我们应该一点点的改进它。\n2. 错误的使用方法\n错误的使用方法是每次需要获取Class的对象时都使用Class.forName方法，或者需要调用Class对象上的方法时都调用getDeclaredMethod(String name, Class<?>... parameterTypes)或getMethod(String name, Class<?>... parameterTypes)方法获取Method对象，再调用其上的invoke(Object obj, Object... args)方法。\n这里存在两个容易造成性能损耗的地方：\nClass.forName方法的调用会执行Class类文件在整个类路径下的搜索，频繁调用比较影响性能。\nClass对象上的getDeclaredMethod (String, Class<?>...)或getMethod(String, Class<?>...)方法的调用会执行Method对象在Class对象上的搜索。有些同事还使用getMethods()方法获取Method数组，然后执行搜索任务，实际上getMethods()还会执行方法对象的集体Copy比直接使用(String, Class<?>...)或getMethod(String, Class<?>...)方法还要消耗时间及空间。\n3. Cache思想\nCache的思想是将需要的反射中间件给存储下来，以便以后使用。不管使用什么方法获取Class对象上的Method对象，返回的都是Method对象的copy对象。这些copy对象有的只是使用一次就被回收了，未免有些可惜。我们可这以将这些对象给缓存下来，以便以后使用。而在存储数据结构中，无疑HashMap的查找速度是最快的，它主要是通过对象的Hash码进行一次查找，速度超快。但是HashMap上的操作不是线程安全的，需要改进方法实现同步。\n4. 具体实现\n需要两个组件ClassInfo和ReflectionCache。\nClassInfo主要保存Class对象的信息，主要是方法Map。其中ClassInfo中包括三部分方法的Map: Getter, Setter, Other。Getter是Class的属性的获取方法，Setter是Class的属性的设置方法，Other是其它方法。需要注意的是Getter和Setter的方法需要完全符合Javabean规范(isXXX方法属于Getter方法范围内)，其key值是方法对应的属性名。Other方法是除Getter和Setter以外的其它方法。\nReflectionCache组件主要是通过HashMap对ClassInfo进行缓存。缓存的键值是ClassInfo中Class对象的全称。如一个String对象，它缓存的键值就是java.lang.String。并且ReflectionCache提供了几种不同get和put方法来方便用户的操作。\n另外ClassInfo的生成需要用到ClassInfoUtils工具。它的主要工作是创建ClassInfo对象，其中创建ClassInfo时可以提供Method Type信息来指定缓存的方法类型（如：所有方法-All、存取器方法-Access、获取方法-Getter和设置方法-Setter）。\n5. 同步控制\nReflectionCache中ClassInfoMap是一个静变量，那么随之而来的就是HashMap的同步问题。我对ReflectionCache的做了些改进，主要是对put方法的处理。首先HashMap的获取操作（get操作）没有加入同步操作，因此获取的操作是可以并发的。现在的问题在于如果获取不了ClassInfo对象时会要执行设置操作（set操作），此时并发问题随之而来。可能在同一时刻会有很多线程去设置ClassInfo，在第一个设置完ClassInfo的线程结束后，第二个线程应该停止设置ClassInfo。在此需求之上，我们需要对ReflectionCache的put操作上加上同步块，并且让put操作再执行一个额外的操作：返回添加到ClassInfoMap中的ClassInfo，不管它是不是其它线程添加的。因此我们在设置ClassInfo时，可以这样操作：\nClassInfo classInfo = ReflectionCache.putClassInfo(String.class);\n6. 改进效率\n改进之后的效率的提高是明显的。主要是节省了中间变量创建及反射数据的查找时间。测试数据:\n100000次，20个线程，无Class.forName操作\n一般用法: 11375 milliseconds\nReflectionCache: 2562 milliseconds\n100000次，20个线程，有Class.forName操作\n一般用法: 16125 milliseconds\nReflectionCache: 4187 milliseconds\n可见使用ReflectionCache明显提高了效率。\n\n伪代码如下：\n```\n1.默认方式\nClass clazz = Class.forName(\"com.dianping.csc.page_config.view.entity.ViewConfig\");\nclazz.newInstance();\n2.Cache加载Class\nCachedClass classInfo = ReflectionCache.getCachedClass(ViewConfig.class);\nClass clazz = classInfo.getTheClass();\n3.Cache加载Method\nMethodAccess methodAccess = MethodAccess.get(classInfo.getTheClass());\nmethodAccess.invoke();\nclazz.newInstance();\n```\n引用用包如下：\n```\n<dependency>\n <groupId>org.codehaus.groovy</groupId>\n <artifactId>groovy-all</artifactId>\n <version>2.4.7</version>\n</dependency>\n\n<dependency>\n <groupId>com.esotericsoftware</groupId>\n <artifactId>reflectasm</artifactId>\n <version>1.11.3</version>\n</dependency>\n```\n程序示例：\n```\n/**\n *根据Body字符串，自动封装\n * @param issueBody\n * @param obj\n * @return\n * @throws CscConfigException\n */\npublic static Object setJavaBeanByRequestBody(String issueBody, Object obj) throws CscConfigException {\n    try {\n        JsonParser jsonParser = new JsonParser();\n JsonObject jsonObject = jsonParser.parse(issueBody).getAsJsonObject();\n Map<String, String> map = ObjectUtil.getObjectPro(obj.getClass());\n Set<Map.Entry<String, String>> mapping = map.entrySet();\n MethodAccess methodAccess = MethodAccess.get(obj.getClass());\n for (Map.Entry<String, String> me : mapping) {\n            String name = me.getKey();\n String type = me.getValue();\n try{\n                int index_ = methodAccess.getIndex(\"set\" + StringUtil.toFirstUp(name));\n if (type.contains(\"String\")) {\n                    if (jsonObject.get(name) != null) {\n                        String setValue = \"\";\n try{\n                            setValue = jsonObject.get(name).getAsString();\n }catch(Exception e){\n                            setValue = jsonObject.get(name).toString();\n }\n                        if (setValue == null) {\n                            setValue = \"\";\n }\n                        setValue = setValue.replace(\"&quot;\", \"\").replace(\"&nbsp;\", \"\");\n methodAccess.invoke(obj,index_,setValue);\n }\n                } else if (type.contains(\"Long\")) {\n                    if (jsonObject.get(name) != null) {\n                        methodAccess.invoke(obj,index_,jsonObject.get(name).getAsLong());\n }\n                } else if (type.contains(\"Date\")) {\n                    if (jsonObject.get(name) != null) {\n                        DateFormat dateformat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n Date date = dateformat.parse(jsonObject.get(name).toString());\n\n }\n                } else if (type.contains(\"Integer\")) {\n                    if (jsonObject.get(name) != null) {\n                        methodAccess.invoke(obj,index_,jsonObject.get(name).getAsInt());\n }\n                } else {\n                }\n            }catch (Exception e){\n                continue;\n }\n\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n throw new CscConfigException(100001,\"信息获取异常\");\n }\n    return obj;\n}\n```\n\n","slug":"14JAVA反射详解和优化","published":1,"updated":"2017-07-20T08:30:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tc9c0003a7xwkyak16sq","content":"<h3 id=\"1-何为反射机制\"><a href=\"#1-何为反射机制\" class=\"headerlink\" title=\"1.何为反射机制\"></a>1.何为反射机制</h3><p>反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。<br><a id=\"more\"></a></p>\n<h3 id=\"2-反射的应用场景\"><a href=\"#2-反射的应用场景\" class=\"headerlink\" title=\"2.反射的应用场景\"></a>2.反射的应用场景</h3><ol>\n<li>在运行时判断任意一个对象所属的类；</li>\n<li>在运行时构造任意一个类的对象；</li>\n<li>在运行时判断任意一个类所具有的成员变量和方法；</li>\n<li>在运行时调用任意一个对象的方法；</li>\n<li>生成动态代理；</li>\n</ol>\n<h3 id=\"3-反射机制相关API\"><a href=\"#3-反射机制相关API\" class=\"headerlink\" title=\"3.反射机制相关API\"></a>3.反射机制相关API</h3><ol>\n<li><p>通过一个对象获得完整的包名和类名</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">TestReflect</span> &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String[] args</span>) throws Exception </span>&#123;</div><div class=\"line\">        TestReflect testReflect = <span class=\"keyword\">new</span> TestReflect();</div><div class=\"line\">        System.<span class=\"keyword\">out</span>.println(testReflect.getClass().getName());</div><div class=\"line\">        <span class=\"comment\">// 结果 com.gemini.test.TestReflect</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>实例化Class类对象</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> TestReflect &#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(String[] args) <span class=\"keyword\">throws</span> Exception &#123;</div><div class=\"line\">        <span class=\"keyword\">Class</span>&lt;?&gt; class1 = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">Class</span>&lt;?&gt; class2 = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">Class</span>&lt;?&gt; class3 = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"comment\">// 一般采用这种形式</span></div><div class=\"line\">        class1 = <span class=\"keyword\">Class</span>.forName(<span class=\"string\">\"com.gemini.test.TestReflect\"</span>);</div><div class=\"line\">        class2 = <span class=\"keyword\">new</span> TestReflect().getClass();</div><div class=\"line\">        class3 = TestReflect.<span class=\"keyword\">class</span>;</div><div class=\"line\">        System.out.<span class=\"keyword\">println</span>(<span class=\"string\">\"类名称   \"</span> + class1.getName());</div><div class=\"line\">        System.out.<span class=\"keyword\">println</span>(<span class=\"string\">\"类名称   \"</span> + class2.getName());</div><div class=\"line\">        System.out.<span class=\"keyword\">println</span>(<span class=\"string\">\"类名称   \"</span> + class3.getName());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>获取一个对象的父类与实现的接口</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.io.Serializable;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> TestReflect <span class=\"keyword\">implements</span> Serializable &#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">2862585049955236662</span>L;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(String[] args) <span class=\"keyword\">throws</span> Exception &#123;</div><div class=\"line\">        <span class=\"keyword\">Class</span>&lt;?&gt; clazz = <span class=\"keyword\">Class</span>.forName(<span class=\"string\">\"net.xsoftlab.baike.TestReflect\"</span>);</div><div class=\"line\">        <span class=\"comment\">// 取得父类</span></div><div class=\"line\">        <span class=\"keyword\">Class</span>&lt;?&gt; parentClass = clazz.getSuperclass();</div><div class=\"line\">        System.out.<span class=\"keyword\">println</span>(<span class=\"string\">\"clazz的父类为：\"</span> + parentClass.getName());</div><div class=\"line\">        <span class=\"comment\">// clazz的父类为： java.lang.Object</span></div><div class=\"line\">        <span class=\"comment\">// 获取所有的接口</span></div><div class=\"line\">        <span class=\"keyword\">Class</span>&lt;?&gt; intes[] = clazz.getInterfaces();</div><div class=\"line\">        System.out.<span class=\"keyword\">println</span>(<span class=\"string\">\"clazz实现的接口有：\"</span>);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; intes.length; i++) &#123;</div><div class=\"line\">            System.out.<span class=\"keyword\">println</span>((i + <span class=\"number\">1</span>) + <span class=\"string\">\"：\"</span> + intes[i].getName());</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// clazz实现的接口有：</span></div><div class=\"line\">        <span class=\"comment\">// 1：java.io.Serializable</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>通过反射机制实例化一个类的对象</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\">import java.lang.reflect.Constructor;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">TestReflect</span> &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String[] args</span>) throws Exception </span>&#123;</div><div class=\"line\">        Class&lt;?&gt; class1 = <span class=\"literal\">null</span>;</div><div class=\"line\">        class1 = Class.forName(<span class=\"string\">\"com.gemini.test.User\"</span>);</div><div class=\"line\">        <span class=\"comment\">// 第一种方法，实例化默认构造方法，调用set赋值</span></div><div class=\"line\">        User user = (User) class1.newInstance();</div><div class=\"line\">        user.setAge(<span class=\"number\">20</span>);</div><div class=\"line\">        user.setName(<span class=\"string\">\"Rollen\"</span>);</div><div class=\"line\">        System.<span class=\"keyword\">out</span>.println(user); <span class=\"comment\">// 结果 User [age=20, name=Rollen]</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 第二种方法 取得全部的构造函数 使用构造函数赋值</span></div><div class=\"line\">        Constructor&lt;?&gt; cons[] = class1.getConstructors();</div><div class=\"line\">        <span class=\"comment\">// 查看每个构造方法需要的参数</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; cons.length; i++) &#123;</div><div class=\"line\">            Class&lt;?&gt; clazzs[] = cons[i].getParameterTypes();</div><div class=\"line\">            System.<span class=\"keyword\">out</span>.print(<span class=\"string\">\"cons[\"</span> + i + <span class=\"string\">\"] (\"</span>);</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; clazzs.length; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (j == clazzs.length - <span class=\"number\">1</span>)</div><div class=\"line\">                    System.<span class=\"keyword\">out</span>.print(clazzs[j].getName());</div><div class=\"line\">                <span class=\"keyword\">else</span></div><div class=\"line\">                    System.<span class=\"keyword\">out</span>.print(clazzs[j].getName() + <span class=\"string\">\",\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">            System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\")\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// 结果</span></div><div class=\"line\">        <span class=\"comment\">// cons[0] (java.lang.String)</span></div><div class=\"line\">        <span class=\"comment\">// cons[1] (int,java.lang.String)</span></div><div class=\"line\">        <span class=\"comment\">// cons[2] ()</span></div><div class=\"line\">        user = (User) cons[<span class=\"number\">0</span>].newInstance(<span class=\"string\">\"Rollen\"</span>);</div><div class=\"line\">        System.<span class=\"keyword\">out</span>.println(user);</div><div class=\"line\">        <span class=\"comment\">// 结果 User [age=0, name=Rollen]</span></div><div class=\"line\">        user = (User) cons[<span class=\"number\">1</span>].newInstance(<span class=\"number\">20</span>, <span class=\"string\">\"Rollen\"</span>);</div><div class=\"line\">        System.<span class=\"keyword\">out</span>.println(user);</div><div class=\"line\">        <span class=\"comment\">// 结果 User [age=20, name=Rollen]</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</div><div class=\"line\">    <span class=\"keyword\">private</span> String name;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        super();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span>(<span class=\"params\">String name</span>) </span>&#123;</div><div class=\"line\">        super();</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span>(<span class=\"params\"><span class=\"keyword\">int</span> age, String name</span>) </span>&#123;</div><div class=\"line\">        super();</div><div class=\"line\">        <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> age;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span>(<span class=\"params\"><span class=\"keyword\">int</span> age</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span>(<span class=\"params\">String name</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\">    @<span class=\"function\">Override</span></div><div class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title\">toString</span>(<span class=\"params\"></span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"User [age=\"</span> + age + <span class=\"string\">\", name=\"</span> + name + <span class=\"string\">\"]\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>获取某个类的全部属性</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.io.Serializable;</div><div class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Field;</div><div class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Modifier;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> TestReflect <span class=\"keyword\">implements</span> Serializable &#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">2862585049955236662</span>L;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(String[] args) <span class=\"keyword\">throws</span> Exception &#123;</div><div class=\"line\">        <span class=\"keyword\">Class</span>&lt;?&gt; clazz = <span class=\"keyword\">Class</span>.forName(<span class=\"string\">\"com.gemini.test.TestReflect\"</span>);</div><div class=\"line\">        System.out.<span class=\"keyword\">println</span>(<span class=\"string\">\"===============本类属性===============\"</span>);</div><div class=\"line\">        Field[] field = clazz.getDeclaredFields(); <span class=\"comment\">// 取得本类的全部属性</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; field.length; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> mo = field[i].getModifiers();<span class=\"comment\">// 权限修饰符</span></div><div class=\"line\">            String priv = Modifier.toString(mo);</div><div class=\"line\">            <span class=\"keyword\">Class</span>&lt;?&gt; type = field[i].getType();<span class=\"comment\">// 属性类型</span></div><div class=\"line\">            System.out.<span class=\"keyword\">println</span>(priv + <span class=\"string\">\" \"</span> + type.getName() + <span class=\"string\">\" \"</span> + field[i].getName() + <span class=\"string\">\";\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        System.out.<span class=\"keyword\">println</span>(<span class=\"string\">\"==========实现的接口或者父类的属性==========\"</span>);</div><div class=\"line\">        Field[] filed1 = clazz.getFields(); <span class=\"comment\">// 取得实现的接口或者父类的属性</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; filed1.length; j++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> mo = filed1[j].getModifiers();<span class=\"comment\">// 权限修饰符</span></div><div class=\"line\">            String priv = Modifier.toString(mo);</div><div class=\"line\">            <span class=\"keyword\">Class</span>&lt;?&gt; type = filed1[j].getType();<span class=\"comment\">// 属性类型</span></div><div class=\"line\">            System.out.<span class=\"keyword\">println</span>(priv + <span class=\"string\">\" \"</span> + type.getName() + <span class=\"string\">\" \"</span> + filed1[j].getName() + <span class=\"string\">\";\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>获取某个类的全部方法</p>\n<figure class=\"highlight monkey\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.io.Serializable;</div><div class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</div><div class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Modifier;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestReflect</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">private</span> static <span class=\"keyword\">final</span> long serialVersionUID = -<span class=\"number\">2862585049955236662</span>L;</div><div class=\"line\">    <span class=\"keyword\">public</span> static void main(String[] args) throws Exception &#123;</div><div class=\"line\">        <span class=\"class\"><span class=\"keyword\">Class</span>&lt;?&gt; <span class=\"title\">clazz</span> = <span class=\"title\">Class</span>.<span class=\"title\">forName</span>(\"<span class=\"title\">com</span>.<span class=\"title\">gemini</span>.<span class=\"title\">test</span>.<span class=\"title\">TestReflect</span>\");</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">Method</span> <span class=\"title\">method</span>[] =</span> clazz.getMethods();</div><div class=\"line\">        <span class=\"keyword\">for</span> (int i = <span class=\"number\">0</span>; i &lt; <span class=\"function\"><span class=\"keyword\">method</span>.<span class=\"title\">length</span>; ++<span class=\"title\">i</span>) &#123;</span></div><div class=\"line\">            <span class=\"class\"><span class=\"keyword\">Class</span>&lt;?&gt; <span class=\"title\">returnType</span> = <span class=\"title\">method</span>[<span class=\"title\">i</span>].<span class=\"title\">getReturnType</span>();</span></div><div class=\"line\">            <span class=\"class\"><span class=\"keyword\">Class</span>&lt;?&gt; <span class=\"title\">para</span>[] = <span class=\"title\">method</span>[<span class=\"title\">i</span>].<span class=\"title\">getParameterTypes</span>();</span></div><div class=\"line\">            int temp = <span class=\"function\"><span class=\"keyword\">method</span>[<span class=\"title\">i</span>].<span class=\"title\">getModifiers</span>(</span>);</div><div class=\"line\">            System.out.<span class=\"built_in\">print</span>(Modifier.toString(temp) + <span class=\"string\">\" \"</span>);</div><div class=\"line\">            System.out.<span class=\"built_in\">print</span>(returnType.getName() + <span class=\"string\">\"  \"</span>);</div><div class=\"line\">            System.out.<span class=\"built_in\">print</span>(<span class=\"function\"><span class=\"keyword\">method</span>[<span class=\"title\">i</span>].<span class=\"title\">getName</span>(</span>) + <span class=\"string\">\" \"</span>);</div><div class=\"line\">            System.out.<span class=\"built_in\">print</span>(<span class=\"string\">\"(\"</span>);</div><div class=\"line\">            <span class=\"keyword\">for</span> (int j = <span class=\"number\">0</span>; j &lt; para.length; ++j) &#123;</div><div class=\"line\">                System.out.<span class=\"built_in\">print</span>(para[j].getName() + <span class=\"string\">\" \"</span> + <span class=\"string\">\"arg\"</span> + j);</div><div class=\"line\">                <span class=\"keyword\">if</span> (j &lt; para.length - <span class=\"number\">1</span>) &#123;</div><div class=\"line\">                    System.out.<span class=\"built_in\">print</span>(<span class=\"string\">\",\"</span>);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"class\"><span class=\"keyword\">Class</span>&lt;?&gt; <span class=\"title\">exce</span>[] = <span class=\"title\">method</span>[<span class=\"title\">i</span>].<span class=\"title\">getExceptionTypes</span>();</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (exce.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                System.out.<span class=\"built_in\">print</span>(<span class=\"string\">\") throws \"</span>);</div><div class=\"line\">                <span class=\"keyword\">for</span> (int k = <span class=\"number\">0</span>; k &lt; exce.length; ++k) &#123;</div><div class=\"line\">                    System.out.<span class=\"built_in\">print</span>(exce[k].getName() + <span class=\"string\">\" \"</span>);</div><div class=\"line\">                    <span class=\"keyword\">if</span> (k &lt; exce.length - <span class=\"number\">1</span>) &#123;</div><div class=\"line\">                        System.out.<span class=\"built_in\">print</span>(<span class=\"string\">\",\"</span>);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                System.out.<span class=\"built_in\">print</span>(<span class=\"string\">\")\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">            System.out.println();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>通过反射机制调用某个类的方法</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> TestReflect &#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(<span class=\"keyword\">String</span>[] args) throws Exception &#123;</div><div class=\"line\">        Class&lt;?&gt; clazz = Class.forName(<span class=\"string\">\"net.xsoftlab.baike.TestReflect\"</span>);</div><div class=\"line\">        <span class=\"comment\">// 调用TestReflect类中的reflect1方法</span></div><div class=\"line\">        Method method = clazz.getMethod(<span class=\"string\">\"reflect1\"</span>);</div><div class=\"line\">        method.invoke(clazz.newInstance());</div><div class=\"line\">        <span class=\"comment\">// Java 反射机制 - 调用某个类的方法1.</span></div><div class=\"line\">        <span class=\"comment\">// 调用TestReflect的reflect2方法</span></div><div class=\"line\">        method = clazz.getMethod(<span class=\"string\">\"reflect2\"</span>, <span class=\"keyword\">int</span>.<span class=\"keyword\">class</span>, <span class=\"keyword\">String</span>.<span class=\"keyword\">class</span>);</div><div class=\"line\">        method.invoke(clazz.newInstance(), <span class=\"number\">20</span>, <span class=\"string\">\"张三\"</span>);</div><div class=\"line\">        <span class=\"comment\">// Java 反射机制 - 调用某个类的方法2.</span></div><div class=\"line\">        <span class=\"comment\">// age -&gt; 20. name -&gt; 张三</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> reflect1() &#123;</div><div class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Java 反射机制 - 调用某个类的方法1.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> reflect2(<span class=\"keyword\">int</span> age, <span class=\"keyword\">String</span> name) &#123;</div><div class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Java 反射机制 - 调用某个类的方法2.\"</span>);</div><div class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"age -&gt; \"</span> + age + <span class=\"string\">\". name -&gt; \"</span> + name);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>通过反射机制操作某个类的属性</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Field;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestReflect</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">String</span> proprety = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> void main(<span class=\"keyword\">String</span>[] args) throws Exception &#123;</div><div class=\"line\">        Class&lt;?&gt; clazz = Class.forName(<span class=\"string\">\"net.xsoftlab.baike.TestReflect\"</span>);</div><div class=\"line\">        Object obj = clazz.<span class=\"keyword\">new</span><span class=\"type\">Instance</span>();</div><div class=\"line\">        <span class=\"comment\">// 可以直接对 private 的属性赋值</span></div><div class=\"line\">        Field field = clazz.getDeclaredField(<span class=\"string\">\"proprety\"</span>);</div><div class=\"line\">        field.setAccessible(<span class=\"literal\">true</span>);</div><div class=\"line\">        field.<span class=\"keyword\">set</span>(obj, <span class=\"string\">\"Java反射机制\"</span>);</div><div class=\"line\">        System.out.println(field.<span class=\"keyword\">get</span>(obj));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>反射机制的动态代理</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 获取类加载器的方法</span></div><div class=\"line\">TestReflect testReflect = <span class=\"keyword\">new</span> <span class=\"type\">TestReflect</span>();</div><div class=\"line\">        System.out.println(<span class=\"string\">\"类加载器  \"</span> + testReflect.getClass().getClassLoader().getClass().getName());</div><div class=\"line\"><span class=\"keyword\">package</span> com.gemini.test;</div><div class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</div><div class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</div><div class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Proxy;</div><div class=\"line\"><span class=\"comment\">//定义项目接口</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subject</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> say(<span class=\"keyword\">String</span> name, int age);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 定义真实项目</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealSubject</span> <span class=\"keyword\"><span class=\"keyword\">implements</span> <span class=\"type\">Subject</span></span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> say(<span class=\"keyword\">String</span> name, int age) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name + <span class=\"string\">\"  \"</span> + age;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyInvocationHandler</span> <span class=\"keyword\"><span class=\"keyword\">implements</span> <span class=\"type\">InvocationHandler</span></span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> Object obj = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">public</span> Object bind(Object obj) &#123;</div><div class=\"line\">        <span class=\"built_in\">this</span>.obj = obj;</div><div class=\"line\">        <span class=\"keyword\">return</span> Proxy.<span class=\"keyword\">new</span><span class=\"type\">ProxyInstance</span>(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), <span class=\"built_in\">this</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">public</span> Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</div><div class=\"line\">        Object temp = method.invoke(<span class=\"built_in\">this</span>.obj, args);</div><div class=\"line\">        <span class=\"keyword\">return</span> temp;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 在java中有三种类类加载器。</div><div class=\"line\"> *</div><div class=\"line\"> * 1）Bootstrap ClassLoader 此加载器采用c++编写，一般开发中很少见。</div><div class=\"line\"> *</div><div class=\"line\"> * 2）Extension ClassLoader 用来进行扩展类的加载，一般对应的是jrelibext目录中的类</div><div class=\"line\"> *</div><div class=\"line\"> * 3）AppClassLoader 加载classpath指定的类，是最常用的加载器。同时也是java中默认的加载器。</div><div class=\"line\"> *</div><div class=\"line\"> * 如果想要完成动态代理，首先需要定义一个InvocationHandler接口的子类，已完成代理的具体操作。</div><div class=\"line\"> *</div><div class=\"line\"> * @author xsoftlab.net</div><div class=\"line\"> *</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestReflect</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> void main(<span class=\"keyword\">String</span>[] args) throws Exception &#123;</div><div class=\"line\">        MyInvocationHandler demo = <span class=\"keyword\">new</span> <span class=\"type\">MyInvocationHandler</span>();</div><div class=\"line\">        Subject sub = (Subject) demo.bind(<span class=\"keyword\">new</span> <span class=\"type\">RealSubject</span>());</div><div class=\"line\">        <span class=\"keyword\">String</span> info = sub.say(<span class=\"string\">\"Rollen\"</span>, <span class=\"number\">20</span>);</div><div class=\"line\">        System.out.println(info);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>将反射机制应用于工厂模式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">fruit</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>  <span class=\"title\">Apple</span> <span class=\"keyword\">implements</span> <span class=\"title\">fruit</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"Apple\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Orange</span> <span class=\"keyword\">implements</span> <span class=\"title\">fruit</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"Orange\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Factory</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> fruit <span class=\"title\">getInstance</span><span class=\"params\">(String ClassName)</span> </span>&#123;</div><div class=\"line\">        fruit f = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            f = (fruit) Class.forName(ClassName).newInstance();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> f;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 对于普通的工厂模式当我们在添加一个子类的时候，就需要对应的修改工厂类。 当我们添加很多的子类的时候，会很麻烦。</div><div class=\"line\"> * Java 工厂模式可以参考</div><div class=\"line\"> * http://baike.xsoftlab.net/view/java-factory-pattern</div><div class=\"line\"> *</div><div class=\"line\"> * 现在我们利用反射机制实现工厂模式，可以在不修改工厂类的情况下添加任意多个子类。</div><div class=\"line\"> * 但是有一点仍然很麻烦，就是需要知道完整的包名和类名，这里可以使用properties配置文件来完成。</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestReflect</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">        fruit f = Factory.getInstance(<span class=\"string\">\"com.gemini.test.Apple\"</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span> (f != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            f.eat();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"4-反射机制优化\"><a href=\"#4-反射机制优化\" class=\"headerlink\" title=\"4.反射机制优化\"></a>4.反射机制优化</h3><ol>\n<li>描述<br>从事java开发的都知道反射的运行速度慢，所以很多java的开发者都对反射机制的使用望而却步(包括BME组件SDO)。我想知道，究竟反射机制慢在哪里？有没有改进方法，让我们可以继续使用它？如果一个好东西因为其自身的一些缺陷而不使用它，那么实在可惜，反射也是这样。我想说的是：我们应该一点点的改进它。</li>\n<li>错误的使用方法<br>错误的使用方法是每次需要获取Class的对象时都使用Class.forName方法，或者需要调用Class对象上的方法时都调用getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)或getMethod(String name, Class&lt;?&gt;… parameterTypes)方法获取Method对象，再调用其上的invoke(Object obj, Object… args)方法。<br>这里存在两个容易造成性能损耗的地方：<br>Class.forName方法的调用会执行Class类文件在整个类路径下的搜索，频繁调用比较影响性能。<br>Class对象上的getDeclaredMethod (String, Class&lt;?&gt;…)或getMethod(String, Class&lt;?&gt;…)方法的调用会执行Method对象在Class对象上的搜索。有些同事还使用getMethods()方法获取Method数组，然后执行搜索任务，实际上getMethods()还会执行方法对象的集体Copy比直接使用(String, Class&lt;?&gt;…)或getMethod(String, Class&lt;?&gt;…)方法还要消耗时间及空间。</li>\n<li>Cache思想<br>Cache的思想是将需要的反射中间件给存储下来，以便以后使用。不管使用什么方法获取Class对象上的Method对象，返回的都是Method对象的copy对象。这些copy对象有的只是使用一次就被回收了，未免有些可惜。我们可这以将这些对象给缓存下来，以便以后使用。而在存储数据结构中，无疑HashMap的查找速度是最快的，它主要是通过对象的Hash码进行一次查找，速度超快。但是HashMap上的操作不是线程安全的，需要改进方法实现同步。</li>\n<li>具体实现<br>需要两个组件ClassInfo和ReflectionCache。<br>ClassInfo主要保存Class对象的信息，主要是方法Map。其中ClassInfo中包括三部分方法的Map: Getter, Setter, Other。Getter是Class的属性的获取方法，Setter是Class的属性的设置方法，Other是其它方法。需要注意的是Getter和Setter的方法需要完全符合Javabean规范(isXXX方法属于Getter方法范围内)，其key值是方法对应的属性名。Other方法是除Getter和Setter以外的其它方法。<br>ReflectionCache组件主要是通过HashMap对ClassInfo进行缓存。缓存的键值是ClassInfo中Class对象的全称。如一个String对象，它缓存的键值就是java.lang.String。并且ReflectionCache提供了几种不同get和put方法来方便用户的操作。<br>另外ClassInfo的生成需要用到ClassInfoUtils工具。它的主要工作是创建ClassInfo对象，其中创建ClassInfo时可以提供Method Type信息来指定缓存的方法类型（如：所有方法-All、存取器方法-Access、获取方法-Getter和设置方法-Setter）。</li>\n<li>同步控制<br>ReflectionCache中ClassInfoMap是一个静变量，那么随之而来的就是HashMap的同步问题。我对ReflectionCache的做了些改进，主要是对put方法的处理。首先HashMap的获取操作（get操作）没有加入同步操作，因此获取的操作是可以并发的。现在的问题在于如果获取不了ClassInfo对象时会要执行设置操作（set操作），此时并发问题随之而来。可能在同一时刻会有很多线程去设置ClassInfo，在第一个设置完ClassInfo的线程结束后，第二个线程应该停止设置ClassInfo。在此需求之上，我们需要对ReflectionCache的put操作上加上同步块，并且让put操作再执行一个额外的操作：返回添加到ClassInfoMap中的ClassInfo，不管它是不是其它线程添加的。因此我们在设置ClassInfo时，可以这样操作：<br>ClassInfo classInfo = ReflectionCache.putClassInfo(String.class);</li>\n<li>改进效率<br>改进之后的效率的提高是明显的。主要是节省了中间变量创建及反射数据的查找时间。测试数据:<br>100000次，20个线程，无Class.forName操作<br>一般用法: 11375 milliseconds<br>ReflectionCache: 2562 milliseconds<br>100000次，20个线程，有Class.forName操作<br>一般用法: 16125 milliseconds<br>ReflectionCache: 4187 milliseconds<br>可见使用ReflectionCache明显提高了效率。</li>\n</ol>\n<p>伪代码如下：<br><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1</span>.默认方式</div><div class=\"line\">Class clazz = Class.forName(<span class=\"string\">\"com.dianping.csc.page_config.view.entity.ViewConfig\"</span>)<span class=\"comment\">;</span></div><div class=\"line\">clazz.newInstance()<span class=\"comment\">;</span></div><div class=\"line\"><span class=\"number\">2</span>.<span class=\"keyword\">Cache加载Class</span></div><div class=\"line\"><span class=\"keyword\">CachedClass </span>classInfo = ReflectionCache.getCachedClass(ViewConfig.class)<span class=\"comment\">;</span></div><div class=\"line\">Class clazz = classInfo.getTheClass()<span class=\"comment\">;</span></div><div class=\"line\"><span class=\"number\">3</span>.<span class=\"keyword\">Cache加载Method</span></div><div class=\"line\">MethodAccess methodAccess = MethodAccess.get(classInfo.getTheClass())<span class=\"comment\">;</span></div><div class=\"line\">methodAccess.invoke()<span class=\"comment\">;</span></div><div class=\"line\">clazz.newInstance()<span class=\"comment\">;</span></div></pre></td></tr></table></figure></p>\n<p>引用用包如下：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.codehaus.groovy<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>groovy-all<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.4.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.esotericsoftware<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>reflectasm<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.11.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>程序示例：<br><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"><span class=\"markdown\">/**</span></span></div><div class=\"line\"> *根据Body字符串，自动封装</div><div class=\"line\"> * @param issueBody</div><div class=\"line\"> * @param obj</div><div class=\"line\"> * @return</div><div class=\"line\"> * @throws CscConfigException</div><div class=\"line\"> */</div><div class=\"line\">public <span class=\"keyword\">static</span> <span class=\"built_in\">Object</span> setJavaBeanByRequestBody(<span class=\"built_in\">String</span> issueBody, <span class=\"built_in\">Object</span> obj) throws CscConfigException &#123;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        JsonParser jsonParser = <span class=\"keyword\">new</span> JsonParser();</div><div class=\"line\"> JsonObject jsonObject = jsonParser.parse(issueBody).getAsJsonObject();</div><div class=\"line\"> <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">String</span>&gt; map = ObjectUtil.getObjectPro(obj.getClass());</div><div class=\"line\"> <span class=\"built_in\">Set</span>&lt;<span class=\"built_in\">Map</span>.Entry&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">String</span>&gt;&gt; mapping = map.entrySet();</div><div class=\"line\"> MethodAccess methodAccess = MethodAccess.<span class=\"keyword\">get</span>(obj.getClass());</div><div class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"built_in\">Map</span>.Entry&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">String</span>&gt; me : mapping) &#123;</div><div class=\"line\">            <span class=\"built_in\">String</span> name = me.getKey();</div><div class=\"line\"> <span class=\"built_in\">String</span> type = me.getValue();</div><div class=\"line\"> <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">                <span class=\"built_in\">int</span> index_ = methodAccess.getIndex(<span class=\"string\">\"set\"</span> + StringUtil.toFirstUp(name));</div><div class=\"line\"> <span class=\"keyword\">if</span> (type.contains(<span class=\"string\">\"String\"</span>)) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (jsonObject.<span class=\"keyword\">get</span>(name) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                        <span class=\"built_in\">String</span> setValue = <span class=\"string\">\"\"</span>;</div><div class=\"line\"> <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">                            setValue = jsonObject.<span class=\"keyword\">get</span>(name).getAsString();</div><div class=\"line\"> &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</div><div class=\"line\">                            setValue = jsonObject.<span class=\"keyword\">get</span>(name).toString();</div><div class=\"line\"> &#125;</div><div class=\"line\">                        <span class=\"keyword\">if</span> (setValue == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                            setValue = <span class=\"string\">\"\"</span>;</div><div class=\"line\"> &#125;</div><div class=\"line\">                        setValue = setValue.replace(<span class=\"string\">\"&amp;quot;\"</span>, <span class=\"string\">\"\"</span>).replace(<span class=\"string\">\"&amp;nbsp;\"</span>, <span class=\"string\">\"\"</span>);</div><div class=\"line\"> methodAccess.invoke(obj,index_,setValue);</div><div class=\"line\"> &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type.contains(<span class=\"string\">\"Long\"</span>)) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (jsonObject.<span class=\"keyword\">get</span>(name) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                        methodAccess.invoke(obj,index_,jsonObject.<span class=\"keyword\">get</span>(name).getAsLong());</div><div class=\"line\"> &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type.contains(<span class=\"string\">\"Date\"</span>)) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (jsonObject.<span class=\"keyword\">get</span>(name) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                        DateFormat dateformat = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>);</div><div class=\"line\"> Date date = dateformat.parse(jsonObject.<span class=\"keyword\">get</span>(name).toString());</div><div class=\"line\"></div><div class=\"line\"> &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type.contains(<span class=\"string\">\"Integer\"</span>)) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (jsonObject.<span class=\"keyword\">get</span>(name) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                        methodAccess.invoke(obj,index_,jsonObject.<span class=\"keyword\">get</span>(name).getAsInt());</div><div class=\"line\"> &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">        e.printStackTrace();</div><div class=\"line\"> <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> CscConfigException(<span class=\"number\">100001</span>,<span class=\"string\">\"信息获取异常\"</span>);</div><div class=\"line\"> &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> obj;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","excerpt":"<h3 id=\"1-何为反射机制\"><a href=\"#1-何为反射机制\" class=\"headerlink\" title=\"1.何为反射机制\"></a>1.何为反射机制</h3><p>反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。<br></p>","more":"<p></p>\n<h3 id=\"2-反射的应用场景\"><a href=\"#2-反射的应用场景\" class=\"headerlink\" title=\"2.反射的应用场景\"></a>2.反射的应用场景</h3><ol>\n<li>在运行时判断任意一个对象所属的类；</li>\n<li>在运行时构造任意一个类的对象；</li>\n<li>在运行时判断任意一个类所具有的成员变量和方法；</li>\n<li>在运行时调用任意一个对象的方法；</li>\n<li>生成动态代理；</li>\n</ol>\n<h3 id=\"3-反射机制相关API\"><a href=\"#3-反射机制相关API\" class=\"headerlink\" title=\"3.反射机制相关API\"></a>3.反射机制相关API</h3><ol>\n<li><p>通过一个对象获得完整的包名和类名</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">TestReflect</span> &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String[] args</span>) throws Exception </span>&#123;</div><div class=\"line\">        TestReflect testReflect = <span class=\"keyword\">new</span> TestReflect();</div><div class=\"line\">        System.<span class=\"keyword\">out</span>.println(testReflect.getClass().getName());</div><div class=\"line\">        <span class=\"comment\">// 结果 com.gemini.test.TestReflect</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>实例化Class类对象</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> TestReflect &#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(String[] args) <span class=\"keyword\">throws</span> Exception &#123;</div><div class=\"line\">        <span class=\"keyword\">Class</span>&lt;?&gt; class1 = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">Class</span>&lt;?&gt; class2 = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">Class</span>&lt;?&gt; class3 = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"comment\">// 一般采用这种形式</span></div><div class=\"line\">        class1 = <span class=\"keyword\">Class</span>.forName(<span class=\"string\">\"com.gemini.test.TestReflect\"</span>);</div><div class=\"line\">        class2 = <span class=\"keyword\">new</span> TestReflect().getClass();</div><div class=\"line\">        class3 = TestReflect.<span class=\"keyword\">class</span>;</div><div class=\"line\">        System.out.<span class=\"keyword\">println</span>(<span class=\"string\">\"类名称   \"</span> + class1.getName());</div><div class=\"line\">        System.out.<span class=\"keyword\">println</span>(<span class=\"string\">\"类名称   \"</span> + class2.getName());</div><div class=\"line\">        System.out.<span class=\"keyword\">println</span>(<span class=\"string\">\"类名称   \"</span> + class3.getName());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>获取一个对象的父类与实现的接口</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.io.Serializable;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> TestReflect <span class=\"keyword\">implements</span> Serializable &#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">2862585049955236662</span>L;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(String[] args) <span class=\"keyword\">throws</span> Exception &#123;</div><div class=\"line\">        <span class=\"keyword\">Class</span>&lt;?&gt; clazz = <span class=\"keyword\">Class</span>.forName(<span class=\"string\">\"net.xsoftlab.baike.TestReflect\"</span>);</div><div class=\"line\">        <span class=\"comment\">// 取得父类</span></div><div class=\"line\">        <span class=\"keyword\">Class</span>&lt;?&gt; parentClass = clazz.getSuperclass();</div><div class=\"line\">        System.out.<span class=\"keyword\">println</span>(<span class=\"string\">\"clazz的父类为：\"</span> + parentClass.getName());</div><div class=\"line\">        <span class=\"comment\">// clazz的父类为： java.lang.Object</span></div><div class=\"line\">        <span class=\"comment\">// 获取所有的接口</span></div><div class=\"line\">        <span class=\"keyword\">Class</span>&lt;?&gt; intes[] = clazz.getInterfaces();</div><div class=\"line\">        System.out.<span class=\"keyword\">println</span>(<span class=\"string\">\"clazz实现的接口有：\"</span>);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; intes.length; i++) &#123;</div><div class=\"line\">            System.out.<span class=\"keyword\">println</span>((i + <span class=\"number\">1</span>) + <span class=\"string\">\"：\"</span> + intes[i].getName());</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// clazz实现的接口有：</span></div><div class=\"line\">        <span class=\"comment\">// 1：java.io.Serializable</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>通过反射机制实例化一个类的对象</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\">import java.lang.reflect.Constructor;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">TestReflect</span> &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String[] args</span>) throws Exception </span>&#123;</div><div class=\"line\">        Class&lt;?&gt; class1 = <span class=\"literal\">null</span>;</div><div class=\"line\">        class1 = Class.forName(<span class=\"string\">\"com.gemini.test.User\"</span>);</div><div class=\"line\">        <span class=\"comment\">// 第一种方法，实例化默认构造方法，调用set赋值</span></div><div class=\"line\">        User user = (User) class1.newInstance();</div><div class=\"line\">        user.setAge(<span class=\"number\">20</span>);</div><div class=\"line\">        user.setName(<span class=\"string\">\"Rollen\"</span>);</div><div class=\"line\">        System.<span class=\"keyword\">out</span>.println(user); <span class=\"comment\">// 结果 User [age=20, name=Rollen]</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 第二种方法 取得全部的构造函数 使用构造函数赋值</span></div><div class=\"line\">        Constructor&lt;?&gt; cons[] = class1.getConstructors();</div><div class=\"line\">        <span class=\"comment\">// 查看每个构造方法需要的参数</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; cons.length; i++) &#123;</div><div class=\"line\">            Class&lt;?&gt; clazzs[] = cons[i].getParameterTypes();</div><div class=\"line\">            System.<span class=\"keyword\">out</span>.print(<span class=\"string\">\"cons[\"</span> + i + <span class=\"string\">\"] (\"</span>);</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; clazzs.length; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (j == clazzs.length - <span class=\"number\">1</span>)</div><div class=\"line\">                    System.<span class=\"keyword\">out</span>.print(clazzs[j].getName());</div><div class=\"line\">                <span class=\"keyword\">else</span></div><div class=\"line\">                    System.<span class=\"keyword\">out</span>.print(clazzs[j].getName() + <span class=\"string\">\",\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">            System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\")\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// 结果</span></div><div class=\"line\">        <span class=\"comment\">// cons[0] (java.lang.String)</span></div><div class=\"line\">        <span class=\"comment\">// cons[1] (int,java.lang.String)</span></div><div class=\"line\">        <span class=\"comment\">// cons[2] ()</span></div><div class=\"line\">        user = (User) cons[<span class=\"number\">0</span>].newInstance(<span class=\"string\">\"Rollen\"</span>);</div><div class=\"line\">        System.<span class=\"keyword\">out</span>.println(user);</div><div class=\"line\">        <span class=\"comment\">// 结果 User [age=0, name=Rollen]</span></div><div class=\"line\">        user = (User) cons[<span class=\"number\">1</span>].newInstance(<span class=\"number\">20</span>, <span class=\"string\">\"Rollen\"</span>);</div><div class=\"line\">        System.<span class=\"keyword\">out</span>.println(user);</div><div class=\"line\">        <span class=\"comment\">// 结果 User [age=20, name=Rollen]</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</div><div class=\"line\">    <span class=\"keyword\">private</span> String name;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        super();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span>(<span class=\"params\">String name</span>) </span>&#123;</div><div class=\"line\">        super();</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span>(<span class=\"params\"><span class=\"keyword\">int</span> age, String name</span>) </span>&#123;</div><div class=\"line\">        super();</div><div class=\"line\">        <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> age;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span>(<span class=\"params\"><span class=\"keyword\">int</span> age</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span>(<span class=\"params\">String name</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\">    @<span class=\"function\">Override</span></div><div class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title\">toString</span>(<span class=\"params\"></span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"User [age=\"</span> + age + <span class=\"string\">\", name=\"</span> + name + <span class=\"string\">\"]\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>获取某个类的全部属性</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.io.Serializable;</div><div class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Field;</div><div class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Modifier;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> TestReflect <span class=\"keyword\">implements</span> Serializable &#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">2862585049955236662</span>L;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(String[] args) <span class=\"keyword\">throws</span> Exception &#123;</div><div class=\"line\">        <span class=\"keyword\">Class</span>&lt;?&gt; clazz = <span class=\"keyword\">Class</span>.forName(<span class=\"string\">\"com.gemini.test.TestReflect\"</span>);</div><div class=\"line\">        System.out.<span class=\"keyword\">println</span>(<span class=\"string\">\"===============本类属性===============\"</span>);</div><div class=\"line\">        Field[] field = clazz.getDeclaredFields(); <span class=\"comment\">// 取得本类的全部属性</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; field.length; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> mo = field[i].getModifiers();<span class=\"comment\">// 权限修饰符</span></div><div class=\"line\">            String priv = Modifier.toString(mo);</div><div class=\"line\">            <span class=\"keyword\">Class</span>&lt;?&gt; type = field[i].getType();<span class=\"comment\">// 属性类型</span></div><div class=\"line\">            System.out.<span class=\"keyword\">println</span>(priv + <span class=\"string\">\" \"</span> + type.getName() + <span class=\"string\">\" \"</span> + field[i].getName() + <span class=\"string\">\";\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        System.out.<span class=\"keyword\">println</span>(<span class=\"string\">\"==========实现的接口或者父类的属性==========\"</span>);</div><div class=\"line\">        Field[] filed1 = clazz.getFields(); <span class=\"comment\">// 取得实现的接口或者父类的属性</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; filed1.length; j++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> mo = filed1[j].getModifiers();<span class=\"comment\">// 权限修饰符</span></div><div class=\"line\">            String priv = Modifier.toString(mo);</div><div class=\"line\">            <span class=\"keyword\">Class</span>&lt;?&gt; type = filed1[j].getType();<span class=\"comment\">// 属性类型</span></div><div class=\"line\">            System.out.<span class=\"keyword\">println</span>(priv + <span class=\"string\">\" \"</span> + type.getName() + <span class=\"string\">\" \"</span> + filed1[j].getName() + <span class=\"string\">\";\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>获取某个类的全部方法</p>\n<figure class=\"highlight monkey\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.io.Serializable;</div><div class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</div><div class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Modifier;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestReflect</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> &#123;</span></div><div class=\"line\">    <span class=\"keyword\">private</span> static <span class=\"keyword\">final</span> long serialVersionUID = -<span class=\"number\">2862585049955236662</span>L;</div><div class=\"line\">    <span class=\"keyword\">public</span> static void main(String[] args) throws Exception &#123;</div><div class=\"line\">        <span class=\"class\"><span class=\"keyword\">Class</span>&lt;?&gt; <span class=\"title\">clazz</span> = <span class=\"title\">Class</span>.<span class=\"title\">forName</span>(\"<span class=\"title\">com</span>.<span class=\"title\">gemini</span>.<span class=\"title\">test</span>.<span class=\"title\">TestReflect</span>\");</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">Method</span> <span class=\"title\">method</span>[] =</span> clazz.getMethods();</div><div class=\"line\">        <span class=\"keyword\">for</span> (int i = <span class=\"number\">0</span>; i &lt; <span class=\"function\"><span class=\"keyword\">method</span>.<span class=\"title\">length</span>; ++<span class=\"title\">i</span>) &#123;</span></div><div class=\"line\">            <span class=\"class\"><span class=\"keyword\">Class</span>&lt;?&gt; <span class=\"title\">returnType</span> = <span class=\"title\">method</span>[<span class=\"title\">i</span>].<span class=\"title\">getReturnType</span>();</span></div><div class=\"line\">            <span class=\"class\"><span class=\"keyword\">Class</span>&lt;?&gt; <span class=\"title\">para</span>[] = <span class=\"title\">method</span>[<span class=\"title\">i</span>].<span class=\"title\">getParameterTypes</span>();</span></div><div class=\"line\">            int temp = <span class=\"function\"><span class=\"keyword\">method</span>[<span class=\"title\">i</span>].<span class=\"title\">getModifiers</span>(</span>);</div><div class=\"line\">            System.out.<span class=\"built_in\">print</span>(Modifier.toString(temp) + <span class=\"string\">\" \"</span>);</div><div class=\"line\">            System.out.<span class=\"built_in\">print</span>(returnType.getName() + <span class=\"string\">\"  \"</span>);</div><div class=\"line\">            System.out.<span class=\"built_in\">print</span>(<span class=\"function\"><span class=\"keyword\">method</span>[<span class=\"title\">i</span>].<span class=\"title\">getName</span>(</span>) + <span class=\"string\">\" \"</span>);</div><div class=\"line\">            System.out.<span class=\"built_in\">print</span>(<span class=\"string\">\"(\"</span>);</div><div class=\"line\">            <span class=\"keyword\">for</span> (int j = <span class=\"number\">0</span>; j &lt; para.length; ++j) &#123;</div><div class=\"line\">                System.out.<span class=\"built_in\">print</span>(para[j].getName() + <span class=\"string\">\" \"</span> + <span class=\"string\">\"arg\"</span> + j);</div><div class=\"line\">                <span class=\"keyword\">if</span> (j &lt; para.length - <span class=\"number\">1</span>) &#123;</div><div class=\"line\">                    System.out.<span class=\"built_in\">print</span>(<span class=\"string\">\",\"</span>);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"class\"><span class=\"keyword\">Class</span>&lt;?&gt; <span class=\"title\">exce</span>[] = <span class=\"title\">method</span>[<span class=\"title\">i</span>].<span class=\"title\">getExceptionTypes</span>();</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (exce.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                System.out.<span class=\"built_in\">print</span>(<span class=\"string\">\") throws \"</span>);</div><div class=\"line\">                <span class=\"keyword\">for</span> (int k = <span class=\"number\">0</span>; k &lt; exce.length; ++k) &#123;</div><div class=\"line\">                    System.out.<span class=\"built_in\">print</span>(exce[k].getName() + <span class=\"string\">\" \"</span>);</div><div class=\"line\">                    <span class=\"keyword\">if</span> (k &lt; exce.length - <span class=\"number\">1</span>) &#123;</div><div class=\"line\">                        System.out.<span class=\"built_in\">print</span>(<span class=\"string\">\",\"</span>);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                System.out.<span class=\"built_in\">print</span>(<span class=\"string\">\")\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">            System.out.println();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>通过反射机制调用某个类的方法</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> TestReflect &#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(<span class=\"keyword\">String</span>[] args) throws Exception &#123;</div><div class=\"line\">        Class&lt;?&gt; clazz = Class.forName(<span class=\"string\">\"net.xsoftlab.baike.TestReflect\"</span>);</div><div class=\"line\">        <span class=\"comment\">// 调用TestReflect类中的reflect1方法</span></div><div class=\"line\">        Method method = clazz.getMethod(<span class=\"string\">\"reflect1\"</span>);</div><div class=\"line\">        method.invoke(clazz.newInstance());</div><div class=\"line\">        <span class=\"comment\">// Java 反射机制 - 调用某个类的方法1.</span></div><div class=\"line\">        <span class=\"comment\">// 调用TestReflect的reflect2方法</span></div><div class=\"line\">        method = clazz.getMethod(<span class=\"string\">\"reflect2\"</span>, <span class=\"keyword\">int</span>.<span class=\"keyword\">class</span>, <span class=\"keyword\">String</span>.<span class=\"keyword\">class</span>);</div><div class=\"line\">        method.invoke(clazz.newInstance(), <span class=\"number\">20</span>, <span class=\"string\">\"张三\"</span>);</div><div class=\"line\">        <span class=\"comment\">// Java 反射机制 - 调用某个类的方法2.</span></div><div class=\"line\">        <span class=\"comment\">// age -&gt; 20. name -&gt; 张三</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> reflect1() &#123;</div><div class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Java 反射机制 - 调用某个类的方法1.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> reflect2(<span class=\"keyword\">int</span> age, <span class=\"keyword\">String</span> name) &#123;</div><div class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Java 反射机制 - 调用某个类的方法2.\"</span>);</div><div class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"age -&gt; \"</span> + age + <span class=\"string\">\". name -&gt; \"</span> + name);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>通过反射机制操作某个类的属性</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Field;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestReflect</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">String</span> proprety = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> void main(<span class=\"keyword\">String</span>[] args) throws Exception &#123;</div><div class=\"line\">        Class&lt;?&gt; clazz = Class.forName(<span class=\"string\">\"net.xsoftlab.baike.TestReflect\"</span>);</div><div class=\"line\">        Object obj = clazz.<span class=\"keyword\">new</span><span class=\"type\">Instance</span>();</div><div class=\"line\">        <span class=\"comment\">// 可以直接对 private 的属性赋值</span></div><div class=\"line\">        Field field = clazz.getDeclaredField(<span class=\"string\">\"proprety\"</span>);</div><div class=\"line\">        field.setAccessible(<span class=\"literal\">true</span>);</div><div class=\"line\">        field.<span class=\"keyword\">set</span>(obj, <span class=\"string\">\"Java反射机制\"</span>);</div><div class=\"line\">        System.out.println(field.<span class=\"keyword\">get</span>(obj));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>反射机制的动态代理</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 获取类加载器的方法</span></div><div class=\"line\">TestReflect testReflect = <span class=\"keyword\">new</span> <span class=\"type\">TestReflect</span>();</div><div class=\"line\">        System.out.println(<span class=\"string\">\"类加载器  \"</span> + testReflect.getClass().getClassLoader().getClass().getName());</div><div class=\"line\"><span class=\"keyword\">package</span> com.gemini.test;</div><div class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</div><div class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</div><div class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Proxy;</div><div class=\"line\"><span class=\"comment\">//定义项目接口</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subject</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> say(<span class=\"keyword\">String</span> name, int age);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 定义真实项目</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealSubject</span> <span class=\"keyword\"><span class=\"keyword\">implements</span> <span class=\"type\">Subject</span></span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> say(<span class=\"keyword\">String</span> name, int age) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name + <span class=\"string\">\"  \"</span> + age;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyInvocationHandler</span> <span class=\"keyword\"><span class=\"keyword\">implements</span> <span class=\"type\">InvocationHandler</span></span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> Object obj = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">public</span> Object bind(Object obj) &#123;</div><div class=\"line\">        <span class=\"built_in\">this</span>.obj = obj;</div><div class=\"line\">        <span class=\"keyword\">return</span> Proxy.<span class=\"keyword\">new</span><span class=\"type\">ProxyInstance</span>(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), <span class=\"built_in\">this</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">public</span> Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</div><div class=\"line\">        Object temp = method.invoke(<span class=\"built_in\">this</span>.obj, args);</div><div class=\"line\">        <span class=\"keyword\">return</span> temp;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 在java中有三种类类加载器。</div><div class=\"line\"> *</div><div class=\"line\"> * 1）Bootstrap ClassLoader 此加载器采用c++编写，一般开发中很少见。</div><div class=\"line\"> *</div><div class=\"line\"> * 2）Extension ClassLoader 用来进行扩展类的加载，一般对应的是jrelibext目录中的类</div><div class=\"line\"> *</div><div class=\"line\"> * 3）AppClassLoader 加载classpath指定的类，是最常用的加载器。同时也是java中默认的加载器。</div><div class=\"line\"> *</div><div class=\"line\"> * 如果想要完成动态代理，首先需要定义一个InvocationHandler接口的子类，已完成代理的具体操作。</div><div class=\"line\"> *</div><div class=\"line\"> * @author xsoftlab.net</div><div class=\"line\"> *</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestReflect</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> void main(<span class=\"keyword\">String</span>[] args) throws Exception &#123;</div><div class=\"line\">        MyInvocationHandler demo = <span class=\"keyword\">new</span> <span class=\"type\">MyInvocationHandler</span>();</div><div class=\"line\">        Subject sub = (Subject) demo.bind(<span class=\"keyword\">new</span> <span class=\"type\">RealSubject</span>());</div><div class=\"line\">        <span class=\"keyword\">String</span> info = sub.say(<span class=\"string\">\"Rollen\"</span>, <span class=\"number\">20</span>);</div><div class=\"line\">        System.out.println(info);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>将反射机制应用于工厂模式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">fruit</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>  <span class=\"title\">Apple</span> <span class=\"keyword\">implements</span> <span class=\"title\">fruit</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"Apple\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Orange</span> <span class=\"keyword\">implements</span> <span class=\"title\">fruit</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"Orange\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Factory</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> fruit <span class=\"title\">getInstance</span><span class=\"params\">(String ClassName)</span> </span>&#123;</div><div class=\"line\">        fruit f = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            f = (fruit) Class.forName(ClassName).newInstance();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> f;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 对于普通的工厂模式当我们在添加一个子类的时候，就需要对应的修改工厂类。 当我们添加很多的子类的时候，会很麻烦。</div><div class=\"line\"> * Java 工厂模式可以参考</div><div class=\"line\"> * http://baike.xsoftlab.net/view/java-factory-pattern</div><div class=\"line\"> *</div><div class=\"line\"> * 现在我们利用反射机制实现工厂模式，可以在不修改工厂类的情况下添加任意多个子类。</div><div class=\"line\"> * 但是有一点仍然很麻烦，就是需要知道完整的包名和类名，这里可以使用properties配置文件来完成。</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestReflect</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">        fruit f = Factory.getInstance(<span class=\"string\">\"com.gemini.test.Apple\"</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span> (f != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            f.eat();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"4-反射机制优化\"><a href=\"#4-反射机制优化\" class=\"headerlink\" title=\"4.反射机制优化\"></a>4.反射机制优化</h3><ol>\n<li>描述<br>从事java开发的都知道反射的运行速度慢，所以很多java的开发者都对反射机制的使用望而却步(包括BME组件SDO)。我想知道，究竟反射机制慢在哪里？有没有改进方法，让我们可以继续使用它？如果一个好东西因为其自身的一些缺陷而不使用它，那么实在可惜，反射也是这样。我想说的是：我们应该一点点的改进它。</li>\n<li>错误的使用方法<br>错误的使用方法是每次需要获取Class的对象时都使用Class.forName方法，或者需要调用Class对象上的方法时都调用getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)或getMethod(String name, Class&lt;?&gt;… parameterTypes)方法获取Method对象，再调用其上的invoke(Object obj, Object… args)方法。<br>这里存在两个容易造成性能损耗的地方：<br>Class.forName方法的调用会执行Class类文件在整个类路径下的搜索，频繁调用比较影响性能。<br>Class对象上的getDeclaredMethod (String, Class&lt;?&gt;…)或getMethod(String, Class&lt;?&gt;…)方法的调用会执行Method对象在Class对象上的搜索。有些同事还使用getMethods()方法获取Method数组，然后执行搜索任务，实际上getMethods()还会执行方法对象的集体Copy比直接使用(String, Class&lt;?&gt;…)或getMethod(String, Class&lt;?&gt;…)方法还要消耗时间及空间。</li>\n<li>Cache思想<br>Cache的思想是将需要的反射中间件给存储下来，以便以后使用。不管使用什么方法获取Class对象上的Method对象，返回的都是Method对象的copy对象。这些copy对象有的只是使用一次就被回收了，未免有些可惜。我们可这以将这些对象给缓存下来，以便以后使用。而在存储数据结构中，无疑HashMap的查找速度是最快的，它主要是通过对象的Hash码进行一次查找，速度超快。但是HashMap上的操作不是线程安全的，需要改进方法实现同步。</li>\n<li>具体实现<br>需要两个组件ClassInfo和ReflectionCache。<br>ClassInfo主要保存Class对象的信息，主要是方法Map。其中ClassInfo中包括三部分方法的Map: Getter, Setter, Other。Getter是Class的属性的获取方法，Setter是Class的属性的设置方法，Other是其它方法。需要注意的是Getter和Setter的方法需要完全符合Javabean规范(isXXX方法属于Getter方法范围内)，其key值是方法对应的属性名。Other方法是除Getter和Setter以外的其它方法。<br>ReflectionCache组件主要是通过HashMap对ClassInfo进行缓存。缓存的键值是ClassInfo中Class对象的全称。如一个String对象，它缓存的键值就是java.lang.String。并且ReflectionCache提供了几种不同get和put方法来方便用户的操作。<br>另外ClassInfo的生成需要用到ClassInfoUtils工具。它的主要工作是创建ClassInfo对象，其中创建ClassInfo时可以提供Method Type信息来指定缓存的方法类型（如：所有方法-All、存取器方法-Access、获取方法-Getter和设置方法-Setter）。</li>\n<li>同步控制<br>ReflectionCache中ClassInfoMap是一个静变量，那么随之而来的就是HashMap的同步问题。我对ReflectionCache的做了些改进，主要是对put方法的处理。首先HashMap的获取操作（get操作）没有加入同步操作，因此获取的操作是可以并发的。现在的问题在于如果获取不了ClassInfo对象时会要执行设置操作（set操作），此时并发问题随之而来。可能在同一时刻会有很多线程去设置ClassInfo，在第一个设置完ClassInfo的线程结束后，第二个线程应该停止设置ClassInfo。在此需求之上，我们需要对ReflectionCache的put操作上加上同步块，并且让put操作再执行一个额外的操作：返回添加到ClassInfoMap中的ClassInfo，不管它是不是其它线程添加的。因此我们在设置ClassInfo时，可以这样操作：<br>ClassInfo classInfo = ReflectionCache.putClassInfo(String.class);</li>\n<li>改进效率<br>改进之后的效率的提高是明显的。主要是节省了中间变量创建及反射数据的查找时间。测试数据:<br>100000次，20个线程，无Class.forName操作<br>一般用法: 11375 milliseconds<br>ReflectionCache: 2562 milliseconds<br>100000次，20个线程，有Class.forName操作<br>一般用法: 16125 milliseconds<br>ReflectionCache: 4187 milliseconds<br>可见使用ReflectionCache明显提高了效率。</li>\n</ol>\n<p>伪代码如下：<br><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1</span>.默认方式</div><div class=\"line\">Class clazz = Class.forName(<span class=\"string\">\"com.dianping.csc.page_config.view.entity.ViewConfig\"</span>)<span class=\"comment\">;</span></div><div class=\"line\">clazz.newInstance()<span class=\"comment\">;</span></div><div class=\"line\"><span class=\"number\">2</span>.<span class=\"keyword\">Cache加载Class</span></div><div class=\"line\"><span class=\"keyword\">CachedClass </span>classInfo = ReflectionCache.getCachedClass(ViewConfig.class)<span class=\"comment\">;</span></div><div class=\"line\">Class clazz = classInfo.getTheClass()<span class=\"comment\">;</span></div><div class=\"line\"><span class=\"number\">3</span>.<span class=\"keyword\">Cache加载Method</span></div><div class=\"line\">MethodAccess methodAccess = MethodAccess.get(classInfo.getTheClass())<span class=\"comment\">;</span></div><div class=\"line\">methodAccess.invoke()<span class=\"comment\">;</span></div><div class=\"line\">clazz.newInstance()<span class=\"comment\">;</span></div></pre></td></tr></table></figure></p>\n<p>引用用包如下：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.codehaus.groovy<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>groovy-all<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.4.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.esotericsoftware<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>reflectasm<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.11.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>程序示例：<br><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"><span class=\"markdown\">/**</span></span></div><div class=\"line\"> *根据Body字符串，自动封装</div><div class=\"line\"> * @param issueBody</div><div class=\"line\"> * @param obj</div><div class=\"line\"> * @return</div><div class=\"line\"> * @throws CscConfigException</div><div class=\"line\"> */</div><div class=\"line\">public <span class=\"keyword\">static</span> <span class=\"built_in\">Object</span> setJavaBeanByRequestBody(<span class=\"built_in\">String</span> issueBody, <span class=\"built_in\">Object</span> obj) throws CscConfigException &#123;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        JsonParser jsonParser = <span class=\"keyword\">new</span> JsonParser();</div><div class=\"line\"> JsonObject jsonObject = jsonParser.parse(issueBody).getAsJsonObject();</div><div class=\"line\"> <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">String</span>&gt; map = ObjectUtil.getObjectPro(obj.getClass());</div><div class=\"line\"> <span class=\"built_in\">Set</span>&lt;<span class=\"built_in\">Map</span>.Entry&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">String</span>&gt;&gt; mapping = map.entrySet();</div><div class=\"line\"> MethodAccess methodAccess = MethodAccess.<span class=\"keyword\">get</span>(obj.getClass());</div><div class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"built_in\">Map</span>.Entry&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">String</span>&gt; me : mapping) &#123;</div><div class=\"line\">            <span class=\"built_in\">String</span> name = me.getKey();</div><div class=\"line\"> <span class=\"built_in\">String</span> type = me.getValue();</div><div class=\"line\"> <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">                <span class=\"built_in\">int</span> index_ = methodAccess.getIndex(<span class=\"string\">\"set\"</span> + StringUtil.toFirstUp(name));</div><div class=\"line\"> <span class=\"keyword\">if</span> (type.contains(<span class=\"string\">\"String\"</span>)) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (jsonObject.<span class=\"keyword\">get</span>(name) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                        <span class=\"built_in\">String</span> setValue = <span class=\"string\">\"\"</span>;</div><div class=\"line\"> <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">                            setValue = jsonObject.<span class=\"keyword\">get</span>(name).getAsString();</div><div class=\"line\"> &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</div><div class=\"line\">                            setValue = jsonObject.<span class=\"keyword\">get</span>(name).toString();</div><div class=\"line\"> &#125;</div><div class=\"line\">                        <span class=\"keyword\">if</span> (setValue == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                            setValue = <span class=\"string\">\"\"</span>;</div><div class=\"line\"> &#125;</div><div class=\"line\">                        setValue = setValue.replace(<span class=\"string\">\"&amp;quot;\"</span>, <span class=\"string\">\"\"</span>).replace(<span class=\"string\">\"&amp;nbsp;\"</span>, <span class=\"string\">\"\"</span>);</div><div class=\"line\"> methodAccess.invoke(obj,index_,setValue);</div><div class=\"line\"> &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type.contains(<span class=\"string\">\"Long\"</span>)) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (jsonObject.<span class=\"keyword\">get</span>(name) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                        methodAccess.invoke(obj,index_,jsonObject.<span class=\"keyword\">get</span>(name).getAsLong());</div><div class=\"line\"> &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type.contains(<span class=\"string\">\"Date\"</span>)) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (jsonObject.<span class=\"keyword\">get</span>(name) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                        DateFormat dateformat = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>);</div><div class=\"line\"> Date date = dateformat.parse(jsonObject.<span class=\"keyword\">get</span>(name).toString());</div><div class=\"line\"></div><div class=\"line\"> &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type.contains(<span class=\"string\">\"Integer\"</span>)) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (jsonObject.<span class=\"keyword\">get</span>(name) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                        methodAccess.invoke(obj,index_,jsonObject.<span class=\"keyword\">get</span>(name).getAsInt());</div><div class=\"line\"> &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">        e.printStackTrace();</div><div class=\"line\"> <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> CscConfigException(<span class=\"number\">100001</span>,<span class=\"string\">\"信息获取异常\"</span>);</div><div class=\"line\"> &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> obj;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>"},{"title":"面试题","date":"2017-07-19T01:54:16.000Z","toc":true,"_content":"### 一、Java基础\n1. String类为什么是final的。\n2. HashMap的源码，实现原理，底层结构。\n3. 说说你知道的几个Java集合类：list、set、queue、map实现类咯。。。\n4. 描述一下ArrayList和LinkedList各自实现和区别\n5. Java中的队列都有哪些，有什么区别。\n6. 反射中，Class.forName和classloader的区别\n<!--more-->\n7. Java7、Java8的新特性(baidu问的,好BT)\n8. Java数组和链表两种结构的操作效率，在哪些情况下(从开头开始，从结尾开始，从中间开始)，哪些操作(插入，查找，删除)的效率高\n9. Java内存泄露的问题调查定位：jmap，jstack的使用等等\n10. string、stringbuilder、stringbuffer区别\n11. hashtable和hashmap的区别\n13. 异常的结构，运行时异常和非运行时异常，各举个例子\n14. String a= “abc” String b = “abc” String c = new String(“abc”) String d = “ab” + “c” .他们之间用 == 比较的结果\n15. String 类的常用方法\n16. Java 的引用类型有哪几种\n17. 抽象类和接口的区别\n18. java的基础类型和字节大小。\n19. Hashtable,HashMap,ConcurrentHashMap 底层实现原理与线程安全问题（建议熟悉 jdk 源码，才能从容应答）\n20. 如果不让你用Java Jdk提供的工具，你自己实现一个Map，你怎么做。说了好久，说了HashMap源代码，如果我做，就会借鉴HashMap的原理，说了一通HashMap实现\n21. Hash冲突怎么办？哪些解决散列冲突的方法？\n22. HashMap冲突很厉害，最差性能，你会怎么解决?从O（n）提升到log（n）咯，用二叉排序树的思路说了一通\n23. rehash\n24. hashCode() 与 equals() 生成算法、方法怎么重写\n### 二、Java IO\n1. 讲讲IO里面的常见类，字节流、字符流、接口、实现类、方法阻塞。\n2. 讲讲NIO。\n3. String 编码UTF-8 和GBK的区别?\n4. 什么时候使用字节流、什么时候使用字符流?\n5. 递归读取文件夹下的文件，代码怎么实现\n### 三、java Web\n1. session和cookie的区别和联系，session的生命周期，多个服务部署时session管理。\n2. servlet的一些相关问题\n3. webservice相关问题\n4. jdbc连接，forname方式的步骤，怎么声明使用一个事务。举例并具体代码\n5. 无框架下配置web.xml的主要配置内容\n6. jsp和servlet的区别\n### 四、JVM\n1. Java的内存模型以及GC算法\n2. jvm性能调优都做了什么\n3. 介绍JVM中7个区域，然后把每个区域可能造成内存的溢出的情况说明\n4. 介绍GC 和GC Root不正常引用。\n5. 自己从classload 加载方式，加载机制说开去，从程序运行时数据区，讲到内存分配，讲到String常量池，讲到JVM垃圾回收机制，算法，hotspot。反正就是各种扩展\n6. jvm 如何分配直接内存， new 对象如何不分配在堆而是栈上，常量池解析\n7. 数组多大放在 JVM 老年代（不只是设置 PretenureSizeThreshold ，问通常多大，没做过一问便知）\n8. 老年代中数组的访问方式\n9. GC 算法，永久代对象如何 GC ， GC 有环怎么处理\n10. 谁会被 GC ，什么时候 GC\n11. 如果想不被 GC 怎么办\n12. 如果想在 GC 中生存 1 次怎么办\n### 五、开源框架\n1. hibernate和ibatis的区别\n2. 讲讲mybatis的连接池。\n3. spring框架中需要引用哪些jar包，以及这些jar包的用途\n4. springMVC的原理\n5. springMVC注解的意思\n6. spring中beanFactory和ApplicationContext的联系和区别\n7. spring注入的几种方式（循环注入）\n8. spring如何实现事物管理的\n9. springIOC\n10. spring AOP的原理\n11. hibernate中的1级和2级缓存的使用方式以及区别原理（Lazy-Load的理解）\n12. Hibernate的原理体系架构，五大核心接口，Hibernate对象的三种状态转换，事务管理。\n### 六、多线程\n1. Java创建线程之后，直接调用start()方法和run()的区别\n2. 常用的线程池模式以及不同线程池的使用场景\n3. newFixedThreadPool此种线程池如果线程数达到最大值后会怎么办，底层原理。\n4. 多线程之间通信的同步问题，synchronized锁的是对象，衍伸出和synchronized相关很多的具体问题，例如同一个类不同方法都有synchronized锁，一个对象是否可以同时访问。或者一个类的static构造方法加上synchronized之后的锁的影响。\n5. 了解可重入锁的含义，以及ReentrantLock 和synchronized的区别\n6. 同步的数据结构，例如concurrentHashMap的源码理解以及内部实现原理，为什么他是同步的且效率高\n7. atomicinteger和Volatile等线程安全操作的关键字的理解和使用\n8. 线程间通信，wait和notify\n9. 定时线程的使用\n10. 场景：在一个主线程中，要求有大量(很多很多)子线程执行完之后，主线程才执行完成。多种方式，考虑效率。\n11. 进程和线程的区别\n12. 什么叫线程安全？举例说明\n13. 线程的几种状态\n14. 并发、同步的接口或方法\n15. HashMap 是否线程安全，为何不安全。 ConcurrentHashMap，线程安全，为何安全。底层实现是怎么样的。\n16. J.U.C下的常见类的使用。 ThreadPool的深入考察； BlockingQueue的使用。（take，poll的区别，put，offer的区别）；原子类的实现。\n17. 简单介绍下多线程的情况，从建立一个线程开始。然后怎么控制同步过程，多线程常用的方法和结构\n18. volatile的理解\n19. 实现多线程有几种方式，多线程同步怎么做，说说几个线程里常用的方法\n### 七、网络通信\n1. http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么。\n2. socket通信，以及长连接，分包，连接异常断开的处理。\n3. socket通信模型的使用，AIO和NIO。\n4. socket框架netty的使用，以及NIO的实现原理，为什么是异步非阻塞。\n5. 同步和异步，阻塞和非阻塞。\n6. OSI七层模型，包括TCP,IP的一些基本知识\n7. http中，get post的区别\n8. 说说http,tcp,udp之间关系和区别。\n9. 说说浏览器访问www.taobao.com，经历了怎样的过程。\n10. HTTP协议、  HTTPS协议，SSL协议及完整交互过程；\n11. tcp的拥塞，快回传，ip的报文丢弃\n12. https处理的一个过程，对称加密和非对称加密\n13. head各个特点和区别\n14. 说说浏览器访问www.taobao.com，经历了怎样的过程。\n### 八、数据库MySQL\n1. mysql的存储引擎的不\n2. 单个索引、联合索引、主键索引\n3. Mysql怎么分表，以及分表后如果想按条件分页查询怎么办(如果不是按分表字段来查询的话，几乎效率低下，无解)\n4. 分表之后想让一个id多个表是自增的，效率实现\n5. MySql的主从实时备份同步的配置，以及原理(从库读主库的binlog)，读写分离\n6. 写SQL语句。。。\n7. 索引的数据结构，B+树\n8. 事务的四个特性，以及各自的特点（原子、隔离）等等，项目怎么解决这些问题\n9. 数据库的锁：行锁，表锁；乐观锁，悲观锁\n10. 数据库事务的几种粒度；\n11. 关系型和非关系型数据库区别\n### 九、设计模式\n1. 单例模式：饱汉、饿汉。以及饿汉中的延迟加载,双重检查\n2. 工厂模式、装饰者模式、观察者模式。\n3. 工厂方法模式的优点（低耦合、高内聚，开放封闭原则）\n### 十、算法\n1. 使用随机算法产生一个数，要求把1-1000W之间这些数全部生成。（考察高效率，解决产生冲突的问题）\n2. 两个有序数组的合并排序\n3. 一个数组的倒序\n4. 计算一个正整数的正平方根\n5. 说白了就是常见的那些查找、排序算法以及各自的时间复杂度\n6. 二叉树的遍历算法\n7. DFS,BFS算法\n9. 比较重要的数据结构，如链表，队列，栈的基本理解及大致实现。\n10. 排序算法与时空复杂度（快排为什么不稳定，为什么你的项目还在用）\n11. 逆波兰计算器\n12. Hoffman 编码\n13. 查找树与红黑树\n### 十一、并发与性能调优\n1. 有个每秒钟5k个请求，查询手机号所属地的笔试题(记得不完整，没列出)，如何设计算法?请求再多，比如5w，如何设计整个系统?\n2. 高并发情况下，我们系统是如何支撑大量的请求的\n3. 集群如何同步会话状态\n4. 负载均衡的原理\n5. 如果有一个特别大的访问量，到数据库上，怎么做优化（DB设计，DBIO，SQL优化，Java优化）\n6. 如果出现大面积并发，在不增加服务器的基础上，如何解决服务器响应不及时问题“。\n7. 假如你的项目出现性能瓶颈了，你觉得可能会是哪些方面，怎么解决问题。\n8. 如何查找 造成 性能瓶颈出现的位置，是哪个位置照成性能瓶颈。\n9. 你的项目中使用过缓存机制吗？有没用用户非本地缓存\n### 十二、其他\n1.常用的Linux下的命令","source":"_posts/11面试题.md","raw":"---\ntitle: 面试题\ndate: 2017-07-19 09:54:16\ntags: 面试 Java\ncategories: \"面试\"\ntoc: true\n---\n### 一、Java基础\n1. String类为什么是final的。\n2. HashMap的源码，实现原理，底层结构。\n3. 说说你知道的几个Java集合类：list、set、queue、map实现类咯。。。\n4. 描述一下ArrayList和LinkedList各自实现和区别\n5. Java中的队列都有哪些，有什么区别。\n6. 反射中，Class.forName和classloader的区别\n<!--more-->\n7. Java7、Java8的新特性(baidu问的,好BT)\n8. Java数组和链表两种结构的操作效率，在哪些情况下(从开头开始，从结尾开始，从中间开始)，哪些操作(插入，查找，删除)的效率高\n9. Java内存泄露的问题调查定位：jmap，jstack的使用等等\n10. string、stringbuilder、stringbuffer区别\n11. hashtable和hashmap的区别\n13. 异常的结构，运行时异常和非运行时异常，各举个例子\n14. String a= “abc” String b = “abc” String c = new String(“abc”) String d = “ab” + “c” .他们之间用 == 比较的结果\n15. String 类的常用方法\n16. Java 的引用类型有哪几种\n17. 抽象类和接口的区别\n18. java的基础类型和字节大小。\n19. Hashtable,HashMap,ConcurrentHashMap 底层实现原理与线程安全问题（建议熟悉 jdk 源码，才能从容应答）\n20. 如果不让你用Java Jdk提供的工具，你自己实现一个Map，你怎么做。说了好久，说了HashMap源代码，如果我做，就会借鉴HashMap的原理，说了一通HashMap实现\n21. Hash冲突怎么办？哪些解决散列冲突的方法？\n22. HashMap冲突很厉害，最差性能，你会怎么解决?从O（n）提升到log（n）咯，用二叉排序树的思路说了一通\n23. rehash\n24. hashCode() 与 equals() 生成算法、方法怎么重写\n### 二、Java IO\n1. 讲讲IO里面的常见类，字节流、字符流、接口、实现类、方法阻塞。\n2. 讲讲NIO。\n3. String 编码UTF-8 和GBK的区别?\n4. 什么时候使用字节流、什么时候使用字符流?\n5. 递归读取文件夹下的文件，代码怎么实现\n### 三、java Web\n1. session和cookie的区别和联系，session的生命周期，多个服务部署时session管理。\n2. servlet的一些相关问题\n3. webservice相关问题\n4. jdbc连接，forname方式的步骤，怎么声明使用一个事务。举例并具体代码\n5. 无框架下配置web.xml的主要配置内容\n6. jsp和servlet的区别\n### 四、JVM\n1. Java的内存模型以及GC算法\n2. jvm性能调优都做了什么\n3. 介绍JVM中7个区域，然后把每个区域可能造成内存的溢出的情况说明\n4. 介绍GC 和GC Root不正常引用。\n5. 自己从classload 加载方式，加载机制说开去，从程序运行时数据区，讲到内存分配，讲到String常量池，讲到JVM垃圾回收机制，算法，hotspot。反正就是各种扩展\n6. jvm 如何分配直接内存， new 对象如何不分配在堆而是栈上，常量池解析\n7. 数组多大放在 JVM 老年代（不只是设置 PretenureSizeThreshold ，问通常多大，没做过一问便知）\n8. 老年代中数组的访问方式\n9. GC 算法，永久代对象如何 GC ， GC 有环怎么处理\n10. 谁会被 GC ，什么时候 GC\n11. 如果想不被 GC 怎么办\n12. 如果想在 GC 中生存 1 次怎么办\n### 五、开源框架\n1. hibernate和ibatis的区别\n2. 讲讲mybatis的连接池。\n3. spring框架中需要引用哪些jar包，以及这些jar包的用途\n4. springMVC的原理\n5. springMVC注解的意思\n6. spring中beanFactory和ApplicationContext的联系和区别\n7. spring注入的几种方式（循环注入）\n8. spring如何实现事物管理的\n9. springIOC\n10. spring AOP的原理\n11. hibernate中的1级和2级缓存的使用方式以及区别原理（Lazy-Load的理解）\n12. Hibernate的原理体系架构，五大核心接口，Hibernate对象的三种状态转换，事务管理。\n### 六、多线程\n1. Java创建线程之后，直接调用start()方法和run()的区别\n2. 常用的线程池模式以及不同线程池的使用场景\n3. newFixedThreadPool此种线程池如果线程数达到最大值后会怎么办，底层原理。\n4. 多线程之间通信的同步问题，synchronized锁的是对象，衍伸出和synchronized相关很多的具体问题，例如同一个类不同方法都有synchronized锁，一个对象是否可以同时访问。或者一个类的static构造方法加上synchronized之后的锁的影响。\n5. 了解可重入锁的含义，以及ReentrantLock 和synchronized的区别\n6. 同步的数据结构，例如concurrentHashMap的源码理解以及内部实现原理，为什么他是同步的且效率高\n7. atomicinteger和Volatile等线程安全操作的关键字的理解和使用\n8. 线程间通信，wait和notify\n9. 定时线程的使用\n10. 场景：在一个主线程中，要求有大量(很多很多)子线程执行完之后，主线程才执行完成。多种方式，考虑效率。\n11. 进程和线程的区别\n12. 什么叫线程安全？举例说明\n13. 线程的几种状态\n14. 并发、同步的接口或方法\n15. HashMap 是否线程安全，为何不安全。 ConcurrentHashMap，线程安全，为何安全。底层实现是怎么样的。\n16. J.U.C下的常见类的使用。 ThreadPool的深入考察； BlockingQueue的使用。（take，poll的区别，put，offer的区别）；原子类的实现。\n17. 简单介绍下多线程的情况，从建立一个线程开始。然后怎么控制同步过程，多线程常用的方法和结构\n18. volatile的理解\n19. 实现多线程有几种方式，多线程同步怎么做，说说几个线程里常用的方法\n### 七、网络通信\n1. http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么。\n2. socket通信，以及长连接，分包，连接异常断开的处理。\n3. socket通信模型的使用，AIO和NIO。\n4. socket框架netty的使用，以及NIO的实现原理，为什么是异步非阻塞。\n5. 同步和异步，阻塞和非阻塞。\n6. OSI七层模型，包括TCP,IP的一些基本知识\n7. http中，get post的区别\n8. 说说http,tcp,udp之间关系和区别。\n9. 说说浏览器访问www.taobao.com，经历了怎样的过程。\n10. HTTP协议、  HTTPS协议，SSL协议及完整交互过程；\n11. tcp的拥塞，快回传，ip的报文丢弃\n12. https处理的一个过程，对称加密和非对称加密\n13. head各个特点和区别\n14. 说说浏览器访问www.taobao.com，经历了怎样的过程。\n### 八、数据库MySQL\n1. mysql的存储引擎的不\n2. 单个索引、联合索引、主键索引\n3. Mysql怎么分表，以及分表后如果想按条件分页查询怎么办(如果不是按分表字段来查询的话，几乎效率低下，无解)\n4. 分表之后想让一个id多个表是自增的，效率实现\n5. MySql的主从实时备份同步的配置，以及原理(从库读主库的binlog)，读写分离\n6. 写SQL语句。。。\n7. 索引的数据结构，B+树\n8. 事务的四个特性，以及各自的特点（原子、隔离）等等，项目怎么解决这些问题\n9. 数据库的锁：行锁，表锁；乐观锁，悲观锁\n10. 数据库事务的几种粒度；\n11. 关系型和非关系型数据库区别\n### 九、设计模式\n1. 单例模式：饱汉、饿汉。以及饿汉中的延迟加载,双重检查\n2. 工厂模式、装饰者模式、观察者模式。\n3. 工厂方法模式的优点（低耦合、高内聚，开放封闭原则）\n### 十、算法\n1. 使用随机算法产生一个数，要求把1-1000W之间这些数全部生成。（考察高效率，解决产生冲突的问题）\n2. 两个有序数组的合并排序\n3. 一个数组的倒序\n4. 计算一个正整数的正平方根\n5. 说白了就是常见的那些查找、排序算法以及各自的时间复杂度\n6. 二叉树的遍历算法\n7. DFS,BFS算法\n9. 比较重要的数据结构，如链表，队列，栈的基本理解及大致实现。\n10. 排序算法与时空复杂度（快排为什么不稳定，为什么你的项目还在用）\n11. 逆波兰计算器\n12. Hoffman 编码\n13. 查找树与红黑树\n### 十一、并发与性能调优\n1. 有个每秒钟5k个请求，查询手机号所属地的笔试题(记得不完整，没列出)，如何设计算法?请求再多，比如5w，如何设计整个系统?\n2. 高并发情况下，我们系统是如何支撑大量的请求的\n3. 集群如何同步会话状态\n4. 负载均衡的原理\n5. 如果有一个特别大的访问量，到数据库上，怎么做优化（DB设计，DBIO，SQL优化，Java优化）\n6. 如果出现大面积并发，在不增加服务器的基础上，如何解决服务器响应不及时问题“。\n7. 假如你的项目出现性能瓶颈了，你觉得可能会是哪些方面，怎么解决问题。\n8. 如何查找 造成 性能瓶颈出现的位置，是哪个位置照成性能瓶颈。\n9. 你的项目中使用过缓存机制吗？有没用用户非本地缓存\n### 十二、其他\n1.常用的Linux下的命令","slug":"11面试题","published":1,"updated":"2017-07-20T08:12:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tc9j0006a7xwy999qv15","content":"<h3 id=\"一、Java基础\"><a href=\"#一、Java基础\" class=\"headerlink\" title=\"一、Java基础\"></a>一、Java基础</h3><ol>\n<li>String类为什么是final的。</li>\n<li>HashMap的源码，实现原理，底层结构。</li>\n<li>说说你知道的几个Java集合类：list、set、queue、map实现类咯。。。</li>\n<li>描述一下ArrayList和LinkedList各自实现和区别</li>\n<li>Java中的队列都有哪些，有什么区别。</li>\n<li>反射中，Class.forName和classloader的区别<a id=\"more\"></a></li>\n<li>Java7、Java8的新特性(baidu问的,好BT)</li>\n<li>Java数组和链表两种结构的操作效率，在哪些情况下(从开头开始，从结尾开始，从中间开始)，哪些操作(插入，查找，删除)的效率高</li>\n<li>Java内存泄露的问题调查定位：jmap，jstack的使用等等</li>\n<li>string、stringbuilder、stringbuffer区别</li>\n<li>hashtable和hashmap的区别</li>\n<li>异常的结构，运行时异常和非运行时异常，各举个例子</li>\n<li>String a= “abc” String b = “abc” String c = new String(“abc”) String d = “ab” + “c” .他们之间用 == 比较的结果</li>\n<li>String 类的常用方法</li>\n<li>Java 的引用类型有哪几种</li>\n<li>抽象类和接口的区别</li>\n<li>java的基础类型和字节大小。</li>\n<li>Hashtable,HashMap,ConcurrentHashMap 底层实现原理与线程安全问题（建议熟悉 jdk 源码，才能从容应答）</li>\n<li>如果不让你用Java Jdk提供的工具，你自己实现一个Map，你怎么做。说了好久，说了HashMap源代码，如果我做，就会借鉴HashMap的原理，说了一通HashMap实现</li>\n<li>Hash冲突怎么办？哪些解决散列冲突的方法？</li>\n<li>HashMap冲突很厉害，最差性能，你会怎么解决?从O（n）提升到log（n）咯，用二叉排序树的思路说了一通</li>\n<li>rehash</li>\n<li>hashCode() 与 equals() 生成算法、方法怎么重写<h3 id=\"二、Java-IO\"><a href=\"#二、Java-IO\" class=\"headerlink\" title=\"二、Java IO\"></a>二、Java IO</h3></li>\n<li>讲讲IO里面的常见类，字节流、字符流、接口、实现类、方法阻塞。</li>\n<li>讲讲NIO。</li>\n<li>String 编码UTF-8 和GBK的区别?</li>\n<li>什么时候使用字节流、什么时候使用字符流?</li>\n<li>递归读取文件夹下的文件，代码怎么实现<h3 id=\"三、java-Web\"><a href=\"#三、java-Web\" class=\"headerlink\" title=\"三、java Web\"></a>三、java Web</h3></li>\n<li>session和cookie的区别和联系，session的生命周期，多个服务部署时session管理。</li>\n<li>servlet的一些相关问题</li>\n<li>webservice相关问题</li>\n<li>jdbc连接，forname方式的步骤，怎么声明使用一个事务。举例并具体代码</li>\n<li>无框架下配置web.xml的主要配置内容</li>\n<li>jsp和servlet的区别<h3 id=\"四、JVM\"><a href=\"#四、JVM\" class=\"headerlink\" title=\"四、JVM\"></a>四、JVM</h3></li>\n<li>Java的内存模型以及GC算法</li>\n<li>jvm性能调优都做了什么</li>\n<li>介绍JVM中7个区域，然后把每个区域可能造成内存的溢出的情况说明</li>\n<li>介绍GC 和GC Root不正常引用。</li>\n<li>自己从classload 加载方式，加载机制说开去，从程序运行时数据区，讲到内存分配，讲到String常量池，讲到JVM垃圾回收机制，算法，hotspot。反正就是各种扩展</li>\n<li>jvm 如何分配直接内存， new 对象如何不分配在堆而是栈上，常量池解析</li>\n<li>数组多大放在 JVM 老年代（不只是设置 PretenureSizeThreshold ，问通常多大，没做过一问便知）</li>\n<li>老年代中数组的访问方式</li>\n<li>GC 算法，永久代对象如何 GC ， GC 有环怎么处理</li>\n<li>谁会被 GC ，什么时候 GC</li>\n<li>如果想不被 GC 怎么办</li>\n<li>如果想在 GC 中生存 1 次怎么办<h3 id=\"五、开源框架\"><a href=\"#五、开源框架\" class=\"headerlink\" title=\"五、开源框架\"></a>五、开源框架</h3></li>\n<li>hibernate和ibatis的区别</li>\n<li>讲讲mybatis的连接池。</li>\n<li>spring框架中需要引用哪些jar包，以及这些jar包的用途</li>\n<li>springMVC的原理</li>\n<li>springMVC注解的意思</li>\n<li>spring中beanFactory和ApplicationContext的联系和区别</li>\n<li>spring注入的几种方式（循环注入）</li>\n<li>spring如何实现事物管理的</li>\n<li>springIOC</li>\n<li>spring AOP的原理</li>\n<li>hibernate中的1级和2级缓存的使用方式以及区别原理（Lazy-Load的理解）</li>\n<li>Hibernate的原理体系架构，五大核心接口，Hibernate对象的三种状态转换，事务管理。<h3 id=\"六、多线程\"><a href=\"#六、多线程\" class=\"headerlink\" title=\"六、多线程\"></a>六、多线程</h3></li>\n<li>Java创建线程之后，直接调用start()方法和run()的区别</li>\n<li>常用的线程池模式以及不同线程池的使用场景</li>\n<li>newFixedThreadPool此种线程池如果线程数达到最大值后会怎么办，底层原理。</li>\n<li>多线程之间通信的同步问题，synchronized锁的是对象，衍伸出和synchronized相关很多的具体问题，例如同一个类不同方法都有synchronized锁，一个对象是否可以同时访问。或者一个类的static构造方法加上synchronized之后的锁的影响。</li>\n<li>了解可重入锁的含义，以及ReentrantLock 和synchronized的区别</li>\n<li>同步的数据结构，例如concurrentHashMap的源码理解以及内部实现原理，为什么他是同步的且效率高</li>\n<li>atomicinteger和Volatile等线程安全操作的关键字的理解和使用</li>\n<li>线程间通信，wait和notify</li>\n<li>定时线程的使用</li>\n<li>场景：在一个主线程中，要求有大量(很多很多)子线程执行完之后，主线程才执行完成。多种方式，考虑效率。</li>\n<li>进程和线程的区别</li>\n<li>什么叫线程安全？举例说明</li>\n<li>线程的几种状态</li>\n<li>并发、同步的接口或方法</li>\n<li>HashMap 是否线程安全，为何不安全。 ConcurrentHashMap，线程安全，为何安全。底层实现是怎么样的。</li>\n<li>J.U.C下的常见类的使用。 ThreadPool的深入考察； BlockingQueue的使用。（take，poll的区别，put，offer的区别）；原子类的实现。</li>\n<li>简单介绍下多线程的情况，从建立一个线程开始。然后怎么控制同步过程，多线程常用的方法和结构</li>\n<li>volatile的理解</li>\n<li>实现多线程有几种方式，多线程同步怎么做，说说几个线程里常用的方法<h3 id=\"七、网络通信\"><a href=\"#七、网络通信\" class=\"headerlink\" title=\"七、网络通信\"></a>七、网络通信</h3></li>\n<li>http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么。</li>\n<li>socket通信，以及长连接，分包，连接异常断开的处理。</li>\n<li>socket通信模型的使用，AIO和NIO。</li>\n<li>socket框架netty的使用，以及NIO的实现原理，为什么是异步非阻塞。</li>\n<li>同步和异步，阻塞和非阻塞。</li>\n<li>OSI七层模型，包括TCP,IP的一些基本知识</li>\n<li>http中，get post的区别</li>\n<li>说说http,tcp,udp之间关系和区别。</li>\n<li>说说浏览器访问www.taobao.com，经历了怎样的过程。</li>\n<li>HTTP协议、  HTTPS协议，SSL协议及完整交互过程；</li>\n<li>tcp的拥塞，快回传，ip的报文丢弃</li>\n<li>https处理的一个过程，对称加密和非对称加密</li>\n<li>head各个特点和区别</li>\n<li>说说浏览器访问www.taobao.com，经历了怎样的过程。<h3 id=\"八、数据库MySQL\"><a href=\"#八、数据库MySQL\" class=\"headerlink\" title=\"八、数据库MySQL\"></a>八、数据库MySQL</h3></li>\n<li>mysql的存储引擎的不</li>\n<li>单个索引、联合索引、主键索引</li>\n<li>Mysql怎么分表，以及分表后如果想按条件分页查询怎么办(如果不是按分表字段来查询的话，几乎效率低下，无解)</li>\n<li>分表之后想让一个id多个表是自增的，效率实现</li>\n<li>MySql的主从实时备份同步的配置，以及原理(从库读主库的binlog)，读写分离</li>\n<li>写SQL语句。。。</li>\n<li>索引的数据结构，B+树</li>\n<li>事务的四个特性，以及各自的特点（原子、隔离）等等，项目怎么解决这些问题</li>\n<li>数据库的锁：行锁，表锁；乐观锁，悲观锁</li>\n<li>数据库事务的几种粒度；</li>\n<li>关系型和非关系型数据库区别<h3 id=\"九、设计模式\"><a href=\"#九、设计模式\" class=\"headerlink\" title=\"九、设计模式\"></a>九、设计模式</h3></li>\n<li>单例模式：饱汉、饿汉。以及饿汉中的延迟加载,双重检查</li>\n<li>工厂模式、装饰者模式、观察者模式。</li>\n<li>工厂方法模式的优点（低耦合、高内聚，开放封闭原则）<h3 id=\"十、算法\"><a href=\"#十、算法\" class=\"headerlink\" title=\"十、算法\"></a>十、算法</h3></li>\n<li>使用随机算法产生一个数，要求把1-1000W之间这些数全部生成。（考察高效率，解决产生冲突的问题）</li>\n<li>两个有序数组的合并排序</li>\n<li>一个数组的倒序</li>\n<li>计算一个正整数的正平方根</li>\n<li>说白了就是常见的那些查找、排序算法以及各自的时间复杂度</li>\n<li>二叉树的遍历算法</li>\n<li>DFS,BFS算法</li>\n<li>比较重要的数据结构，如链表，队列，栈的基本理解及大致实现。</li>\n<li>排序算法与时空复杂度（快排为什么不稳定，为什么你的项目还在用）</li>\n<li>逆波兰计算器</li>\n<li>Hoffman 编码</li>\n<li>查找树与红黑树<h3 id=\"十一、并发与性能调优\"><a href=\"#十一、并发与性能调优\" class=\"headerlink\" title=\"十一、并发与性能调优\"></a>十一、并发与性能调优</h3></li>\n<li>有个每秒钟5k个请求，查询手机号所属地的笔试题(记得不完整，没列出)，如何设计算法?请求再多，比如5w，如何设计整个系统?</li>\n<li>高并发情况下，我们系统是如何支撑大量的请求的</li>\n<li>集群如何同步会话状态</li>\n<li>负载均衡的原理</li>\n<li>如果有一个特别大的访问量，到数据库上，怎么做优化（DB设计，DBIO，SQL优化，Java优化）</li>\n<li>如果出现大面积并发，在不增加服务器的基础上，如何解决服务器响应不及时问题“。</li>\n<li>假如你的项目出现性能瓶颈了，你觉得可能会是哪些方面，怎么解决问题。</li>\n<li>如何查找 造成 性能瓶颈出现的位置，是哪个位置照成性能瓶颈。</li>\n<li>你的项目中使用过缓存机制吗？有没用用户非本地缓存<h3 id=\"十二、其他\"><a href=\"#十二、其他\" class=\"headerlink\" title=\"十二、其他\"></a>十二、其他</h3>1.常用的Linux下的命令</li>\n</ol>\n","excerpt":"<h3 id=\"一、Java基础\"><a href=\"#一、Java基础\" class=\"headerlink\" title=\"一、Java基础\"></a>一、Java基础</h3><ol>\n<li>String类为什么是final的。</li>\n<li>HashMap的源码，实现原理，底层结构。</li>\n<li>说说你知道的几个Java集合类：list、set、queue、map实现类咯。。。</li>\n<li>描述一下ArrayList和LinkedList各自实现和区别</li>\n<li>Java中的队列都有哪些，有什么区别。</li>\n<li>反射中，Class.forName和classloader的区别</li></ol>","more":"\n<li>Java7、Java8的新特性(baidu问的,好BT)</li>\n<li>Java数组和链表两种结构的操作效率，在哪些情况下(从开头开始，从结尾开始，从中间开始)，哪些操作(插入，查找，删除)的效率高</li>\n<li>Java内存泄露的问题调查定位：jmap，jstack的使用等等</li>\n<li>string、stringbuilder、stringbuffer区别</li>\n<li>hashtable和hashmap的区别</li>\n<li>异常的结构，运行时异常和非运行时异常，各举个例子</li>\n<li>String a= “abc” String b = “abc” String c = new String(“abc”) String d = “ab” + “c” .他们之间用 == 比较的结果</li>\n<li>String 类的常用方法</li>\n<li>Java 的引用类型有哪几种</li>\n<li>抽象类和接口的区别</li>\n<li>java的基础类型和字节大小。</li>\n<li>Hashtable,HashMap,ConcurrentHashMap 底层实现原理与线程安全问题（建议熟悉 jdk 源码，才能从容应答）</li>\n<li>如果不让你用Java Jdk提供的工具，你自己实现一个Map，你怎么做。说了好久，说了HashMap源代码，如果我做，就会借鉴HashMap的原理，说了一通HashMap实现</li>\n<li>Hash冲突怎么办？哪些解决散列冲突的方法？</li>\n<li>HashMap冲突很厉害，最差性能，你会怎么解决?从O（n）提升到log（n）咯，用二叉排序树的思路说了一通</li>\n<li>rehash</li>\n<li>hashCode() 与 equals() 生成算法、方法怎么重写<h3 id=\"二、Java-IO\"><a href=\"#二、Java-IO\" class=\"headerlink\" title=\"二、Java IO\"></a>二、Java IO</h3></li>\n<li>讲讲IO里面的常见类，字节流、字符流、接口、实现类、方法阻塞。</li>\n<li>讲讲NIO。</li>\n<li>String 编码UTF-8 和GBK的区别?</li>\n<li>什么时候使用字节流、什么时候使用字符流?</li>\n<li>递归读取文件夹下的文件，代码怎么实现<h3 id=\"三、java-Web\"><a href=\"#三、java-Web\" class=\"headerlink\" title=\"三、java Web\"></a>三、java Web</h3></li>\n<li>session和cookie的区别和联系，session的生命周期，多个服务部署时session管理。</li>\n<li>servlet的一些相关问题</li>\n<li>webservice相关问题</li>\n<li>jdbc连接，forname方式的步骤，怎么声明使用一个事务。举例并具体代码</li>\n<li>无框架下配置web.xml的主要配置内容</li>\n<li>jsp和servlet的区别<h3 id=\"四、JVM\"><a href=\"#四、JVM\" class=\"headerlink\" title=\"四、JVM\"></a>四、JVM</h3></li>\n<li>Java的内存模型以及GC算法</li>\n<li>jvm性能调优都做了什么</li>\n<li>介绍JVM中7个区域，然后把每个区域可能造成内存的溢出的情况说明</li>\n<li>介绍GC 和GC Root不正常引用。</li>\n<li>自己从classload 加载方式，加载机制说开去，从程序运行时数据区，讲到内存分配，讲到String常量池，讲到JVM垃圾回收机制，算法，hotspot。反正就是各种扩展</li>\n<li>jvm 如何分配直接内存， new 对象如何不分配在堆而是栈上，常量池解析</li>\n<li>数组多大放在 JVM 老年代（不只是设置 PretenureSizeThreshold ，问通常多大，没做过一问便知）</li>\n<li>老年代中数组的访问方式</li>\n<li>GC 算法，永久代对象如何 GC ， GC 有环怎么处理</li>\n<li>谁会被 GC ，什么时候 GC</li>\n<li>如果想不被 GC 怎么办</li>\n<li>如果想在 GC 中生存 1 次怎么办<h3 id=\"五、开源框架\"><a href=\"#五、开源框架\" class=\"headerlink\" title=\"五、开源框架\"></a>五、开源框架</h3></li>\n<li>hibernate和ibatis的区别</li>\n<li>讲讲mybatis的连接池。</li>\n<li>spring框架中需要引用哪些jar包，以及这些jar包的用途</li>\n<li>springMVC的原理</li>\n<li>springMVC注解的意思</li>\n<li>spring中beanFactory和ApplicationContext的联系和区别</li>\n<li>spring注入的几种方式（循环注入）</li>\n<li>spring如何实现事物管理的</li>\n<li>springIOC</li>\n<li>spring AOP的原理</li>\n<li>hibernate中的1级和2级缓存的使用方式以及区别原理（Lazy-Load的理解）</li>\n<li>Hibernate的原理体系架构，五大核心接口，Hibernate对象的三种状态转换，事务管理。<h3 id=\"六、多线程\"><a href=\"#六、多线程\" class=\"headerlink\" title=\"六、多线程\"></a>六、多线程</h3></li>\n<li>Java创建线程之后，直接调用start()方法和run()的区别</li>\n<li>常用的线程池模式以及不同线程池的使用场景</li>\n<li>newFixedThreadPool此种线程池如果线程数达到最大值后会怎么办，底层原理。</li>\n<li>多线程之间通信的同步问题，synchronized锁的是对象，衍伸出和synchronized相关很多的具体问题，例如同一个类不同方法都有synchronized锁，一个对象是否可以同时访问。或者一个类的static构造方法加上synchronized之后的锁的影响。</li>\n<li>了解可重入锁的含义，以及ReentrantLock 和synchronized的区别</li>\n<li>同步的数据结构，例如concurrentHashMap的源码理解以及内部实现原理，为什么他是同步的且效率高</li>\n<li>atomicinteger和Volatile等线程安全操作的关键字的理解和使用</li>\n<li>线程间通信，wait和notify</li>\n<li>定时线程的使用</li>\n<li>场景：在一个主线程中，要求有大量(很多很多)子线程执行完之后，主线程才执行完成。多种方式，考虑效率。</li>\n<li>进程和线程的区别</li>\n<li>什么叫线程安全？举例说明</li>\n<li>线程的几种状态</li>\n<li>并发、同步的接口或方法</li>\n<li>HashMap 是否线程安全，为何不安全。 ConcurrentHashMap，线程安全，为何安全。底层实现是怎么样的。</li>\n<li>J.U.C下的常见类的使用。 ThreadPool的深入考察； BlockingQueue的使用。（take，poll的区别，put，offer的区别）；原子类的实现。</li>\n<li>简单介绍下多线程的情况，从建立一个线程开始。然后怎么控制同步过程，多线程常用的方法和结构</li>\n<li>volatile的理解</li>\n<li>实现多线程有几种方式，多线程同步怎么做，说说几个线程里常用的方法<h3 id=\"七、网络通信\"><a href=\"#七、网络通信\" class=\"headerlink\" title=\"七、网络通信\"></a>七、网络通信</h3></li>\n<li>http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么。</li>\n<li>socket通信，以及长连接，分包，连接异常断开的处理。</li>\n<li>socket通信模型的使用，AIO和NIO。</li>\n<li>socket框架netty的使用，以及NIO的实现原理，为什么是异步非阻塞。</li>\n<li>同步和异步，阻塞和非阻塞。</li>\n<li>OSI七层模型，包括TCP,IP的一些基本知识</li>\n<li>http中，get post的区别</li>\n<li>说说http,tcp,udp之间关系和区别。</li>\n<li>说说浏览器访问www.taobao.com，经历了怎样的过程。</li>\n<li>HTTP协议、  HTTPS协议，SSL协议及完整交互过程；</li>\n<li>tcp的拥塞，快回传，ip的报文丢弃</li>\n<li>https处理的一个过程，对称加密和非对称加密</li>\n<li>head各个特点和区别</li>\n<li>说说浏览器访问www.taobao.com，经历了怎样的过程。<h3 id=\"八、数据库MySQL\"><a href=\"#八、数据库MySQL\" class=\"headerlink\" title=\"八、数据库MySQL\"></a>八、数据库MySQL</h3></li>\n<li>mysql的存储引擎的不</li>\n<li>单个索引、联合索引、主键索引</li>\n<li>Mysql怎么分表，以及分表后如果想按条件分页查询怎么办(如果不是按分表字段来查询的话，几乎效率低下，无解)</li>\n<li>分表之后想让一个id多个表是自增的，效率实现</li>\n<li>MySql的主从实时备份同步的配置，以及原理(从库读主库的binlog)，读写分离</li>\n<li>写SQL语句。。。</li>\n<li>索引的数据结构，B+树</li>\n<li>事务的四个特性，以及各自的特点（原子、隔离）等等，项目怎么解决这些问题</li>\n<li>数据库的锁：行锁，表锁；乐观锁，悲观锁</li>\n<li>数据库事务的几种粒度；</li>\n<li>关系型和非关系型数据库区别<h3 id=\"九、设计模式\"><a href=\"#九、设计模式\" class=\"headerlink\" title=\"九、设计模式\"></a>九、设计模式</h3></li>\n<li>单例模式：饱汉、饿汉。以及饿汉中的延迟加载,双重检查</li>\n<li>工厂模式、装饰者模式、观察者模式。</li>\n<li>工厂方法模式的优点（低耦合、高内聚，开放封闭原则）<h3 id=\"十、算法\"><a href=\"#十、算法\" class=\"headerlink\" title=\"十、算法\"></a>十、算法</h3></li>\n<li>使用随机算法产生一个数，要求把1-1000W之间这些数全部生成。（考察高效率，解决产生冲突的问题）</li>\n<li>两个有序数组的合并排序</li>\n<li>一个数组的倒序</li>\n<li>计算一个正整数的正平方根</li>\n<li>说白了就是常见的那些查找、排序算法以及各自的时间复杂度</li>\n<li>二叉树的遍历算法</li>\n<li>DFS,BFS算法</li>\n<li>比较重要的数据结构，如链表，队列，栈的基本理解及大致实现。</li>\n<li>排序算法与时空复杂度（快排为什么不稳定，为什么你的项目还在用）</li>\n<li>逆波兰计算器</li>\n<li>Hoffman 编码</li>\n<li>查找树与红黑树<h3 id=\"十一、并发与性能调优\"><a href=\"#十一、并发与性能调优\" class=\"headerlink\" title=\"十一、并发与性能调优\"></a>十一、并发与性能调优</h3></li>\n<li>有个每秒钟5k个请求，查询手机号所属地的笔试题(记得不完整，没列出)，如何设计算法?请求再多，比如5w，如何设计整个系统?</li>\n<li>高并发情况下，我们系统是如何支撑大量的请求的</li>\n<li>集群如何同步会话状态</li>\n<li>负载均衡的原理</li>\n<li>如果有一个特别大的访问量，到数据库上，怎么做优化（DB设计，DBIO，SQL优化，Java优化）</li>\n<li>如果出现大面积并发，在不增加服务器的基础上，如何解决服务器响应不及时问题“。</li>\n<li>假如你的项目出现性能瓶颈了，你觉得可能会是哪些方面，怎么解决问题。</li>\n<li>如何查找 造成 性能瓶颈出现的位置，是哪个位置照成性能瓶颈。</li>\n<li>你的项目中使用过缓存机制吗？有没用用户非本地缓存<h3 id=\"十二、其他\"><a href=\"#十二、其他\" class=\"headerlink\" title=\"十二、其他\"></a>十二、其他</h3>1.常用的Linux下的命令</li>\n"},{"title":"常见Jar包简介","date":"2017-07-19T03:22:40.000Z","_content":"```\n了解一些Jar包的功能,分析部分类的功能\n```\n#### rt.jar\n- java.util;\n\n\n\n\n#### javax.servlet:servlet-api\n- http://tomcat.apache.org/tomcat-5.5-doc/servletapi/index.html\n\n#### commons-lang\n```\n<dependency>\n            <groupId>commons-lang</groupId>\n            <artifactId>commons-lang</artifactId>\n            <version>3.8.1</version>\n        </dependency>\n```","source":"_posts/13常见Jar包简介.md","raw":"---\ntitle: 常见Jar包简介\ndate: 2017-07-19 11:22:40\ntags: Java\ncategories: \"Java\"\n---\n```\n了解一些Jar包的功能,分析部分类的功能\n```\n#### rt.jar\n- java.util;\n\n\n\n\n#### javax.servlet:servlet-api\n- http://tomcat.apache.org/tomcat-5.5-doc/servletapi/index.html\n\n#### commons-lang\n```\n<dependency>\n            <groupId>commons-lang</groupId>\n            <artifactId>commons-lang</artifactId>\n            <version>3.8.1</version>\n        </dependency>\n```","slug":"13常见Jar包简介","published":1,"updated":"2018-11-29T03:53:15.985Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tc9m0007a7xwlqnvvxiv","content":"<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">了解一些Jar包的功能,分析部分类的功能</div></pre></td></tr></table></figure>\n<h4 id=\"rt-jar\"><a href=\"#rt-jar\" class=\"headerlink\" title=\"rt.jar\"></a>rt.jar</h4><ul>\n<li>java.util;</li>\n</ul>\n<h4 id=\"javax-servlet-servlet-api\"><a href=\"#javax-servlet-servlet-api\" class=\"headerlink\" title=\"javax.servlet:servlet-api\"></a>javax.servlet:servlet-api</h4><ul>\n<li><a href=\"http://tomcat.apache.org/tomcat-5.5-doc/servletapi/index.html\" target=\"_blank\" rel=\"external\">http://tomcat.apache.org/tomcat-5.5-doc/servletapi/index.html</a></li>\n</ul>\n<h4 id=\"commons-lang\"><a href=\"#commons-lang\" class=\"headerlink\" title=\"commons-lang\"></a>commons-lang</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>commons-lang<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>commons-lang<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.8.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div></pre></td></tr></table></figure>","excerpt":"","more":"<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">了解一些Jar包的功能,分析部分类的功能</div></pre></td></tr></table></figure>\n<h4 id=\"rt-jar\"><a href=\"#rt-jar\" class=\"headerlink\" title=\"rt.jar\"></a>rt.jar</h4><ul>\n<li>java.util;</li>\n</ul>\n<h4 id=\"javax-servlet-servlet-api\"><a href=\"#javax-servlet-servlet-api\" class=\"headerlink\" title=\"javax.servlet:servlet-api\"></a>javax.servlet:servlet-api</h4><ul>\n<li><a href=\"http://tomcat.apache.org/tomcat-5.5-doc/servletapi/index.html\">http://tomcat.apache.org/tomcat-5.5-doc/servletapi/index.html</a></li>\n</ul>\n<h4 id=\"commons-lang\"><a href=\"#commons-lang\" class=\"headerlink\" title=\"commons-lang\"></a>commons-lang</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>commons-lang<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>commons-lang<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.8.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div></pre></td></tr></table></figure>"},{"title":"深入理解Java虚拟机知识点","date":"2017-07-19T03:05:13.000Z","toc":true,"_content":"#### 一.jvm体系总体分四大块：\n1. 类的加载机制\n2. jvm内存结构\n3. GC算法 垃圾回收\n4. GC分析 命令调优\n<!--more-->\n对于搞开发的我们其实也是一样，现在流行的框架越来越多，封装的也越来越完善，各种框架可以搞定一切，几乎不用关注底层的实现，初级程序员只要熟悉基本的使用方法，便可以快速的开发上线；但对于高级程序员来讲，内功的修炼却越发的重要，比如算法、设计模式、底层原理等，只有把这些基础熟练之后，才能在开发过程中知其然知其所以然，出现问题时能快速定位到问题的本质。\n对于Java程序员来讲，spring全家桶几乎可以搞定一切，spring全家桶便是精妙的招式，jvm就是内功心法很重要的一块，线上出现性能问题，jvm调优更是不可回避的问题。因此JVM基础知识对于高级程序员的重要性不必言语.\n\n#### 二.类的加载机制\n1. 什么是类的加载\n2. 类的生命周期\n3. 类加载器\n4. 双亲委派模型\n\n#### 三.什么是类的加载\n类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。\n\n#### 四.类的生命周期\n1. 加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象\n2. 连接，连接又包含三块内容：验证、准备、初始化。1）验证，文件格式、元数据、字节码、符号引用验证；2）准备，为类的静态变量分配内存，并将其初始化为默认值；3）解析，把类中的符号引用转换为直接引用\n3. 初始化，为类的静态变量赋予正确的初始值\n4. 使用，new出对象程序中使用\n5. 卸载，执行垃圾回收\n\n#### 五.类加载器\n1. 启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\\jre\\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库\n2. 扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\\jre\\lib\\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。\n3. 应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器\n\n#### 六.类加载机制\n1. 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入\n2. 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类\n3. 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效\n\n#### 七.jvm内存结构\n![JVM内存分配](http://ol5edn32j.bkt.clouddn.com/JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.jpeg)\n\n1. 方法区和对是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。\n2. Java堆（Heap）,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。\n3. 方法区（Method Area）,方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\n4. 程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。\n5. JVM栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。\n6. 本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。\n\n#### 八.对象分配规则\n1. 对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。\n2. 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。\n3. 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。\n4. 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。\n5. 空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。\n\n#### 九.GC算法\nGC最基础的算法有三种：标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。\n1. 标记 -清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。\n2. 复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。\n3. 标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存\n4. 分代收集算法，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。\n\n#### 十.垃圾回收器\n1. Serial收集器，串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。\n2. ParNew收集器，ParNew收集器其实就是Serial收集器的多线程版本。\n3. Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。\n4. Parallel Old 收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法\n5. CMS收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。\n6. G1收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征\n7. GC算法和垃圾回收器算法图解以及更详细内容参考JVM（3）：Java GC算法 垃圾收集器\n\n#### 十一.GC日志分析\n摘录GC日志一部分（前部分为年轻代gc回收；后部分为full gc回收）：\n2016-07-05T10:43:18.093+0800: 25.395: [GC [PSYoungGen: 274931K->10738K(274944K)] 371093K->147186K(450048K), 0.0668480 secs] [Times: user=0.17 sys=0.08, real=0.07 secs]\n2016-07-05T10:43:18.160+0800: 25.462: [Full GC [PSYoungGen: 10738K->0K(274944K)] [ParOldGen: 136447K->140379K(302592K)] 147186K->140379K(577536K) [PSPermGen: 85411K->85376K(171008K)], 0.6763541 secs] [Times: user=1.75 sys=0.02, real=0.68 secs]\n通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数\n\n#### 十二.调优命令\nSun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo\n1. jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。\n2. jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。\n3. jmap，JVM Memory Map命令用于生成heap dump文件\n4. jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看\n5. jstack，用于生成java虚拟机当前时刻的线程快照。\n6. jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。\n详细的命令使用参考这里JVM（4）：Jvm调优-命令篇\n\n#### 十三.调优工具\n常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。\n1. jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控\n2. jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。\n3. MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗\n4. GChisto，一款专业分析gc日志的工具","source":"_posts/12深入理解Java虚拟机知识点.md","raw":"---\ntitle: 深入理解Java虚拟机知识点\ndate: 2017-07-19 11:05:13\ntags: Java JVM 虚拟机\ncategories: \"Java\"\ntoc: true\n---\n#### 一.jvm体系总体分四大块：\n1. 类的加载机制\n2. jvm内存结构\n3. GC算法 垃圾回收\n4. GC分析 命令调优\n<!--more-->\n对于搞开发的我们其实也是一样，现在流行的框架越来越多，封装的也越来越完善，各种框架可以搞定一切，几乎不用关注底层的实现，初级程序员只要熟悉基本的使用方法，便可以快速的开发上线；但对于高级程序员来讲，内功的修炼却越发的重要，比如算法、设计模式、底层原理等，只有把这些基础熟练之后，才能在开发过程中知其然知其所以然，出现问题时能快速定位到问题的本质。\n对于Java程序员来讲，spring全家桶几乎可以搞定一切，spring全家桶便是精妙的招式，jvm就是内功心法很重要的一块，线上出现性能问题，jvm调优更是不可回避的问题。因此JVM基础知识对于高级程序员的重要性不必言语.\n\n#### 二.类的加载机制\n1. 什么是类的加载\n2. 类的生命周期\n3. 类加载器\n4. 双亲委派模型\n\n#### 三.什么是类的加载\n类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。\n\n#### 四.类的生命周期\n1. 加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象\n2. 连接，连接又包含三块内容：验证、准备、初始化。1）验证，文件格式、元数据、字节码、符号引用验证；2）准备，为类的静态变量分配内存，并将其初始化为默认值；3）解析，把类中的符号引用转换为直接引用\n3. 初始化，为类的静态变量赋予正确的初始值\n4. 使用，new出对象程序中使用\n5. 卸载，执行垃圾回收\n\n#### 五.类加载器\n1. 启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\\jre\\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库\n2. 扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\\jre\\lib\\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。\n3. 应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器\n\n#### 六.类加载机制\n1. 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入\n2. 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类\n3. 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效\n\n#### 七.jvm内存结构\n![JVM内存分配](http://ol5edn32j.bkt.clouddn.com/JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.jpeg)\n\n1. 方法区和对是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。\n2. Java堆（Heap）,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。\n3. 方法区（Method Area）,方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\n4. 程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。\n5. JVM栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。\n6. 本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。\n\n#### 八.对象分配规则\n1. 对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。\n2. 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。\n3. 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。\n4. 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。\n5. 空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。\n\n#### 九.GC算法\nGC最基础的算法有三种：标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。\n1. 标记 -清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。\n2. 复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。\n3. 标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存\n4. 分代收集算法，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。\n\n#### 十.垃圾回收器\n1. Serial收集器，串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。\n2. ParNew收集器，ParNew收集器其实就是Serial收集器的多线程版本。\n3. Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。\n4. Parallel Old 收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法\n5. CMS收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。\n6. G1收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征\n7. GC算法和垃圾回收器算法图解以及更详细内容参考JVM（3）：Java GC算法 垃圾收集器\n\n#### 十一.GC日志分析\n摘录GC日志一部分（前部分为年轻代gc回收；后部分为full gc回收）：\n2016-07-05T10:43:18.093+0800: 25.395: [GC [PSYoungGen: 274931K->10738K(274944K)] 371093K->147186K(450048K), 0.0668480 secs] [Times: user=0.17 sys=0.08, real=0.07 secs]\n2016-07-05T10:43:18.160+0800: 25.462: [Full GC [PSYoungGen: 10738K->0K(274944K)] [ParOldGen: 136447K->140379K(302592K)] 147186K->140379K(577536K) [PSPermGen: 85411K->85376K(171008K)], 0.6763541 secs] [Times: user=1.75 sys=0.02, real=0.68 secs]\n通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数\n\n#### 十二.调优命令\nSun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo\n1. jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。\n2. jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。\n3. jmap，JVM Memory Map命令用于生成heap dump文件\n4. jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看\n5. jstack，用于生成java虚拟机当前时刻的线程快照。\n6. jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。\n详细的命令使用参考这里JVM（4）：Jvm调优-命令篇\n\n#### 十三.调优工具\n常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。\n1. jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控\n2. jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。\n3. MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗\n4. GChisto，一款专业分析gc日志的工具","slug":"12深入理解Java虚拟机知识点","published":1,"updated":"2017-07-20T09:02:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tc9n0008a7xwx5uhtrtj","content":"<h4 id=\"一-jvm体系总体分四大块：\"><a href=\"#一-jvm体系总体分四大块：\" class=\"headerlink\" title=\"一.jvm体系总体分四大块：\"></a>一.jvm体系总体分四大块：</h4><ol>\n<li>类的加载机制</li>\n<li>jvm内存结构</li>\n<li>GC算法 垃圾回收</li>\n<li>GC分析 命令调优<a id=\"more\"></a>\n对于搞开发的我们其实也是一样，现在流行的框架越来越多，封装的也越来越完善，各种框架可以搞定一切，几乎不用关注底层的实现，初级程序员只要熟悉基本的使用方法，便可以快速的开发上线；但对于高级程序员来讲，内功的修炼却越发的重要，比如算法、设计模式、底层原理等，只有把这些基础熟练之后，才能在开发过程中知其然知其所以然，出现问题时能快速定位到问题的本质。<br>对于Java程序员来讲，spring全家桶几乎可以搞定一切，spring全家桶便是精妙的招式，jvm就是内功心法很重要的一块，线上出现性能问题，jvm调优更是不可回避的问题。因此JVM基础知识对于高级程序员的重要性不必言语.</li>\n</ol>\n<h4 id=\"二-类的加载机制\"><a href=\"#二-类的加载机制\" class=\"headerlink\" title=\"二.类的加载机制\"></a>二.类的加载机制</h4><ol>\n<li>什么是类的加载</li>\n<li>类的生命周期</li>\n<li>类加载器</li>\n<li>双亲委派模型</li>\n</ol>\n<h4 id=\"三-什么是类的加载\"><a href=\"#三-什么是类的加载\" class=\"headerlink\" title=\"三.什么是类的加载\"></a>三.什么是类的加载</h4><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p>\n<h4 id=\"四-类的生命周期\"><a href=\"#四-类的生命周期\" class=\"headerlink\" title=\"四.类的生命周期\"></a>四.类的生命周期</h4><ol>\n<li>加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象</li>\n<li>连接，连接又包含三块内容：验证、准备、初始化。1）验证，文件格式、元数据、字节码、符号引用验证；2）准备，为类的静态变量分配内存，并将其初始化为默认值；3）解析，把类中的符号引用转换为直接引用</li>\n<li>初始化，为类的静态变量赋予正确的初始值</li>\n<li>使用，new出对象程序中使用</li>\n<li>卸载，执行垃圾回收</li>\n</ol>\n<h4 id=\"五-类加载器\"><a href=\"#五-类加载器\" class=\"headerlink\" title=\"五.类加载器\"></a>五.类加载器</h4><ol>\n<li>启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\\jre\\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库</li>\n<li>扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\\jre\\lib\\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</li>\n<li>应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器</li>\n</ol>\n<h4 id=\"六-类加载机制\"><a href=\"#六-类加载机制\" class=\"headerlink\" title=\"六.类加载机制\"></a>六.类加载机制</h4><ol>\n<li>全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li>\n<li>父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li>\n<li>缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li>\n</ol>\n<h4 id=\"七-jvm内存结构\"><a href=\"#七-jvm内存结构\" class=\"headerlink\" title=\"七.jvm内存结构\"></a>七.jvm内存结构</h4><p><img src=\"http://ol5edn32j.bkt.clouddn.com/JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.jpeg\" alt=\"JVM内存分配\"></p>\n<ol>\n<li>方法区和对是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。</li>\n<li>Java堆（Heap）,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</li>\n<li>方法区（Method Area）,方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li>\n<li>程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。</li>\n<li>JVM栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>\n<li>本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</li>\n</ol>\n<h4 id=\"八-对象分配规则\"><a href=\"#八-对象分配规则\" class=\"headerlink\" title=\"八.对象分配规则\"></a>八.对象分配规则</h4><ol>\n<li>对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。</li>\n<li>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</li>\n<li>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。</li>\n<li>动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</li>\n<li>空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。</li>\n</ol>\n<h4 id=\"九-GC算法\"><a href=\"#九-GC算法\" class=\"headerlink\" title=\"九.GC算法\"></a>九.GC算法</h4><p>GC最基础的算法有三种：标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。</p>\n<ol>\n<li>标记 -清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。</li>\n<li>复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</li>\n<li>标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</li>\n<li>分代收集算法，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</li>\n</ol>\n<h4 id=\"十-垃圾回收器\"><a href=\"#十-垃圾回收器\" class=\"headerlink\" title=\"十.垃圾回收器\"></a>十.垃圾回收器</h4><ol>\n<li>Serial收集器，串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。</li>\n<li>ParNew收集器，ParNew收集器其实就是Serial收集器的多线程版本。</li>\n<li>Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。</li>\n<li>Parallel Old 收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法</li>\n<li>CMS收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</li>\n<li>G1收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征</li>\n<li>GC算法和垃圾回收器算法图解以及更详细内容参考JVM（3）：Java GC算法 垃圾收集器</li>\n</ol>\n<h4 id=\"十一-GC日志分析\"><a href=\"#十一-GC日志分析\" class=\"headerlink\" title=\"十一.GC日志分析\"></a>十一.GC日志分析</h4><p>摘录GC日志一部分（前部分为年轻代gc回收；后部分为full gc回收）：<br>2016-07-05T10:43:18.093+0800: 25.395: [GC [PSYoungGen: 274931K-&gt;10738K(274944K)] 371093K-&gt;147186K(450048K), 0.0668480 secs] [Times: user=0.17 sys=0.08, real=0.07 secs]<br>2016-07-05T10:43:18.160+0800: 25.462: [Full GC [PSYoungGen: 10738K-&gt;0K(274944K)] [ParOldGen: 136447K-&gt;140379K(302592K)] 147186K-&gt;140379K(577536K) [PSPermGen: 85411K-&gt;85376K(171008K)], 0.6763541 secs] [Times: user=1.75 sys=0.02, real=0.68 secs]<br>通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数</p>\n<h4 id=\"十二-调优命令\"><a href=\"#十二-调优命令\" class=\"headerlink\" title=\"十二.调优命令\"></a>十二.调优命令</h4><p>Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo</p>\n<ol>\n<li>jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</li>\n<li>jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</li>\n<li>jmap，JVM Memory Map命令用于生成heap dump文件</li>\n<li>jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看</li>\n<li>jstack，用于生成java虚拟机当前时刻的线程快照。</li>\n<li>jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。<br>详细的命令使用参考这里JVM（4）：Jvm调优-命令篇</li>\n</ol>\n<h4 id=\"十三-调优工具\"><a href=\"#十三-调优工具\" class=\"headerlink\" title=\"十三.调优工具\"></a>十三.调优工具</h4><p>常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。</p>\n<ol>\n<li>jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控</li>\n<li>jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。</li>\n<li>MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗</li>\n<li>GChisto，一款专业分析gc日志的工具</li>\n</ol>\n","excerpt":"<h4 id=\"一-jvm体系总体分四大块：\"><a href=\"#一-jvm体系总体分四大块：\" class=\"headerlink\" title=\"一.jvm体系总体分四大块：\"></a>一.jvm体系总体分四大块：</h4><ol>\n<li>类的加载机制</li>\n<li>jvm内存结构</li>\n<li>GC算法 垃圾回收</li>\n<li>GC分析 命令调优</li></ol>","more":"对于搞开发的我们其实也是一样，现在流行的框架越来越多，封装的也越来越完善，各种框架可以搞定一切，几乎不用关注底层的实现，初级程序员只要熟悉基本的使用方法，便可以快速的开发上线；但对于高级程序员来讲，内功的修炼却越发的重要，比如算法、设计模式、底层原理等，只有把这些基础熟练之后，才能在开发过程中知其然知其所以然，出现问题时能快速定位到问题的本质。<br>对于Java程序员来讲，spring全家桶几乎可以搞定一切，spring全家桶便是精妙的招式，jvm就是内功心法很重要的一块，线上出现性能问题，jvm调优更是不可回避的问题。因此JVM基础知识对于高级程序员的重要性不必言语.\n\n<h4 id=\"二-类的加载机制\"><a href=\"#二-类的加载机制\" class=\"headerlink\" title=\"二.类的加载机制\"></a>二.类的加载机制</h4><ol>\n<li>什么是类的加载</li>\n<li>类的生命周期</li>\n<li>类加载器</li>\n<li>双亲委派模型</li>\n</ol>\n<h4 id=\"三-什么是类的加载\"><a href=\"#三-什么是类的加载\" class=\"headerlink\" title=\"三.什么是类的加载\"></a>三.什么是类的加载</h4><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p>\n<h4 id=\"四-类的生命周期\"><a href=\"#四-类的生命周期\" class=\"headerlink\" title=\"四.类的生命周期\"></a>四.类的生命周期</h4><ol>\n<li>加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象</li>\n<li>连接，连接又包含三块内容：验证、准备、初始化。1）验证，文件格式、元数据、字节码、符号引用验证；2）准备，为类的静态变量分配内存，并将其初始化为默认值；3）解析，把类中的符号引用转换为直接引用</li>\n<li>初始化，为类的静态变量赋予正确的初始值</li>\n<li>使用，new出对象程序中使用</li>\n<li>卸载，执行垃圾回收</li>\n</ol>\n<h4 id=\"五-类加载器\"><a href=\"#五-类加载器\" class=\"headerlink\" title=\"五.类加载器\"></a>五.类加载器</h4><ol>\n<li>启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\\jre\\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库</li>\n<li>扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\\jre\\lib\\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</li>\n<li>应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器</li>\n</ol>\n<h4 id=\"六-类加载机制\"><a href=\"#六-类加载机制\" class=\"headerlink\" title=\"六.类加载机制\"></a>六.类加载机制</h4><ol>\n<li>全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li>\n<li>父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li>\n<li>缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li>\n</ol>\n<h4 id=\"七-jvm内存结构\"><a href=\"#七-jvm内存结构\" class=\"headerlink\" title=\"七.jvm内存结构\"></a>七.jvm内存结构</h4><p><img src=\"http://ol5edn32j.bkt.clouddn.com/JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.jpeg\" alt=\"JVM内存分配\"></p>\n<ol>\n<li>方法区和对是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。</li>\n<li>Java堆（Heap）,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</li>\n<li>方法区（Method Area）,方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li>\n<li>程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。</li>\n<li>JVM栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>\n<li>本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</li>\n</ol>\n<h4 id=\"八-对象分配规则\"><a href=\"#八-对象分配规则\" class=\"headerlink\" title=\"八.对象分配规则\"></a>八.对象分配规则</h4><ol>\n<li>对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。</li>\n<li>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</li>\n<li>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。</li>\n<li>动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</li>\n<li>空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。</li>\n</ol>\n<h4 id=\"九-GC算法\"><a href=\"#九-GC算法\" class=\"headerlink\" title=\"九.GC算法\"></a>九.GC算法</h4><p>GC最基础的算法有三种：标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。</p>\n<ol>\n<li>标记 -清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。</li>\n<li>复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</li>\n<li>标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</li>\n<li>分代收集算法，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</li>\n</ol>\n<h4 id=\"十-垃圾回收器\"><a href=\"#十-垃圾回收器\" class=\"headerlink\" title=\"十.垃圾回收器\"></a>十.垃圾回收器</h4><ol>\n<li>Serial收集器，串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。</li>\n<li>ParNew收集器，ParNew收集器其实就是Serial收集器的多线程版本。</li>\n<li>Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。</li>\n<li>Parallel Old 收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法</li>\n<li>CMS收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</li>\n<li>G1收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征</li>\n<li>GC算法和垃圾回收器算法图解以及更详细内容参考JVM（3）：Java GC算法 垃圾收集器</li>\n</ol>\n<h4 id=\"十一-GC日志分析\"><a href=\"#十一-GC日志分析\" class=\"headerlink\" title=\"十一.GC日志分析\"></a>十一.GC日志分析</h4><p>摘录GC日志一部分（前部分为年轻代gc回收；后部分为full gc回收）：<br>2016-07-05T10:43:18.093+0800: 25.395: [GC [PSYoungGen: 274931K-&gt;10738K(274944K)] 371093K-&gt;147186K(450048K), 0.0668480 secs] [Times: user=0.17 sys=0.08, real=0.07 secs]<br>2016-07-05T10:43:18.160+0800: 25.462: [Full GC [PSYoungGen: 10738K-&gt;0K(274944K)] [ParOldGen: 136447K-&gt;140379K(302592K)] 147186K-&gt;140379K(577536K) [PSPermGen: 85411K-&gt;85376K(171008K)], 0.6763541 secs] [Times: user=1.75 sys=0.02, real=0.68 secs]<br>通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数</p>\n<h4 id=\"十二-调优命令\"><a href=\"#十二-调优命令\" class=\"headerlink\" title=\"十二.调优命令\"></a>十二.调优命令</h4><p>Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo</p>\n<ol>\n<li>jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</li>\n<li>jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</li>\n<li>jmap，JVM Memory Map命令用于生成heap dump文件</li>\n<li>jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看</li>\n<li>jstack，用于生成java虚拟机当前时刻的线程快照。</li>\n<li>jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。<br>详细的命令使用参考这里JVM（4）：Jvm调优-命令篇</li>\n</ol>\n<h4 id=\"十三-调优工具\"><a href=\"#十三-调优工具\" class=\"headerlink\" title=\"十三.调优工具\"></a>十三.调优工具</h4><p>常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。</p>\n<ol>\n<li>jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控</li>\n<li>jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。</li>\n<li>MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗</li>\n<li>GChisto，一款专业分析gc日志的工具</li>\n</ol>"},{"title":"Java编程实战知识点","date":"2017-07-21T08:23:41.000Z","toc":true,"_content":"","source":"_posts/15Java编程实战知识点.md","raw":"---\ntitle: Java编程实战知识点\ndate: 2017-07-21 16:23:41\ntags: Java\ncategories: \"Java\"\ntoc: true\n---\n","slug":"15Java编程实战知识点","published":1,"updated":"2017-07-21T08:24:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tc9t000ca7xwzscoyunn","content":"","excerpt":"","more":""},{"title":"19一些专业术语解析","date":"2017-09-15T07:32:22.000Z","toc":true,"_content":"\n1. 语法糖:语法糖就是为了避免coder出现错误并提高效率的语法层面的一种优雅的解决方案。在计算机科学中，语法糖(syntactic sugar)是指编程语言中可以更容易的表达一个操作的语法，它可以使程序员更加容易去使用这门语言：操作可以变得更加清晰、方便，或者更加符合程序员的编程习惯。\n相当于汉语里的成语,即用更简练的言语表达较复杂的含义。<!--more-->在得到广泛接受的情况之下，可以提升交流的效率。Java中的泛型，变长参数，自动拆箱/装箱，条件编译等都是。\n2.\n","source":"_posts/19一些专业术语解析.md","raw":"---\ntitle: 19一些专业术语解析\ndate: 2017-09-15 15:32:22\ntags: Java 专业术语\ncategories: \"技术\"\ntoc: true\n---\n\n1. 语法糖:语法糖就是为了避免coder出现错误并提高效率的语法层面的一种优雅的解决方案。在计算机科学中，语法糖(syntactic sugar)是指编程语言中可以更容易的表达一个操作的语法，它可以使程序员更加容易去使用这门语言：操作可以变得更加清晰、方便，或者更加符合程序员的编程习惯。\n相当于汉语里的成语,即用更简练的言语表达较复杂的含义。<!--more-->在得到广泛接受的情况之下，可以提升交流的效率。Java中的泛型，变长参数，自动拆箱/装箱，条件编译等都是。\n2.\n","slug":"19一些专业术语解析","published":1,"updated":"2017-09-18T13:26:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tc9u000ea7xwzudssshb","content":"<ol>\n<li>语法糖:语法糖就是为了避免coder出现错误并提高效率的语法层面的一种优雅的解决方案。在计算机科学中，语法糖(syntactic sugar)是指编程语言中可以更容易的表达一个操作的语法，它可以使程序员更加容易去使用这门语言：操作可以变得更加清晰、方便，或者更加符合程序员的编程习惯。<br>相当于汉语里的成语,即用更简练的言语表达较复杂的含义。<a id=\"more\"></a>在得到广泛接受的情况之下，可以提升交流的效率。Java中的泛型，变长参数，自动拆箱/装箱，条件编译等都是。<br>2.</li>\n</ol>\n","excerpt":"<ol>\n<li>语法糖:语法糖就是为了避免coder出现错误并提高效率的语法层面的一种优雅的解决方案。在计算机科学中，语法糖(syntactic sugar)是指编程语言中可以更容易的表达一个操作的语法，它可以使程序员更加容易去使用这门语言：操作可以变得更加清晰、方便，或者更加符合程序员的编程习惯。<br>相当于汉语里的成语,即用更简练的言语表达较复杂的含义。</li></ol>","more":"在得到广泛接受的情况之下，可以提升交流的效率。Java中的泛型，变长参数，自动拆箱/装箱，条件编译等都是。<br>2.\n"},{"title":"从Paxos到Zookeeper分布式一致性原理与实践","date":"2017-08-14T10:07:19.000Z","toc":true,"_content":"#### 一.分布式架构\n1. 从集中式到分布式\n2. 从ACID到CAP/BASE\n<!--more-->\n\n#### 二.一致性协议\n经典的一致性协议和算法为:两段式提交、三段式提交和PAXOS算法\n##### 1.2PC Two-Phase-Commit\n1. 绝大多数分布式数据库都是采用二段式提交协议来完成分布式协议处理的。\n2. 包括两个阶段:提交事务请求和执行事务提交\n3. 优点: 1.原理简单 2.实现方便\n4. 缺点; 1.同步阻塞 2.单点问题 3.脑裂 4.太过保守\n\n##### 2.分布式系统常见问题\n数据冗余情况下考虑数据的一致性和性能的问题。简单说来：\n1. 要想让数据有高可用性，就得写多份数据。\n2. 写多份的问题会导致数据一致性的问题。\n3. 数据一致性的问题又会引发性能问题\n\n##### 3.一致性模型、\n说起数据一致性来说，简单说有三种类型（当然，如果细分的话，还有很多一致性模型，如：顺序一致性，FIFO一致性，会话一致性，单读一致性，单写一致性，但为了本文的简单易读，我只说下面三种）：\n1. Weak 弱一致性：当你写入一个新值后，读操作在数据副本上可能读出来，也可能读不出来。比如：某些cache系统，网络游戏其它玩家的数据和你没什么关系，VOIP这样的系统，或是百度搜索引擎（呵呵）。\n2. Eventually 最终一致性：当你写入一个新值后，有可能读不出来，但在某个时间窗口之后保证最终能读出来。比如：DNS，电子邮件、Amazon S3，Google搜索引擎这样的系统。\n3. Strong 强一致性：新的数据一旦写入，在任意副本任意时刻都能读到新值。比如：文件系统，RDBMS，Azure Table都是强一致性的。\n\n具体细分:\n1. Master-Slave: 读写请求都由Master负责,写请求写到Master上后，由Master同步到Slave上。\n2. Master-Master: Master-Master，又叫Multi-master，是指一个系统存在两个或多个Master，每个Master都提供read-write服务。这个模型是Master-Slave的加强版，数据间同步一般是通过Master间的异步完成，所以是最终一致性。\n3. Two/Three Phase Commit:\n2PC:\n第一阶段：\n协调者会问所有的参与者结点，是否可以执行提交操作。\n各个参与者开始事务执行的准备工作：如：为资源上锁，预留资源，写undo/redo log……\n参与者响应协调者，如果事务的准备工作成功，则回应“可以提交”，否则回应“拒绝提交”。\n第二阶段：\n如果所有的参与者都回应“可以提交”，那么，协调者向所有的参与者发送“正式提交”的命令。参与者完成正式提交，并释放所有资源，然后回应“完成”，协调者收集各结点的“完成”回应后结束这个Global Transaction。\n如果有一个参与者回应“拒绝提交”，那么，协调者向所有的参与者发送“回滚操作”，并释放所有资源，然后回应“回滚完成”，协调者收集各结点的“回滚”回应后，取消这个Global Transaction。\n2PC存在问题:\n1）如果第一阶段中，参与者没有收到询问请求，或是参与者的回应没有到达协调者。那么，需要协调者做超时处理，一旦超时，可以当作失败，也可以重试。\n2）如果第二阶段中，正式提交发出后，如果有的参与者没有收到，或是参与者提交/回滚后的确认信息没有返回，一旦参与者的回应超时，要么重试，要么把那个参与者标记为问题结点剔除整个集群，这样可以保证服务结点都是数据一致性的。\n3）糟糕的情况是，第二阶段中，如果参与者收不到协调者的commit/fallback指令，参与者将处于“状态未知”阶段，参与者完全不知道要怎么办，比如：如果所有的参与者完成第一阶段的回复后（可能全部yes，可能全部no，可能部分yes部分no），如果协调者在这个时候挂掉了。那么所有的结点完全不知道怎么办（问别的参与者都不行）。为了一致性，要么死等协调者，要么重发第一阶段的yes/no命令。\n为了解决第三种问题,单点问题,发明了3PC:\n4. Two Generals Problem（两将军问题）: 试图通过建立在一个不可靠的连接上的交流来协调一项行动的隐患和设计上的巨大挑战。\n5. 拜占庭将军问题 (Byzantine Generals Problem):\n6. Paxos算法: Paxos 算法解决的问题是在一个可能发生上述异常的分布式系统中如何就某个值达成一致，保证不论发生以上任何异常，都不会破坏决议的一致性。Paxos的目的是让整个集群的结点对某个值的变更达成一致。\n","source":"_posts/18从Paxos到Zookeeper分布式一致性原理与实践.md","raw":"---\ntitle: 从Paxos到Zookeeper分布式一致性原理与实践\ndate: 2017-08-14 18:07:19\ntags: Java Paxos Zookeeper\ncategories: \"分布式\"\ntoc: true\n---\n#### 一.分布式架构\n1. 从集中式到分布式\n2. 从ACID到CAP/BASE\n<!--more-->\n\n#### 二.一致性协议\n经典的一致性协议和算法为:两段式提交、三段式提交和PAXOS算法\n##### 1.2PC Two-Phase-Commit\n1. 绝大多数分布式数据库都是采用二段式提交协议来完成分布式协议处理的。\n2. 包括两个阶段:提交事务请求和执行事务提交\n3. 优点: 1.原理简单 2.实现方便\n4. 缺点; 1.同步阻塞 2.单点问题 3.脑裂 4.太过保守\n\n##### 2.分布式系统常见问题\n数据冗余情况下考虑数据的一致性和性能的问题。简单说来：\n1. 要想让数据有高可用性，就得写多份数据。\n2. 写多份的问题会导致数据一致性的问题。\n3. 数据一致性的问题又会引发性能问题\n\n##### 3.一致性模型、\n说起数据一致性来说，简单说有三种类型（当然，如果细分的话，还有很多一致性模型，如：顺序一致性，FIFO一致性，会话一致性，单读一致性，单写一致性，但为了本文的简单易读，我只说下面三种）：\n1. Weak 弱一致性：当你写入一个新值后，读操作在数据副本上可能读出来，也可能读不出来。比如：某些cache系统，网络游戏其它玩家的数据和你没什么关系，VOIP这样的系统，或是百度搜索引擎（呵呵）。\n2. Eventually 最终一致性：当你写入一个新值后，有可能读不出来，但在某个时间窗口之后保证最终能读出来。比如：DNS，电子邮件、Amazon S3，Google搜索引擎这样的系统。\n3. Strong 强一致性：新的数据一旦写入，在任意副本任意时刻都能读到新值。比如：文件系统，RDBMS，Azure Table都是强一致性的。\n\n具体细分:\n1. Master-Slave: 读写请求都由Master负责,写请求写到Master上后，由Master同步到Slave上。\n2. Master-Master: Master-Master，又叫Multi-master，是指一个系统存在两个或多个Master，每个Master都提供read-write服务。这个模型是Master-Slave的加强版，数据间同步一般是通过Master间的异步完成，所以是最终一致性。\n3. Two/Three Phase Commit:\n2PC:\n第一阶段：\n协调者会问所有的参与者结点，是否可以执行提交操作。\n各个参与者开始事务执行的准备工作：如：为资源上锁，预留资源，写undo/redo log……\n参与者响应协调者，如果事务的准备工作成功，则回应“可以提交”，否则回应“拒绝提交”。\n第二阶段：\n如果所有的参与者都回应“可以提交”，那么，协调者向所有的参与者发送“正式提交”的命令。参与者完成正式提交，并释放所有资源，然后回应“完成”，协调者收集各结点的“完成”回应后结束这个Global Transaction。\n如果有一个参与者回应“拒绝提交”，那么，协调者向所有的参与者发送“回滚操作”，并释放所有资源，然后回应“回滚完成”，协调者收集各结点的“回滚”回应后，取消这个Global Transaction。\n2PC存在问题:\n1）如果第一阶段中，参与者没有收到询问请求，或是参与者的回应没有到达协调者。那么，需要协调者做超时处理，一旦超时，可以当作失败，也可以重试。\n2）如果第二阶段中，正式提交发出后，如果有的参与者没有收到，或是参与者提交/回滚后的确认信息没有返回，一旦参与者的回应超时，要么重试，要么把那个参与者标记为问题结点剔除整个集群，这样可以保证服务结点都是数据一致性的。\n3）糟糕的情况是，第二阶段中，如果参与者收不到协调者的commit/fallback指令，参与者将处于“状态未知”阶段，参与者完全不知道要怎么办，比如：如果所有的参与者完成第一阶段的回复后（可能全部yes，可能全部no，可能部分yes部分no），如果协调者在这个时候挂掉了。那么所有的结点完全不知道怎么办（问别的参与者都不行）。为了一致性，要么死等协调者，要么重发第一阶段的yes/no命令。\n为了解决第三种问题,单点问题,发明了3PC:\n4. Two Generals Problem（两将军问题）: 试图通过建立在一个不可靠的连接上的交流来协调一项行动的隐患和设计上的巨大挑战。\n5. 拜占庭将军问题 (Byzantine Generals Problem):\n6. Paxos算法: Paxos 算法解决的问题是在一个可能发生上述异常的分布式系统中如何就某个值达成一致，保证不论发生以上任何异常，都不会破坏决议的一致性。Paxos的目的是让整个集群的结点对某个值的变更达成一致。\n","slug":"18从Paxos到Zookeeper分布式一致性原理与实践","published":1,"updated":"2017-09-18T13:04:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tc9w000ia7xw44nw0agx","content":"<h4 id=\"一-分布式架构\"><a href=\"#一-分布式架构\" class=\"headerlink\" title=\"一.分布式架构\"></a>一.分布式架构</h4><ol>\n<li>从集中式到分布式</li>\n<li>从ACID到CAP/BASE<a id=\"more\"></a>\n</li>\n</ol>\n<h4 id=\"二-一致性协议\"><a href=\"#二-一致性协议\" class=\"headerlink\" title=\"二.一致性协议\"></a>二.一致性协议</h4><p>经典的一致性协议和算法为:两段式提交、三段式提交和PAXOS算法</p>\n<h5 id=\"1-2PC-Two-Phase-Commit\"><a href=\"#1-2PC-Two-Phase-Commit\" class=\"headerlink\" title=\"1.2PC Two-Phase-Commit\"></a>1.2PC Two-Phase-Commit</h5><ol>\n<li>绝大多数分布式数据库都是采用二段式提交协议来完成分布式协议处理的。</li>\n<li>包括两个阶段:提交事务请求和执行事务提交</li>\n<li>优点: 1.原理简单 2.实现方便</li>\n<li>缺点; 1.同步阻塞 2.单点问题 3.脑裂 4.太过保守</li>\n</ol>\n<h5 id=\"2-分布式系统常见问题\"><a href=\"#2-分布式系统常见问题\" class=\"headerlink\" title=\"2.分布式系统常见问题\"></a>2.分布式系统常见问题</h5><p>数据冗余情况下考虑数据的一致性和性能的问题。简单说来：</p>\n<ol>\n<li>要想让数据有高可用性，就得写多份数据。</li>\n<li>写多份的问题会导致数据一致性的问题。</li>\n<li>数据一致性的问题又会引发性能问题</li>\n</ol>\n<h5 id=\"3-一致性模型、\"><a href=\"#3-一致性模型、\" class=\"headerlink\" title=\"3.一致性模型、\"></a>3.一致性模型、</h5><p>说起数据一致性来说，简单说有三种类型（当然，如果细分的话，还有很多一致性模型，如：顺序一致性，FIFO一致性，会话一致性，单读一致性，单写一致性，但为了本文的简单易读，我只说下面三种）：</p>\n<ol>\n<li>Weak 弱一致性：当你写入一个新值后，读操作在数据副本上可能读出来，也可能读不出来。比如：某些cache系统，网络游戏其它玩家的数据和你没什么关系，VOIP这样的系统，或是百度搜索引擎（呵呵）。</li>\n<li>Eventually 最终一致性：当你写入一个新值后，有可能读不出来，但在某个时间窗口之后保证最终能读出来。比如：DNS，电子邮件、Amazon S3，Google搜索引擎这样的系统。</li>\n<li>Strong 强一致性：新的数据一旦写入，在任意副本任意时刻都能读到新值。比如：文件系统，RDBMS，Azure Table都是强一致性的。</li>\n</ol>\n<p>具体细分:</p>\n<ol>\n<li>Master-Slave: 读写请求都由Master负责,写请求写到Master上后，由Master同步到Slave上。</li>\n<li>Master-Master: Master-Master，又叫Multi-master，是指一个系统存在两个或多个Master，每个Master都提供read-write服务。这个模型是Master-Slave的加强版，数据间同步一般是通过Master间的异步完成，所以是最终一致性。</li>\n<li>Two/Three Phase Commit:<br>2PC:<br>第一阶段：<br>协调者会问所有的参与者结点，是否可以执行提交操作。<br>各个参与者开始事务执行的准备工作：如：为资源上锁，预留资源，写undo/redo log……<br>参与者响应协调者，如果事务的准备工作成功，则回应“可以提交”，否则回应“拒绝提交”。<br>第二阶段：<br>如果所有的参与者都回应“可以提交”，那么，协调者向所有的参与者发送“正式提交”的命令。参与者完成正式提交，并释放所有资源，然后回应“完成”，协调者收集各结点的“完成”回应后结束这个Global Transaction。<br>如果有一个参与者回应“拒绝提交”，那么，协调者向所有的参与者发送“回滚操作”，并释放所有资源，然后回应“回滚完成”，协调者收集各结点的“回滚”回应后，取消这个Global Transaction。<br>2PC存在问题:<br>1）如果第一阶段中，参与者没有收到询问请求，或是参与者的回应没有到达协调者。那么，需要协调者做超时处理，一旦超时，可以当作失败，也可以重试。<br>2）如果第二阶段中，正式提交发出后，如果有的参与者没有收到，或是参与者提交/回滚后的确认信息没有返回，一旦参与者的回应超时，要么重试，要么把那个参与者标记为问题结点剔除整个集群，这样可以保证服务结点都是数据一致性的。<br>3）糟糕的情况是，第二阶段中，如果参与者收不到协调者的commit/fallback指令，参与者将处于“状态未知”阶段，参与者完全不知道要怎么办，比如：如果所有的参与者完成第一阶段的回复后（可能全部yes，可能全部no，可能部分yes部分no），如果协调者在这个时候挂掉了。那么所有的结点完全不知道怎么办（问别的参与者都不行）。为了一致性，要么死等协调者，要么重发第一阶段的yes/no命令。<br>为了解决第三种问题,单点问题,发明了3PC:</li>\n<li>Two Generals Problem（两将军问题）: 试图通过建立在一个不可靠的连接上的交流来协调一项行动的隐患和设计上的巨大挑战。</li>\n<li>拜占庭将军问题 (Byzantine Generals Problem):</li>\n<li>Paxos算法: Paxos 算法解决的问题是在一个可能发生上述异常的分布式系统中如何就某个值达成一致，保证不论发生以上任何异常，都不会破坏决议的一致性。Paxos的目的是让整个集群的结点对某个值的变更达成一致。</li>\n</ol>\n","excerpt":"<h4 id=\"一-分布式架构\"><a href=\"#一-分布式架构\" class=\"headerlink\" title=\"一.分布式架构\"></a>一.分布式架构</h4><ol>\n<li>从集中式到分布式</li>\n<li>从ACID到CAP/BASE</li></ol>","more":"\n\n<h4 id=\"二-一致性协议\"><a href=\"#二-一致性协议\" class=\"headerlink\" title=\"二.一致性协议\"></a>二.一致性协议</h4><p>经典的一致性协议和算法为:两段式提交、三段式提交和PAXOS算法</p>\n<h5 id=\"1-2PC-Two-Phase-Commit\"><a href=\"#1-2PC-Two-Phase-Commit\" class=\"headerlink\" title=\"1.2PC Two-Phase-Commit\"></a>1.2PC Two-Phase-Commit</h5><ol>\n<li>绝大多数分布式数据库都是采用二段式提交协议来完成分布式协议处理的。</li>\n<li>包括两个阶段:提交事务请求和执行事务提交</li>\n<li>优点: 1.原理简单 2.实现方便</li>\n<li>缺点; 1.同步阻塞 2.单点问题 3.脑裂 4.太过保守</li>\n</ol>\n<h5 id=\"2-分布式系统常见问题\"><a href=\"#2-分布式系统常见问题\" class=\"headerlink\" title=\"2.分布式系统常见问题\"></a>2.分布式系统常见问题</h5><p>数据冗余情况下考虑数据的一致性和性能的问题。简单说来：</p>\n<ol>\n<li>要想让数据有高可用性，就得写多份数据。</li>\n<li>写多份的问题会导致数据一致性的问题。</li>\n<li>数据一致性的问题又会引发性能问题</li>\n</ol>\n<h5 id=\"3-一致性模型、\"><a href=\"#3-一致性模型、\" class=\"headerlink\" title=\"3.一致性模型、\"></a>3.一致性模型、</h5><p>说起数据一致性来说，简单说有三种类型（当然，如果细分的话，还有很多一致性模型，如：顺序一致性，FIFO一致性，会话一致性，单读一致性，单写一致性，但为了本文的简单易读，我只说下面三种）：</p>\n<ol>\n<li>Weak 弱一致性：当你写入一个新值后，读操作在数据副本上可能读出来，也可能读不出来。比如：某些cache系统，网络游戏其它玩家的数据和你没什么关系，VOIP这样的系统，或是百度搜索引擎（呵呵）。</li>\n<li>Eventually 最终一致性：当你写入一个新值后，有可能读不出来，但在某个时间窗口之后保证最终能读出来。比如：DNS，电子邮件、Amazon S3，Google搜索引擎这样的系统。</li>\n<li>Strong 强一致性：新的数据一旦写入，在任意副本任意时刻都能读到新值。比如：文件系统，RDBMS，Azure Table都是强一致性的。</li>\n</ol>\n<p>具体细分:</p>\n<ol>\n<li>Master-Slave: 读写请求都由Master负责,写请求写到Master上后，由Master同步到Slave上。</li>\n<li>Master-Master: Master-Master，又叫Multi-master，是指一个系统存在两个或多个Master，每个Master都提供read-write服务。这个模型是Master-Slave的加强版，数据间同步一般是通过Master间的异步完成，所以是最终一致性。</li>\n<li>Two/Three Phase Commit:<br>2PC:<br>第一阶段：<br>协调者会问所有的参与者结点，是否可以执行提交操作。<br>各个参与者开始事务执行的准备工作：如：为资源上锁，预留资源，写undo/redo log……<br>参与者响应协调者，如果事务的准备工作成功，则回应“可以提交”，否则回应“拒绝提交”。<br>第二阶段：<br>如果所有的参与者都回应“可以提交”，那么，协调者向所有的参与者发送“正式提交”的命令。参与者完成正式提交，并释放所有资源，然后回应“完成”，协调者收集各结点的“完成”回应后结束这个Global Transaction。<br>如果有一个参与者回应“拒绝提交”，那么，协调者向所有的参与者发送“回滚操作”，并释放所有资源，然后回应“回滚完成”，协调者收集各结点的“回滚”回应后，取消这个Global Transaction。<br>2PC存在问题:<br>1）如果第一阶段中，参与者没有收到询问请求，或是参与者的回应没有到达协调者。那么，需要协调者做超时处理，一旦超时，可以当作失败，也可以重试。<br>2）如果第二阶段中，正式提交发出后，如果有的参与者没有收到，或是参与者提交/回滚后的确认信息没有返回，一旦参与者的回应超时，要么重试，要么把那个参与者标记为问题结点剔除整个集群，这样可以保证服务结点都是数据一致性的。<br>3）糟糕的情况是，第二阶段中，如果参与者收不到协调者的commit/fallback指令，参与者将处于“状态未知”阶段，参与者完全不知道要怎么办，比如：如果所有的参与者完成第一阶段的回复后（可能全部yes，可能全部no，可能部分yes部分no），如果协调者在这个时候挂掉了。那么所有的结点完全不知道怎么办（问别的参与者都不行）。为了一致性，要么死等协调者，要么重发第一阶段的yes/no命令。<br>为了解决第三种问题,单点问题,发明了3PC:</li>\n<li>Two Generals Problem（两将军问题）: 试图通过建立在一个不可靠的连接上的交流来协调一项行动的隐患和设计上的巨大挑战。</li>\n<li>拜占庭将军问题 (Byzantine Generals Problem):</li>\n<li>Paxos算法: Paxos 算法解决的问题是在一个可能发生上述异常的分布式系统中如何就某个值达成一致，保证不论发生以上任何异常，都不会破坏决议的一致性。Paxos的目的是让整个集群的结点对某个值的变更达成一致。</li>\n</ol>"},{"title":"String-StringBuffer-StringBuilder性能对比","date":"2017-07-21T11:42:56.000Z","toc":true,"_content":"String-StringBuffer-StringBuilder性能对比,以及常见的几道面试题。\n<!--more-->\n```\npackage com.meng.Jason.standard;\n\n/**\n * Created by MengDexin.\n * Date : 17/7/21.\n * Time : 17:51.\n */\npublic class StringTest {\n    private static int time = 50000;\n\n    public static void main(String[] args) {\n        testString();\n        testStringBuffer();\n        testStringBuilder();\n        test1String();\n        test2String();\n    }\n\n    public static void testString() {\n        String s = \"\";\n        long begin = System.currentTimeMillis();\n        for (int i = 0; i < time; i++) {\n            s += \"java\";\n        }\n        long over = System.currentTimeMillis();\n        System.out.println(\"操作\" + s.getClass().getName() + \"类型使用的时间为：\" + (over - begin) + \"毫秒\");\n    }\n\n    public static void testStringBuffer() {\n        StringBuffer sb = new StringBuffer();\n        long begin = System.currentTimeMillis();\n        for (int i = 0; i < time; i++) {\n            sb.append(\"java\");\n        }\n        long over = System.currentTimeMillis();\n        System.out.println(\"操作\" + sb.getClass().getName() + \"类型使用的时间为：\" + (over - begin) + \"毫秒\");\n    }\n\n    public static void testStringBuilder() {\n        StringBuilder sb = new StringBuilder();\n        long begin = System.currentTimeMillis();\n        for (int i = 0; i < time; i++) {\n            sb.append(\"java\");\n        }\n        long over = System.currentTimeMillis();\n        System.out.println(\"操作\" + sb.getClass().getName() + \"类型使用的时间为：\" + (over - begin) + \"毫秒\");\n    }\n\n    public static void test1String() {\n        long begin = System.currentTimeMillis();\n        for (int i = 0; i < time; i++) {\n            String s = \"I\" + \"love\" + \"java\";\n        }\n        long over = System.currentTimeMillis();\n        System.out.println(\"字符串直接相加操作：\" + (over - begin) + \"毫秒\");\n    }\n\n    public static void test2String() {\n        String s1 = \"I\";\n        String s2 = \"love\";\n        String s3 = \"java\";\n        long begin = System.currentTimeMillis();\n        for (int i = 0; i < time; i++) {\n            String s = s1 + s2 + s3;\n        }\n        long over = System.currentTimeMillis();\n        System.out.println(\"字符串间接相加操作：\" + (over - begin) + \"毫秒\");\n    }\n}\n```\n结果\n```\n操作java.lang.String类型使用的时间为：2457毫秒\n操作java.lang.StringBuffer类型使用的时间为：6毫秒\n操作java.lang.StringBuilder类型使用的时间为：2毫秒\n字符串直接相加操作：1毫秒\n字符串间接相加操作：7毫秒\n```\n分析:\n1. 对于直接相加字符串，效率很高，因为在编译器便确定了它的值，也就是说形如\"I\"+\"love\"+\"java\"; 的字符串相加，在编译期间便被优化成了\"Ilovejava\"。这个可以用javap -c命令反编译生成的class文件进行验证。\n2. String、StringBuilder、StringBuffer三者的执行效率：\n　　StringBuilder(线程不安全的) > StringBuffer(线程安全的) > String\n　　当然这个是相对的，不一定在所有情况下都是这样。\n　　比如String str = \"hello\"+ \"world\"的效率就比 StringBuilder st  = new StringBuilder().append(\"hello\").append(\"world\")要高。\n　　因此，这三个类是各有利弊，应当根据不同的情况来进行选择使用：\n　　当字符串相加操作或者改动较少的情况下，建议使用 String str=\"hello\"这种形式；\n　　当字符串相加操作较多的情况下，建议使用StringBuilder，如果采用了多线程，则使用StringBuffer。\n1. 下面这段代码的输出结果是什么？\n　　String a = \"hello2\"; 　　String b = \"hello\" + 2; 　　System.out.println((a == b));\n　　输出结果为：true。原因很简单，\"hello\"+2在编译期间就已经被优化成\"hello2\"，因此在运行期间，变量a和变量b指向的是同一个对象。\n2. 下面这段代码的输出结果是什么？\n　　String a = \"hello2\"; 　  String b = \"hello\";       String c = b + 2;       System.out.println((a == c));\n　　输出结果为:false。由于有符号引用的存在，所以  String c = b + 2;不会在编译期间被优化，不会把b+2当做字面常量来处理的，因此这种方式生成的对象事实上是保存在堆上的。因此a和c指向的并不是同一个对象。\n3. 下面这段代码的输出结果是什么？\n　　String a = \"hello2\";   　 final String b = \"hello\";       String c = b + 2;       System.out.println((a == c));\n　　输出结果为：true。对于被final修饰的变量，会在class文件常量池中保存一个副本，也就是说不会通过连接而进行访问，对final变量的访问在编译期间都会直接被替代为真实的值。那么String c = b + 2;在编译期间就会被优化成：String c = \"hello\" + 2;\n4. 请别再拿“String s = new String(\"xyz\");创建了多少个String实例”来面试了吧 http://rednaxelafx.iteye.com/blog/774673/\n\n\n\n\n\n","source":"_posts/16String-StringBuffer-StringBuilder性能对比.md","raw":"---\ntitle: String-StringBuffer-StringBuilder性能对比\ndate: 2017-07-21 19:42:56\ntags: Java\ncategories: \"Java\"\ntoc: true\n---\nString-StringBuffer-StringBuilder性能对比,以及常见的几道面试题。\n<!--more-->\n```\npackage com.meng.Jason.standard;\n\n/**\n * Created by MengDexin.\n * Date : 17/7/21.\n * Time : 17:51.\n */\npublic class StringTest {\n    private static int time = 50000;\n\n    public static void main(String[] args) {\n        testString();\n        testStringBuffer();\n        testStringBuilder();\n        test1String();\n        test2String();\n    }\n\n    public static void testString() {\n        String s = \"\";\n        long begin = System.currentTimeMillis();\n        for (int i = 0; i < time; i++) {\n            s += \"java\";\n        }\n        long over = System.currentTimeMillis();\n        System.out.println(\"操作\" + s.getClass().getName() + \"类型使用的时间为：\" + (over - begin) + \"毫秒\");\n    }\n\n    public static void testStringBuffer() {\n        StringBuffer sb = new StringBuffer();\n        long begin = System.currentTimeMillis();\n        for (int i = 0; i < time; i++) {\n            sb.append(\"java\");\n        }\n        long over = System.currentTimeMillis();\n        System.out.println(\"操作\" + sb.getClass().getName() + \"类型使用的时间为：\" + (over - begin) + \"毫秒\");\n    }\n\n    public static void testStringBuilder() {\n        StringBuilder sb = new StringBuilder();\n        long begin = System.currentTimeMillis();\n        for (int i = 0; i < time; i++) {\n            sb.append(\"java\");\n        }\n        long over = System.currentTimeMillis();\n        System.out.println(\"操作\" + sb.getClass().getName() + \"类型使用的时间为：\" + (over - begin) + \"毫秒\");\n    }\n\n    public static void test1String() {\n        long begin = System.currentTimeMillis();\n        for (int i = 0; i < time; i++) {\n            String s = \"I\" + \"love\" + \"java\";\n        }\n        long over = System.currentTimeMillis();\n        System.out.println(\"字符串直接相加操作：\" + (over - begin) + \"毫秒\");\n    }\n\n    public static void test2String() {\n        String s1 = \"I\";\n        String s2 = \"love\";\n        String s3 = \"java\";\n        long begin = System.currentTimeMillis();\n        for (int i = 0; i < time; i++) {\n            String s = s1 + s2 + s3;\n        }\n        long over = System.currentTimeMillis();\n        System.out.println(\"字符串间接相加操作：\" + (over - begin) + \"毫秒\");\n    }\n}\n```\n结果\n```\n操作java.lang.String类型使用的时间为：2457毫秒\n操作java.lang.StringBuffer类型使用的时间为：6毫秒\n操作java.lang.StringBuilder类型使用的时间为：2毫秒\n字符串直接相加操作：1毫秒\n字符串间接相加操作：7毫秒\n```\n分析:\n1. 对于直接相加字符串，效率很高，因为在编译器便确定了它的值，也就是说形如\"I\"+\"love\"+\"java\"; 的字符串相加，在编译期间便被优化成了\"Ilovejava\"。这个可以用javap -c命令反编译生成的class文件进行验证。\n2. String、StringBuilder、StringBuffer三者的执行效率：\n　　StringBuilder(线程不安全的) > StringBuffer(线程安全的) > String\n　　当然这个是相对的，不一定在所有情况下都是这样。\n　　比如String str = \"hello\"+ \"world\"的效率就比 StringBuilder st  = new StringBuilder().append(\"hello\").append(\"world\")要高。\n　　因此，这三个类是各有利弊，应当根据不同的情况来进行选择使用：\n　　当字符串相加操作或者改动较少的情况下，建议使用 String str=\"hello\"这种形式；\n　　当字符串相加操作较多的情况下，建议使用StringBuilder，如果采用了多线程，则使用StringBuffer。\n1. 下面这段代码的输出结果是什么？\n　　String a = \"hello2\"; 　　String b = \"hello\" + 2; 　　System.out.println((a == b));\n　　输出结果为：true。原因很简单，\"hello\"+2在编译期间就已经被优化成\"hello2\"，因此在运行期间，变量a和变量b指向的是同一个对象。\n2. 下面这段代码的输出结果是什么？\n　　String a = \"hello2\"; 　  String b = \"hello\";       String c = b + 2;       System.out.println((a == c));\n　　输出结果为:false。由于有符号引用的存在，所以  String c = b + 2;不会在编译期间被优化，不会把b+2当做字面常量来处理的，因此这种方式生成的对象事实上是保存在堆上的。因此a和c指向的并不是同一个对象。\n3. 下面这段代码的输出结果是什么？\n　　String a = \"hello2\";   　 final String b = \"hello\";       String c = b + 2;       System.out.println((a == c));\n　　输出结果为：true。对于被final修饰的变量，会在class文件常量池中保存一个副本，也就是说不会通过连接而进行访问，对final变量的访问在编译期间都会直接被替代为真实的值。那么String c = b + 2;在编译期间就会被优化成：String c = \"hello\" + 2;\n4. 请别再拿“String s = new String(\"xyz\");创建了多少个String实例”来面试了吧 http://rednaxelafx.iteye.com/blog/774673/\n\n\n\n\n\n","slug":"16String-StringBuffer-StringBuilder性能对比","published":1,"updated":"2017-07-21T11:54:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tc9y000la7xwvibqcd8x","content":"<p>String-StringBuffer-StringBuilder性能对比,以及常见的几道面试题。<br><a id=\"more\"></a><br><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.meng.Jason.standard;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Created by MengDexin.</div><div class=\"line\"> * Date : 17/7/21.</div><div class=\"line\"> * Time : 17:51.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> StringTest &#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> time = <span class=\"number\">50000</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(<span class=\"keyword\">String</span>[] args) &#123;</div><div class=\"line\">        testString();</div><div class=\"line\">        testStringBuffer();</div><div class=\"line\">        testStringBuilder();</div><div class=\"line\">        test1String();</div><div class=\"line\">        test2String();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> testString() &#123;</div><div class=\"line\">        <span class=\"keyword\">String</span> s = <span class=\"string\">\"\"</span>;</div><div class=\"line\">        <span class=\"keyword\">long</span> <span class=\"built_in\">begin</span> = System.currentTimeMillis();</div><div class=\"line\">        <span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; time; i++) &#123;</div><div class=\"line\">            s += <span class=\"string\">\"java\"</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">long</span> over = System.currentTimeMillis();</div><div class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"操作\"</span> + s.getClass().getName() + <span class=\"string\">\"类型使用的时间为：\"</span> + (over - <span class=\"built_in\">begin</span>) + <span class=\"string\">\"毫秒\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> testStringBuffer() &#123;</div><div class=\"line\">        StringBuffer sb = <span class=\"keyword\">new</span> StringBuffer();</div><div class=\"line\">        <span class=\"keyword\">long</span> <span class=\"built_in\">begin</span> = System.currentTimeMillis();</div><div class=\"line\">        <span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; time; i++) &#123;</div><div class=\"line\">            sb.append(<span class=\"string\">\"java\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">long</span> over = System.currentTimeMillis();</div><div class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"操作\"</span> + sb.getClass().getName() + <span class=\"string\">\"类型使用的时间为：\"</span> + (over - <span class=\"built_in\">begin</span>) + <span class=\"string\">\"毫秒\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> testStringBuilder() &#123;</div><div class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\">        <span class=\"keyword\">long</span> <span class=\"built_in\">begin</span> = System.currentTimeMillis();</div><div class=\"line\">        <span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; time; i++) &#123;</div><div class=\"line\">            sb.append(<span class=\"string\">\"java\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">long</span> over = System.currentTimeMillis();</div><div class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"操作\"</span> + sb.getClass().getName() + <span class=\"string\">\"类型使用的时间为：\"</span> + (over - <span class=\"built_in\">begin</span>) + <span class=\"string\">\"毫秒\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> test1String() &#123;</div><div class=\"line\">        <span class=\"keyword\">long</span> <span class=\"built_in\">begin</span> = System.currentTimeMillis();</div><div class=\"line\">        <span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; time; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">String</span> s = <span class=\"string\">\"I\"</span> + <span class=\"string\">\"love\"</span> + <span class=\"string\">\"java\"</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">long</span> over = System.currentTimeMillis();</div><div class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"字符串直接相加操作：\"</span> + (over - <span class=\"built_in\">begin</span>) + <span class=\"string\">\"毫秒\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> test2String() &#123;</div><div class=\"line\">        <span class=\"keyword\">String</span> s1 = <span class=\"string\">\"I\"</span>;</div><div class=\"line\">        <span class=\"keyword\">String</span> s2 = <span class=\"string\">\"love\"</span>;</div><div class=\"line\">        <span class=\"keyword\">String</span> s3 = <span class=\"string\">\"java\"</span>;</div><div class=\"line\">        <span class=\"keyword\">long</span> <span class=\"built_in\">begin</span> = System.currentTimeMillis();</div><div class=\"line\">        <span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; time; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">String</span> s = s1 + s2 + s3;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">long</span> over = System.currentTimeMillis();</div><div class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"字符串间接相加操作：\"</span> + (over - <span class=\"built_in\">begin</span>) + <span class=\"string\">\"毫秒\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>结果<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">操作java<span class=\"selector-class\">.lang</span><span class=\"selector-class\">.String</span>类型使用的时间为：<span class=\"number\">2457</span>毫秒</div><div class=\"line\">操作java<span class=\"selector-class\">.lang</span><span class=\"selector-class\">.StringBuffer</span>类型使用的时间为：<span class=\"number\">6</span>毫秒</div><div class=\"line\">操作java<span class=\"selector-class\">.lang</span><span class=\"selector-class\">.StringBuilder</span>类型使用的时间为：<span class=\"number\">2</span>毫秒</div><div class=\"line\">字符串直接相加操作：<span class=\"number\">1</span>毫秒</div><div class=\"line\">字符串间接相加操作：<span class=\"number\">7</span>毫秒</div></pre></td></tr></table></figure></p>\n<p>分析:</p>\n<ol>\n<li>对于直接相加字符串，效率很高，因为在编译器便确定了它的值，也就是说形如”I”+”love”+”java”; 的字符串相加，在编译期间便被优化成了”Ilovejava”。这个可以用javap -c命令反编译生成的class文件进行验证。</li>\n<li>String、StringBuilder、StringBuffer三者的执行效率：<br>　　StringBuilder(线程不安全的) &gt; StringBuffer(线程安全的) &gt; String<br>　　当然这个是相对的，不一定在所有情况下都是这样。<br>　　比如String str = “hello”+ “world”的效率就比 StringBuilder st  = new StringBuilder().append(“hello”).append(“world”)要高。<br>　　因此，这三个类是各有利弊，应当根据不同的情况来进行选择使用：<br>　　当字符串相加操作或者改动较少的情况下，建议使用 String str=”hello”这种形式；<br>　　当字符串相加操作较多的情况下，建议使用StringBuilder，如果采用了多线程，则使用StringBuffer。</li>\n<li>下面这段代码的输出结果是什么？<br>　　String a = “hello2”; 　　String b = “hello” + 2; 　　System.out.println((a == b));<br>　　输出结果为：true。原因很简单，”hello”+2在编译期间就已经被优化成”hello2”，因此在运行期间，变量a和变量b指向的是同一个对象。</li>\n<li>下面这段代码的输出结果是什么？<br>　　String a = “hello2”; 　  String b = “hello”;       String c = b + 2;       System.out.println((a == c));<br>　　输出结果为:false。由于有符号引用的存在，所以  String c = b + 2;不会在编译期间被优化，不会把b+2当做字面常量来处理的，因此这种方式生成的对象事实上是保存在堆上的。因此a和c指向的并不是同一个对象。</li>\n<li>下面这段代码的输出结果是什么？<br>　　String a = “hello2”;   　 final String b = “hello”;       String c = b + 2;       System.out.println((a == c));<br>　　输出结果为：true。对于被final修饰的变量，会在class文件常量池中保存一个副本，也就是说不会通过连接而进行访问，对final变量的访问在编译期间都会直接被替代为真实的值。那么String c = b + 2;在编译期间就会被优化成：String c = “hello” + 2;</li>\n<li>请别再拿“String s = new String(“xyz”);创建了多少个String实例”来面试了吧 <a href=\"http://rednaxelafx.iteye.com/blog/774673/\" target=\"_blank\" rel=\"external\">http://rednaxelafx.iteye.com/blog/774673/</a></li>\n</ol>\n","excerpt":"<p>String-StringBuffer-StringBuilder性能对比,以及常见的几道面试题。<br></p>","more":"<br><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.meng.Jason.standard;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Created by MengDexin.</div><div class=\"line\"> * Date : 17/7/21.</div><div class=\"line\"> * Time : 17:51.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> StringTest &#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> time = <span class=\"number\">50000</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(<span class=\"keyword\">String</span>[] args) &#123;</div><div class=\"line\">        testString();</div><div class=\"line\">        testStringBuffer();</div><div class=\"line\">        testStringBuilder();</div><div class=\"line\">        test1String();</div><div class=\"line\">        test2String();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> testString() &#123;</div><div class=\"line\">        <span class=\"keyword\">String</span> s = <span class=\"string\">\"\"</span>;</div><div class=\"line\">        <span class=\"keyword\">long</span> <span class=\"built_in\">begin</span> = System.currentTimeMillis();</div><div class=\"line\">        <span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; time; i++) &#123;</div><div class=\"line\">            s += <span class=\"string\">\"java\"</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">long</span> over = System.currentTimeMillis();</div><div class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"操作\"</span> + s.getClass().getName() + <span class=\"string\">\"类型使用的时间为：\"</span> + (over - <span class=\"built_in\">begin</span>) + <span class=\"string\">\"毫秒\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> testStringBuffer() &#123;</div><div class=\"line\">        StringBuffer sb = <span class=\"keyword\">new</span> StringBuffer();</div><div class=\"line\">        <span class=\"keyword\">long</span> <span class=\"built_in\">begin</span> = System.currentTimeMillis();</div><div class=\"line\">        <span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; time; i++) &#123;</div><div class=\"line\">            sb.append(<span class=\"string\">\"java\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">long</span> over = System.currentTimeMillis();</div><div class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"操作\"</span> + sb.getClass().getName() + <span class=\"string\">\"类型使用的时间为：\"</span> + (over - <span class=\"built_in\">begin</span>) + <span class=\"string\">\"毫秒\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> testStringBuilder() &#123;</div><div class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\">        <span class=\"keyword\">long</span> <span class=\"built_in\">begin</span> = System.currentTimeMillis();</div><div class=\"line\">        <span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; time; i++) &#123;</div><div class=\"line\">            sb.append(<span class=\"string\">\"java\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">long</span> over = System.currentTimeMillis();</div><div class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"操作\"</span> + sb.getClass().getName() + <span class=\"string\">\"类型使用的时间为：\"</span> + (over - <span class=\"built_in\">begin</span>) + <span class=\"string\">\"毫秒\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> test1String() &#123;</div><div class=\"line\">        <span class=\"keyword\">long</span> <span class=\"built_in\">begin</span> = System.currentTimeMillis();</div><div class=\"line\">        <span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; time; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">String</span> s = <span class=\"string\">\"I\"</span> + <span class=\"string\">\"love\"</span> + <span class=\"string\">\"java\"</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">long</span> over = System.currentTimeMillis();</div><div class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"字符串直接相加操作：\"</span> + (over - <span class=\"built_in\">begin</span>) + <span class=\"string\">\"毫秒\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> test2String() &#123;</div><div class=\"line\">        <span class=\"keyword\">String</span> s1 = <span class=\"string\">\"I\"</span>;</div><div class=\"line\">        <span class=\"keyword\">String</span> s2 = <span class=\"string\">\"love\"</span>;</div><div class=\"line\">        <span class=\"keyword\">String</span> s3 = <span class=\"string\">\"java\"</span>;</div><div class=\"line\">        <span class=\"keyword\">long</span> <span class=\"built_in\">begin</span> = System.currentTimeMillis();</div><div class=\"line\">        <span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; time; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">String</span> s = s1 + s2 + s3;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">long</span> over = System.currentTimeMillis();</div><div class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"字符串间接相加操作：\"</span> + (over - <span class=\"built_in\">begin</span>) + <span class=\"string\">\"毫秒\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p></p>\n<p>结果<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">操作java<span class=\"selector-class\">.lang</span><span class=\"selector-class\">.String</span>类型使用的时间为：<span class=\"number\">2457</span>毫秒</div><div class=\"line\">操作java<span class=\"selector-class\">.lang</span><span class=\"selector-class\">.StringBuffer</span>类型使用的时间为：<span class=\"number\">6</span>毫秒</div><div class=\"line\">操作java<span class=\"selector-class\">.lang</span><span class=\"selector-class\">.StringBuilder</span>类型使用的时间为：<span class=\"number\">2</span>毫秒</div><div class=\"line\">字符串直接相加操作：<span class=\"number\">1</span>毫秒</div><div class=\"line\">字符串间接相加操作：<span class=\"number\">7</span>毫秒</div></pre></td></tr></table></figure></p>\n<p>分析:</p>\n<ol>\n<li>对于直接相加字符串，效率很高，因为在编译器便确定了它的值，也就是说形如”I”+”love”+”java”; 的字符串相加，在编译期间便被优化成了”Ilovejava”。这个可以用javap -c命令反编译生成的class文件进行验证。</li>\n<li>String、StringBuilder、StringBuffer三者的执行效率：<br>　　StringBuilder(线程不安全的) &gt; StringBuffer(线程安全的) &gt; String<br>　　当然这个是相对的，不一定在所有情况下都是这样。<br>　　比如String str = “hello”+ “world”的效率就比 StringBuilder st  = new StringBuilder().append(“hello”).append(“world”)要高。<br>　　因此，这三个类是各有利弊，应当根据不同的情况来进行选择使用：<br>　　当字符串相加操作或者改动较少的情况下，建议使用 String str=”hello”这种形式；<br>　　当字符串相加操作较多的情况下，建议使用StringBuilder，如果采用了多线程，则使用StringBuffer。</li>\n<li>下面这段代码的输出结果是什么？<br>　　String a = “hello2”; 　　String b = “hello” + 2; 　　System.out.println((a == b));<br>　　输出结果为：true。原因很简单，”hello”+2在编译期间就已经被优化成”hello2”，因此在运行期间，变量a和变量b指向的是同一个对象。</li>\n<li>下面这段代码的输出结果是什么？<br>　　String a = “hello2”; 　  String b = “hello”;       String c = b + 2;       System.out.println((a == c));<br>　　输出结果为:false。由于有符号引用的存在，所以  String c = b + 2;不会在编译期间被优化，不会把b+2当做字面常量来处理的，因此这种方式生成的对象事实上是保存在堆上的。因此a和c指向的并不是同一个对象。</li>\n<li>下面这段代码的输出结果是什么？<br>　　String a = “hello2”;   　 final String b = “hello”;       String c = b + 2;       System.out.println((a == c));<br>　　输出结果为：true。对于被final修饰的变量，会在class文件常量池中保存一个副本，也就是说不会通过连接而进行访问，对final变量的访问在编译期间都会直接被替代为真实的值。那么String c = b + 2;在编译期间就会被优化成：String c = “hello” + 2;</li>\n<li>请别再拿“String s = new String(“xyz”);创建了多少个String实例”来面试了吧 <a href=\"http://rednaxelafx.iteye.com/blog/774673/\">http://rednaxelafx.iteye.com/blog/774673/</a></li>\n</ol>"},{"title":"Guava初探","date":"2017-07-25T07:48:57.000Z","toc":true,"_content":"","source":"_posts/17Guava初探.md","raw":"---\ntitle: Guava初探\ndate: 2017-07-25 15:48:57\ntags: Java Guava\ncategories: \"Guava\"\ntoc: true\n---\n","slug":"17Guava初探","published":1,"updated":"2017-07-25T07:49:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tca1000pa7xwu68rz61d","content":"","excerpt":"","more":""},{"title":"20一致性哈希算法","date":"2017-09-18T09:59:31.000Z","toc":true,"_content":"#### 一.使用场景\n现在我们假设有100台redis data服务器，一份数据101进来的时候，以散列公式hash(i)&100，计算所存放的服务器，假设hash(i) = i,那么数据被散列到标号为1的服务器,然后这个时候服务器新增了一台，然后散列公式为hash(i)%101，这个时候请求访问数据101的时候，被分配至0号服务器，但是其实这个时候数据是在1号服务器的。\n所以这个时候大量的数据失效了（访问不到了）。\n<!--more-->\n所以这个时候，我们假设是新增了服务器，如果是持久化存储的，我们可以让服务器集群对数据进行重新散列，进行数据迁移，然后进行恢复，但是这个时候就意味着每次增减服务器的时候，集群就需要大量的通信，进行数据迁移，这个开销是非常大的。如果只是缓存，那么缓存就都失效了。所以这个时候怎么办？\n我们可以看到，关键问题在于，服务器数量变动的时候，要能够保证旧的数据能够按照老的算法，计算到数据所在的服务器，而新的数据能够按照新的散列算法，计算出数据所在的服务器。\n如，我们有ABCD四台服务器，这四台服务器被分配至0~232 的一个环上，比如0~230的存储在A服务器，230 +1~231 存储到B服务器上.....CD按照这样的进行均分。将我们的散列空间也划为0~232 ，然后数据进来后对232 取模，得到一个值K1，我们根据K1在环上所处的位置，得到所分配到的服务器，如图，K1被分配到B服务器。 这个时候，我们有一台服务器B失效了。\n我们可以看到，如果是B失效了，那么如果有持久化存储的，需要做数据恢复，将B的数据迁移至C即可，对于原本散列在A和D的数据，不需要做任何改变。 同理，如果我们是新增了服务器，那么只需要对一台服务器的数据迁移一部分至新加的服务器即可。\n一致性hash算法，减少了数据映射关系的变动，不会像hash(i)%N那样带来全局的变动\n而且这样还有个好处，假设我们使用UID作为散列范围（即上面的232 ）,那么假设有部分UID的访问很频繁，而且这部分UID集中在B服务器上，那么就造成了B的负载远远高于其他服务器。这就是热点数据的问题。这个时候我们可以向B所在的UID空间添加服务器，减少B的压力。\n其实还有个更好的解决办法：虚拟节点。\n上面说的情况是，使用真实的服务器作为节点散列在232 上。 我们假设，只有4台服务器，然后A上面有热点数据，结果A挂掉了，然后做数据恢复，A的数据迁移至B，然后B需要承受A+B的数据，也承受不住，也挂了。。。。然后继续CD都挂了。这就造成了\n\n#### 二.哈希算法判定标准\n一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：\n1. 平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。\n2. 单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。\n3. 分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。\n4. 负载(Load)：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。\n\n#### 三.要点总结：\n1. 所谓的哈希算法，就是尽量做到随机无序，如果数据量足够的话，就可以看作是打乱顺序、平均分配位置的算法。\n2. 新增的redis物理节点，必须经过哈希算法，获取到n个虚拟节点（分身），每个虚拟节点遵循顺时针原则，管理散列在哈希环（哈希桶）上对应的对象（http请求）；\n3. 这样，即便是新增或者删除真实的节点，都不会影响太大，因为每个真实的redis节点都可以看作是平均分配在整个系统当中的，1个节点的失效最多引起n个虚拟节点的实效，考虑到虚拟节点有散列平均分配的性质，基本不会造成灾难性影响。\n\n#### 四.相关链接：\n1. https://coolshell.cn/articles/10910.html\n2.\n\n","source":"_posts/20一致性哈希算法.md","raw":"---\ntitle: 20一致性哈希算法\ndate: 2017-09-18 17:59:31\ntags: 算法\ncategories: \"技术\"\ntoc: true\n---\n#### 一.使用场景\n现在我们假设有100台redis data服务器，一份数据101进来的时候，以散列公式hash(i)&100，计算所存放的服务器，假设hash(i) = i,那么数据被散列到标号为1的服务器,然后这个时候服务器新增了一台，然后散列公式为hash(i)%101，这个时候请求访问数据101的时候，被分配至0号服务器，但是其实这个时候数据是在1号服务器的。\n所以这个时候大量的数据失效了（访问不到了）。\n<!--more-->\n所以这个时候，我们假设是新增了服务器，如果是持久化存储的，我们可以让服务器集群对数据进行重新散列，进行数据迁移，然后进行恢复，但是这个时候就意味着每次增减服务器的时候，集群就需要大量的通信，进行数据迁移，这个开销是非常大的。如果只是缓存，那么缓存就都失效了。所以这个时候怎么办？\n我们可以看到，关键问题在于，服务器数量变动的时候，要能够保证旧的数据能够按照老的算法，计算到数据所在的服务器，而新的数据能够按照新的散列算法，计算出数据所在的服务器。\n如，我们有ABCD四台服务器，这四台服务器被分配至0~232 的一个环上，比如0~230的存储在A服务器，230 +1~231 存储到B服务器上.....CD按照这样的进行均分。将我们的散列空间也划为0~232 ，然后数据进来后对232 取模，得到一个值K1，我们根据K1在环上所处的位置，得到所分配到的服务器，如图，K1被分配到B服务器。 这个时候，我们有一台服务器B失效了。\n我们可以看到，如果是B失效了，那么如果有持久化存储的，需要做数据恢复，将B的数据迁移至C即可，对于原本散列在A和D的数据，不需要做任何改变。 同理，如果我们是新增了服务器，那么只需要对一台服务器的数据迁移一部分至新加的服务器即可。\n一致性hash算法，减少了数据映射关系的变动，不会像hash(i)%N那样带来全局的变动\n而且这样还有个好处，假设我们使用UID作为散列范围（即上面的232 ）,那么假设有部分UID的访问很频繁，而且这部分UID集中在B服务器上，那么就造成了B的负载远远高于其他服务器。这就是热点数据的问题。这个时候我们可以向B所在的UID空间添加服务器，减少B的压力。\n其实还有个更好的解决办法：虚拟节点。\n上面说的情况是，使用真实的服务器作为节点散列在232 上。 我们假设，只有4台服务器，然后A上面有热点数据，结果A挂掉了，然后做数据恢复，A的数据迁移至B，然后B需要承受A+B的数据，也承受不住，也挂了。。。。然后继续CD都挂了。这就造成了\n\n#### 二.哈希算法判定标准\n一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：\n1. 平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。\n2. 单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。\n3. 分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。\n4. 负载(Load)：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。\n\n#### 三.要点总结：\n1. 所谓的哈希算法，就是尽量做到随机无序，如果数据量足够的话，就可以看作是打乱顺序、平均分配位置的算法。\n2. 新增的redis物理节点，必须经过哈希算法，获取到n个虚拟节点（分身），每个虚拟节点遵循顺时针原则，管理散列在哈希环（哈希桶）上对应的对象（http请求）；\n3. 这样，即便是新增或者删除真实的节点，都不会影响太大，因为每个真实的redis节点都可以看作是平均分配在整个系统当中的，1个节点的失效最多引起n个虚拟节点的实效，考虑到虚拟节点有散列平均分配的性质，基本不会造成灾难性影响。\n\n#### 四.相关链接：\n1. https://coolshell.cn/articles/10910.html\n2.\n\n","slug":"20一致性哈希算法","published":1,"updated":"2017-09-18T13:24:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tca2000ra7xwcxfsqx5n","content":"<h4 id=\"一-使用场景\"><a href=\"#一-使用场景\" class=\"headerlink\" title=\"一.使用场景\"></a>一.使用场景</h4><p>现在我们假设有100台redis data服务器，一份数据101进来的时候，以散列公式hash(i)&amp;100，计算所存放的服务器，假设hash(i) = i,那么数据被散列到标号为1的服务器,然后这个时候服务器新增了一台，然后散列公式为hash(i)%101，这个时候请求访问数据101的时候，被分配至0号服务器，但是其实这个时候数据是在1号服务器的。<br>所以这个时候大量的数据失效了（访问不到了）。<br><a id=\"more\"></a><br>所以这个时候，我们假设是新增了服务器，如果是持久化存储的，我们可以让服务器集群对数据进行重新散列，进行数据迁移，然后进行恢复，但是这个时候就意味着每次增减服务器的时候，集群就需要大量的通信，进行数据迁移，这个开销是非常大的。如果只是缓存，那么缓存就都失效了。所以这个时候怎么办？<br>我们可以看到，关键问题在于，服务器数量变动的时候，要能够保证旧的数据能够按照老的算法，计算到数据所在的服务器，而新的数据能够按照新的散列算法，计算出数据所在的服务器。<br>如，我们有ABCD四台服务器，这四台服务器被分配至0~232 的一个环上，比如0~230的存储在A服务器，230 +1~231 存储到B服务器上…..CD按照这样的进行均分。将我们的散列空间也划为0~232 ，然后数据进来后对232 取模，得到一个值K1，我们根据K1在环上所处的位置，得到所分配到的服务器，如图，K1被分配到B服务器。 这个时候，我们有一台服务器B失效了。<br>我们可以看到，如果是B失效了，那么如果有持久化存储的，需要做数据恢复，将B的数据迁移至C即可，对于原本散列在A和D的数据，不需要做任何改变。 同理，如果我们是新增了服务器，那么只需要对一台服务器的数据迁移一部分至新加的服务器即可。<br>一致性hash算法，减少了数据映射关系的变动，不会像hash(i)%N那样带来全局的变动<br>而且这样还有个好处，假设我们使用UID作为散列范围（即上面的232 ）,那么假设有部分UID的访问很频繁，而且这部分UID集中在B服务器上，那么就造成了B的负载远远高于其他服务器。这就是热点数据的问题。这个时候我们可以向B所在的UID空间添加服务器，减少B的压力。<br>其实还有个更好的解决办法：虚拟节点。<br>上面说的情况是，使用真实的服务器作为节点散列在232 上。 我们假设，只有4台服务器，然后A上面有热点数据，结果A挂掉了，然后做数据恢复，A的数据迁移至B，然后B需要承受A+B的数据，也承受不住，也挂了。。。。然后继续CD都挂了。这就造成了</p>\n<h4 id=\"二-哈希算法判定标准\"><a href=\"#二-哈希算法判定标准\" class=\"headerlink\" title=\"二.哈希算法判定标准\"></a>二.哈希算法判定标准</h4><p>一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：</p>\n<ol>\n<li>平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</li>\n<li>单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。</li>\n<li>分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。</li>\n<li>负载(Load)：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</li>\n</ol>\n<h4 id=\"三-要点总结：\"><a href=\"#三-要点总结：\" class=\"headerlink\" title=\"三.要点总结：\"></a>三.要点总结：</h4><ol>\n<li>所谓的哈希算法，就是尽量做到随机无序，如果数据量足够的话，就可以看作是打乱顺序、平均分配位置的算法。</li>\n<li>新增的redis物理节点，必须经过哈希算法，获取到n个虚拟节点（分身），每个虚拟节点遵循顺时针原则，管理散列在哈希环（哈希桶）上对应的对象（http请求）；</li>\n<li>这样，即便是新增或者删除真实的节点，都不会影响太大，因为每个真实的redis节点都可以看作是平均分配在整个系统当中的，1个节点的失效最多引起n个虚拟节点的实效，考虑到虚拟节点有散列平均分配的性质，基本不会造成灾难性影响。</li>\n</ol>\n<h4 id=\"四-相关链接：\"><a href=\"#四-相关链接：\" class=\"headerlink\" title=\"四.相关链接：\"></a>四.相关链接：</h4><ol>\n<li><a href=\"https://coolshell.cn/articles/10910.html\" target=\"_blank\" rel=\"external\">https://coolshell.cn/articles/10910.html</a><br>2.</li>\n</ol>\n","excerpt":"<h4 id=\"一-使用场景\"><a href=\"#一-使用场景\" class=\"headerlink\" title=\"一.使用场景\"></a>一.使用场景</h4><p>现在我们假设有100台redis data服务器，一份数据101进来的时候，以散列公式hash(i)&amp;100，计算所存放的服务器，假设hash(i) = i,那么数据被散列到标号为1的服务器,然后这个时候服务器新增了一台，然后散列公式为hash(i)%101，这个时候请求访问数据101的时候，被分配至0号服务器，但是其实这个时候数据是在1号服务器的。<br>所以这个时候大量的数据失效了（访问不到了）。<br></p>","more":"<br>所以这个时候，我们假设是新增了服务器，如果是持久化存储的，我们可以让服务器集群对数据进行重新散列，进行数据迁移，然后进行恢复，但是这个时候就意味着每次增减服务器的时候，集群就需要大量的通信，进行数据迁移，这个开销是非常大的。如果只是缓存，那么缓存就都失效了。所以这个时候怎么办？<br>我们可以看到，关键问题在于，服务器数量变动的时候，要能够保证旧的数据能够按照老的算法，计算到数据所在的服务器，而新的数据能够按照新的散列算法，计算出数据所在的服务器。<br>如，我们有ABCD四台服务器，这四台服务器被分配至0~232 的一个环上，比如0~230的存储在A服务器，230 +1~231 存储到B服务器上…..CD按照这样的进行均分。将我们的散列空间也划为0~232 ，然后数据进来后对232 取模，得到一个值K1，我们根据K1在环上所处的位置，得到所分配到的服务器，如图，K1被分配到B服务器。 这个时候，我们有一台服务器B失效了。<br>我们可以看到，如果是B失效了，那么如果有持久化存储的，需要做数据恢复，将B的数据迁移至C即可，对于原本散列在A和D的数据，不需要做任何改变。 同理，如果我们是新增了服务器，那么只需要对一台服务器的数据迁移一部分至新加的服务器即可。<br>一致性hash算法，减少了数据映射关系的变动，不会像hash(i)%N那样带来全局的变动<br>而且这样还有个好处，假设我们使用UID作为散列范围（即上面的232 ）,那么假设有部分UID的访问很频繁，而且这部分UID集中在B服务器上，那么就造成了B的负载远远高于其他服务器。这就是热点数据的问题。这个时候我们可以向B所在的UID空间添加服务器，减少B的压力。<br>其实还有个更好的解决办法：虚拟节点。<br>上面说的情况是，使用真实的服务器作为节点散列在232 上。 我们假设，只有4台服务器，然后A上面有热点数据，结果A挂掉了，然后做数据恢复，A的数据迁移至B，然后B需要承受A+B的数据，也承受不住，也挂了。。。。然后继续CD都挂了。这就造成了<p></p>\n<h4 id=\"二-哈希算法判定标准\"><a href=\"#二-哈希算法判定标准\" class=\"headerlink\" title=\"二.哈希算法判定标准\"></a>二.哈希算法判定标准</h4><p>一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：</p>\n<ol>\n<li>平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</li>\n<li>单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。</li>\n<li>分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。</li>\n<li>负载(Load)：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</li>\n</ol>\n<h4 id=\"三-要点总结：\"><a href=\"#三-要点总结：\" class=\"headerlink\" title=\"三.要点总结：\"></a>三.要点总结：</h4><ol>\n<li>所谓的哈希算法，就是尽量做到随机无序，如果数据量足够的话，就可以看作是打乱顺序、平均分配位置的算法。</li>\n<li>新增的redis物理节点，必须经过哈希算法，获取到n个虚拟节点（分身），每个虚拟节点遵循顺时针原则，管理散列在哈希环（哈希桶）上对应的对象（http请求）；</li>\n<li>这样，即便是新增或者删除真实的节点，都不会影响太大，因为每个真实的redis节点都可以看作是平均分配在整个系统当中的，1个节点的失效最多引起n个虚拟节点的实效，考虑到虚拟节点有散列平均分配的性质，基本不会造成灾难性影响。</li>\n</ol>\n<h4 id=\"四-相关链接：\"><a href=\"#四-相关链接：\" class=\"headerlink\" title=\"四.相关链接：\"></a>四.相关链接：</h4><ol>\n<li><a href=\"https://coolshell.cn/articles/10910.html\">https://coolshell.cn/articles/10910.html</a><br>2.</li>\n</ol>"},{"title":"程序员最核心的竞争力是什么？","date":"2017-09-27T07:52:45.000Z","_content":"进行社招面试时，有一个问题几乎是必问的：\n> 你为什么要离开上一家公司？\n\n其实这个问题主要是想试探一下求职者的核心诉求，并借此预估一下他在本公司工作的稳定性。常见的答案也无非就是这么几种：对薪酬不满意、干得不爽，或者是想换个环境。\n<!--more-->\n然而，我遇到过好几个初次跳槽的求职者给出的答案是：「在原来的公司学不到技术」。\n一听到这个，我就不由得叹口气：今天这一小时又算是交代了，这人基本上没戏。因为根据我的经验，这句话如果由工作不满两年的人说出来，很大概率这是个不会学习不会感恩又特别爱抱怨的人。\n程序员最核心的竞争力——「学习力」\n如果有人问我：你在面试程序员时，最看中的是什么能力？那我的答案一定是：学习力。\n互联网时代的技术来得快，去得更快。就像Flash这样曾经雄霸天下多年的技术，都有被人人唾弃的一天。如果没有足够强的学习能力，就无法跟上变化，被淘汰只是迟早的事。想想看，你苦心钻研多年引以为傲的技术，一夜之间就没有用武之地了，难免会有一种「身体被掏空」的感觉。\n学习力强的程序员敢大胆地体验尝试新技术，他们的技术栈始终在保持不断地更新。他们能快速把握事物的本质，并判断出它能用来做什么，不能用来做什么。他们拥抱技术升级和革命，因为他们学习并掌握新技术的速度比其他人更快，所以他们永远不用担心失业。事实上，他们掌握的是「驾驶」和「学习驾驶」的技术，而不是「驾驶XX牌汽车」的技术。\n而学习力差的程序员呢？为了继续停留在旧技术的舒适区，他们往往会抵制新技术的推广，甚至百般阻挠。因为那会使他们过去的经验统统无效，只能和后来者站在同一起跑线上。抱死一个框架好几年，脱离了框架啥都干不了的程序员实在太多了。事实上，这样的人不能驾驭技术，反而是被技术给奴役了。\n同样是自行车，为什么山地车比公路车更普及更流行？除了皮实耐用价格低外，主要是因为它的通过性好，什么泥地沙地都不在话下，上下马路牙子跟玩一样。而公路车呢？只能老老实实地跑在平路上。\n公司不是学校\n面对这些因为「想学点技术」而换工作的求职者，评价他们「不思进取」貌似不太合适。但显然他们的思维模式还是被学校洗脑的那一套，没能真正地融入社会。也许他们认为，学习就是要由老师手把手带着，而自己之所以学不到技术，就是因为没遇到一个好leader，能替自己设计好成长路线，指出所有重难点，提供各种参考资料……\n在中国传统文化里，不管是匠人还是武师，收徒都要找毫无根基的幼童。这一方面是为了保持师父的绝对权威，方便贯彻落实教学；另一方面是为了尽量延长学徒期，以考察徒弟的品性。拜师之后，徒弟便跟随师父一起生活，经过数年的言传身教，这才得以出师。\n师父收徒的核心诉求，是「传承」自己的技艺和名声，希望徒弟日后能做出一番成就来光耀师门。这就要求徒弟流动性低、忠诚度高、归属感强。与其说是收徒，还不如说是在挑儿子，所以有句俗话叫作「一日为师，终身为父」。\n然而公司是盈利性的商业组织，不是学校，更不是新手训练营。公司招聘员工的核心诉求，是生产出实实在在、对得起薪水的价值，而不是传承技艺。公司希望员工入职前就具备工作的能力，至少在经过短暂的培训和指导后就能独立开展工作，正所谓「能干就干，干不了走人」。\n一般情况下，为了使新人尽快进入工作状态，公司会安排一位老员工来做一段时间的导师。但导师只有为你解惑的义务，却没有教你技术的责任。 因为导师自己手里还有做不完的工作，带新人又没什么利益可图，凭什么为你提供私人教练级的服务？能有耐心听完你的问题，指点一下方向，就已经很不错了。\n学习是自己的事，没有人能替你去做。这就跟吃饭一样，谁真的关心你吃没吃、饱没饱？就算你的亲人再怎么关心你，也不能替你去吃。我们都知道，人不吃饭肯定是要饿死的，那你为什么不去给自己找吃的，却在埋怨没有人给你嘴里喂食呢？\n为什么你学不到技术？\n很多人在学习之路上已经饱尝了痛苦的滋味，因此在离开学校之后。他们不到万不得已，是决然不会去学习的。你不妨回顾一下，从参加工作以来到现在，自己哪段时间里学习最认真，进步最明显？\n如果不出意外的话，应该就是你找到的第一份工作的试用期。因为不想失去自己通过努力争取到的工作机会，所以你不得不逼自己打起十二份精神来学习，结果居然以自己都无法想象的速度掌握了工作必备的知识和技能。\n然而，大多数人在自己的能力满足当前工作的要求之后，就丧失了学习的动力。下班之后要追剧，要玩游戏，要打球，要谈恋爱……为啥我要学习？不学又不会失业！学这个有啥用？谁知道用得上用不上？等要用的时候再学呗！\n其实， 学不到技术最核心的原因只有一个：动机不足。至于环境条件，只是影响学习效果的因素之一，但绝对不是最重要的因素。在一个恶劣的环境里选择放弃学习的人，不可能到了一个优越的环境里就会去主动学习，因为在他内心深处对学习是抗拒的。\n难道说换上了Macbook Pro和4k显示器，坐在数千元的人体工学座椅上，下班后就会有兴趣看框架源码了吗？看电影、打游戏不是更舒服一些？\n在我看来，学习力的源泉就是好奇心，也就是对新知识的渴求，以及对探索未知的冲动。我们的大脑是「用进废退」的，如果不定期给它输送新鲜的知识营养，它就会逐渐退化。有学习力的人一段时间不看书，不折腾点新玩意，大脑真的是会「饿」的。\n程序员该怎么学习技术？\n有的求职者觉得自己没学到技术，是因为公司不给机会，或者缺乏条件：\n「上次的H5让小王做了，这次的微信小程序又给了小李……完全没我什么事啊！」\n「公司最大一张表才10W数据，根本用不着分库分表啊！」\n……\n学习技术最有效的方式是阅读、实践和交流。公司没给你安排这方面的工作，那你自己都做了些什么呢？八小时之外的时间都用在哪了？有没有读源码？有没有看原版书？有没有泡技术社区？有没有尝试最新流行的技术？有没有尝试把它们用在公司的项目上？有没有主动去接触行业里使用这些技术的团队和大牛？\n「看文档」其实是最快的学习方法。对于自己工作中常用到的技术，抽时间把官方文档通读一遍（其实篇幅都不大），绝对收获满满。没事的时候多翻翻自己使用的框架/系统/平台的API，看看有哪些自己不知道或者没用过的功能，想想这个功能可以用来做什么，能不能解决现存的问题，或者优化当下的解决方案。\n如果你是前端工程师，通读HTTP协议和ECMAScript标准，就能秒杀95%的同行，不开玩笑。\n「读源码」是深入学习开源技术的唯一途径。只有理解了某个功能在底层是如何实现的，你才能真正把握它更适合用来做什么，不能用来做什么。正如不明显汽车的构造和原理，我们也能把车开好。而如果多少知道一点，开起来就会更得心应手。当车出现问题时，也不至于完全束手无策，只能蹲在路边等待救援。\n你一个框架用了N年了，却连一行源码都没读过？如果它是你女朋友，估计早该分手了。\n「折腾」是学习任何技术的必经之路。在有保护的环境下进行大量的试错，是最高效的学习方法。现在虚拟机技术已经那么成熟，VPS也很便宜，你为什么不分分钟弄一个，然后在上面花式作死呢？\n听说过无数次 rm -rf / 的事故，可你居然一次都没试过？知道输出啥样子么？\n公司给你提供的最有价值的东西，就是实战的机会。 你所学习的技术，最终需要通过工作来变现。你有机会接触到真实的数据，了解真实的用户，观察真实系统是怎样运转的，积累真实的经验……\n然而，所谓的机会，只属于已经提前准备好的人。 不要等到工作都安排到你身上了再去学习。公司不是你的试验田，你也不该拿用户当小白鼠。公司不给你机会，那只说明你还没有准备好。\n后话\n「吾生也有涯，而知也无涯 。以有涯随无涯，殆已！」*——《庄子·内篇·养生主第三》\n技术世界就如同一片汪洋大海，细分领域真是多如牛毛。我们只是站在其中一个小岛上，怎么确定自己该朝哪个方向进发呢？\n学习技术不外乎以下两个方向：\n1、广度：整个使用链条由哪些环节构成？每个环节的作用是什么？都有哪些类似的可替代方案？它们之间有什么区别？各自优劣点是什么？……\n2、深度：这个「技术 / 产品」的本质是什么？都能做什么？运作原理是什么？底层是如何实现的？可以做怎样的改进？……\n不管你在做什么工作，都应该先把自己每天都要用的核心技术做到一定深度，再去拓展广度。 「什么都知道一点，但都不甚了解」是最可怕的，它会让你误以为自己已经很NB了。\n学习，是一辈子的事。","source":"_posts/21程序员最核心的竞争力是什么？.md","raw":"---\ntitle: 程序员最核心的竞争力是什么？\ndate: 2017-09-27 15:52:45\ntags: 面试 Java\ncategories: \"职业规划\"\n---\n进行社招面试时，有一个问题几乎是必问的：\n> 你为什么要离开上一家公司？\n\n其实这个问题主要是想试探一下求职者的核心诉求，并借此预估一下他在本公司工作的稳定性。常见的答案也无非就是这么几种：对薪酬不满意、干得不爽，或者是想换个环境。\n<!--more-->\n然而，我遇到过好几个初次跳槽的求职者给出的答案是：「在原来的公司学不到技术」。\n一听到这个，我就不由得叹口气：今天这一小时又算是交代了，这人基本上没戏。因为根据我的经验，这句话如果由工作不满两年的人说出来，很大概率这是个不会学习不会感恩又特别爱抱怨的人。\n程序员最核心的竞争力——「学习力」\n如果有人问我：你在面试程序员时，最看中的是什么能力？那我的答案一定是：学习力。\n互联网时代的技术来得快，去得更快。就像Flash这样曾经雄霸天下多年的技术，都有被人人唾弃的一天。如果没有足够强的学习能力，就无法跟上变化，被淘汰只是迟早的事。想想看，你苦心钻研多年引以为傲的技术，一夜之间就没有用武之地了，难免会有一种「身体被掏空」的感觉。\n学习力强的程序员敢大胆地体验尝试新技术，他们的技术栈始终在保持不断地更新。他们能快速把握事物的本质，并判断出它能用来做什么，不能用来做什么。他们拥抱技术升级和革命，因为他们学习并掌握新技术的速度比其他人更快，所以他们永远不用担心失业。事实上，他们掌握的是「驾驶」和「学习驾驶」的技术，而不是「驾驶XX牌汽车」的技术。\n而学习力差的程序员呢？为了继续停留在旧技术的舒适区，他们往往会抵制新技术的推广，甚至百般阻挠。因为那会使他们过去的经验统统无效，只能和后来者站在同一起跑线上。抱死一个框架好几年，脱离了框架啥都干不了的程序员实在太多了。事实上，这样的人不能驾驭技术，反而是被技术给奴役了。\n同样是自行车，为什么山地车比公路车更普及更流行？除了皮实耐用价格低外，主要是因为它的通过性好，什么泥地沙地都不在话下，上下马路牙子跟玩一样。而公路车呢？只能老老实实地跑在平路上。\n公司不是学校\n面对这些因为「想学点技术」而换工作的求职者，评价他们「不思进取」貌似不太合适。但显然他们的思维模式还是被学校洗脑的那一套，没能真正地融入社会。也许他们认为，学习就是要由老师手把手带着，而自己之所以学不到技术，就是因为没遇到一个好leader，能替自己设计好成长路线，指出所有重难点，提供各种参考资料……\n在中国传统文化里，不管是匠人还是武师，收徒都要找毫无根基的幼童。这一方面是为了保持师父的绝对权威，方便贯彻落实教学；另一方面是为了尽量延长学徒期，以考察徒弟的品性。拜师之后，徒弟便跟随师父一起生活，经过数年的言传身教，这才得以出师。\n师父收徒的核心诉求，是「传承」自己的技艺和名声，希望徒弟日后能做出一番成就来光耀师门。这就要求徒弟流动性低、忠诚度高、归属感强。与其说是收徒，还不如说是在挑儿子，所以有句俗话叫作「一日为师，终身为父」。\n然而公司是盈利性的商业组织，不是学校，更不是新手训练营。公司招聘员工的核心诉求，是生产出实实在在、对得起薪水的价值，而不是传承技艺。公司希望员工入职前就具备工作的能力，至少在经过短暂的培训和指导后就能独立开展工作，正所谓「能干就干，干不了走人」。\n一般情况下，为了使新人尽快进入工作状态，公司会安排一位老员工来做一段时间的导师。但导师只有为你解惑的义务，却没有教你技术的责任。 因为导师自己手里还有做不完的工作，带新人又没什么利益可图，凭什么为你提供私人教练级的服务？能有耐心听完你的问题，指点一下方向，就已经很不错了。\n学习是自己的事，没有人能替你去做。这就跟吃饭一样，谁真的关心你吃没吃、饱没饱？就算你的亲人再怎么关心你，也不能替你去吃。我们都知道，人不吃饭肯定是要饿死的，那你为什么不去给自己找吃的，却在埋怨没有人给你嘴里喂食呢？\n为什么你学不到技术？\n很多人在学习之路上已经饱尝了痛苦的滋味，因此在离开学校之后。他们不到万不得已，是决然不会去学习的。你不妨回顾一下，从参加工作以来到现在，自己哪段时间里学习最认真，进步最明显？\n如果不出意外的话，应该就是你找到的第一份工作的试用期。因为不想失去自己通过努力争取到的工作机会，所以你不得不逼自己打起十二份精神来学习，结果居然以自己都无法想象的速度掌握了工作必备的知识和技能。\n然而，大多数人在自己的能力满足当前工作的要求之后，就丧失了学习的动力。下班之后要追剧，要玩游戏，要打球，要谈恋爱……为啥我要学习？不学又不会失业！学这个有啥用？谁知道用得上用不上？等要用的时候再学呗！\n其实， 学不到技术最核心的原因只有一个：动机不足。至于环境条件，只是影响学习效果的因素之一，但绝对不是最重要的因素。在一个恶劣的环境里选择放弃学习的人，不可能到了一个优越的环境里就会去主动学习，因为在他内心深处对学习是抗拒的。\n难道说换上了Macbook Pro和4k显示器，坐在数千元的人体工学座椅上，下班后就会有兴趣看框架源码了吗？看电影、打游戏不是更舒服一些？\n在我看来，学习力的源泉就是好奇心，也就是对新知识的渴求，以及对探索未知的冲动。我们的大脑是「用进废退」的，如果不定期给它输送新鲜的知识营养，它就会逐渐退化。有学习力的人一段时间不看书，不折腾点新玩意，大脑真的是会「饿」的。\n程序员该怎么学习技术？\n有的求职者觉得自己没学到技术，是因为公司不给机会，或者缺乏条件：\n「上次的H5让小王做了，这次的微信小程序又给了小李……完全没我什么事啊！」\n「公司最大一张表才10W数据，根本用不着分库分表啊！」\n……\n学习技术最有效的方式是阅读、实践和交流。公司没给你安排这方面的工作，那你自己都做了些什么呢？八小时之外的时间都用在哪了？有没有读源码？有没有看原版书？有没有泡技术社区？有没有尝试最新流行的技术？有没有尝试把它们用在公司的项目上？有没有主动去接触行业里使用这些技术的团队和大牛？\n「看文档」其实是最快的学习方法。对于自己工作中常用到的技术，抽时间把官方文档通读一遍（其实篇幅都不大），绝对收获满满。没事的时候多翻翻自己使用的框架/系统/平台的API，看看有哪些自己不知道或者没用过的功能，想想这个功能可以用来做什么，能不能解决现存的问题，或者优化当下的解决方案。\n如果你是前端工程师，通读HTTP协议和ECMAScript标准，就能秒杀95%的同行，不开玩笑。\n「读源码」是深入学习开源技术的唯一途径。只有理解了某个功能在底层是如何实现的，你才能真正把握它更适合用来做什么，不能用来做什么。正如不明显汽车的构造和原理，我们也能把车开好。而如果多少知道一点，开起来就会更得心应手。当车出现问题时，也不至于完全束手无策，只能蹲在路边等待救援。\n你一个框架用了N年了，却连一行源码都没读过？如果它是你女朋友，估计早该分手了。\n「折腾」是学习任何技术的必经之路。在有保护的环境下进行大量的试错，是最高效的学习方法。现在虚拟机技术已经那么成熟，VPS也很便宜，你为什么不分分钟弄一个，然后在上面花式作死呢？\n听说过无数次 rm -rf / 的事故，可你居然一次都没试过？知道输出啥样子么？\n公司给你提供的最有价值的东西，就是实战的机会。 你所学习的技术，最终需要通过工作来变现。你有机会接触到真实的数据，了解真实的用户，观察真实系统是怎样运转的，积累真实的经验……\n然而，所谓的机会，只属于已经提前准备好的人。 不要等到工作都安排到你身上了再去学习。公司不是你的试验田，你也不该拿用户当小白鼠。公司不给你机会，那只说明你还没有准备好。\n后话\n「吾生也有涯，而知也无涯 。以有涯随无涯，殆已！」*——《庄子·内篇·养生主第三》\n技术世界就如同一片汪洋大海，细分领域真是多如牛毛。我们只是站在其中一个小岛上，怎么确定自己该朝哪个方向进发呢？\n学习技术不外乎以下两个方向：\n1、广度：整个使用链条由哪些环节构成？每个环节的作用是什么？都有哪些类似的可替代方案？它们之间有什么区别？各自优劣点是什么？……\n2、深度：这个「技术 / 产品」的本质是什么？都能做什么？运作原理是什么？底层是如何实现的？可以做怎样的改进？……\n不管你在做什么工作，都应该先把自己每天都要用的核心技术做到一定深度，再去拓展广度。 「什么都知道一点，但都不甚了解」是最可怕的，它会让你误以为自己已经很NB了。\n学习，是一辈子的事。","slug":"21程序员最核心的竞争力是什么？","published":1,"updated":"2017-09-27T08:01:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tca4000wa7xwtw2bymk3","content":"<p>进行社招面试时，有一个问题几乎是必问的：</p>\n<blockquote>\n<p>你为什么要离开上一家公司？</p>\n</blockquote>\n<p>其实这个问题主要是想试探一下求职者的核心诉求，并借此预估一下他在本公司工作的稳定性。常见的答案也无非就是这么几种：对薪酬不满意、干得不爽，或者是想换个环境。<br><a id=\"more\"></a><br>然而，我遇到过好几个初次跳槽的求职者给出的答案是：「在原来的公司学不到技术」。<br>一听到这个，我就不由得叹口气：今天这一小时又算是交代了，这人基本上没戏。因为根据我的经验，这句话如果由工作不满两年的人说出来，很大概率这是个不会学习不会感恩又特别爱抱怨的人。<br>程序员最核心的竞争力——「学习力」<br>如果有人问我：你在面试程序员时，最看中的是什么能力？那我的答案一定是：学习力。<br>互联网时代的技术来得快，去得更快。就像Flash这样曾经雄霸天下多年的技术，都有被人人唾弃的一天。如果没有足够强的学习能力，就无法跟上变化，被淘汰只是迟早的事。想想看，你苦心钻研多年引以为傲的技术，一夜之间就没有用武之地了，难免会有一种「身体被掏空」的感觉。<br>学习力强的程序员敢大胆地体验尝试新技术，他们的技术栈始终在保持不断地更新。他们能快速把握事物的本质，并判断出它能用来做什么，不能用来做什么。他们拥抱技术升级和革命，因为他们学习并掌握新技术的速度比其他人更快，所以他们永远不用担心失业。事实上，他们掌握的是「驾驶」和「学习驾驶」的技术，而不是「驾驶XX牌汽车」的技术。<br>而学习力差的程序员呢？为了继续停留在旧技术的舒适区，他们往往会抵制新技术的推广，甚至百般阻挠。因为那会使他们过去的经验统统无效，只能和后来者站在同一起跑线上。抱死一个框架好几年，脱离了框架啥都干不了的程序员实在太多了。事实上，这样的人不能驾驭技术，反而是被技术给奴役了。<br>同样是自行车，为什么山地车比公路车更普及更流行？除了皮实耐用价格低外，主要是因为它的通过性好，什么泥地沙地都不在话下，上下马路牙子跟玩一样。而公路车呢？只能老老实实地跑在平路上。<br>公司不是学校<br>面对这些因为「想学点技术」而换工作的求职者，评价他们「不思进取」貌似不太合适。但显然他们的思维模式还是被学校洗脑的那一套，没能真正地融入社会。也许他们认为，学习就是要由老师手把手带着，而自己之所以学不到技术，就是因为没遇到一个好leader，能替自己设计好成长路线，指出所有重难点，提供各种参考资料……<br>在中国传统文化里，不管是匠人还是武师，收徒都要找毫无根基的幼童。这一方面是为了保持师父的绝对权威，方便贯彻落实教学；另一方面是为了尽量延长学徒期，以考察徒弟的品性。拜师之后，徒弟便跟随师父一起生活，经过数年的言传身教，这才得以出师。<br>师父收徒的核心诉求，是「传承」自己的技艺和名声，希望徒弟日后能做出一番成就来光耀师门。这就要求徒弟流动性低、忠诚度高、归属感强。与其说是收徒，还不如说是在挑儿子，所以有句俗话叫作「一日为师，终身为父」。<br>然而公司是盈利性的商业组织，不是学校，更不是新手训练营。公司招聘员工的核心诉求，是生产出实实在在、对得起薪水的价值，而不是传承技艺。公司希望员工入职前就具备工作的能力，至少在经过短暂的培训和指导后就能独立开展工作，正所谓「能干就干，干不了走人」。<br>一般情况下，为了使新人尽快进入工作状态，公司会安排一位老员工来做一段时间的导师。但导师只有为你解惑的义务，却没有教你技术的责任。 因为导师自己手里还有做不完的工作，带新人又没什么利益可图，凭什么为你提供私人教练级的服务？能有耐心听完你的问题，指点一下方向，就已经很不错了。<br>学习是自己的事，没有人能替你去做。这就跟吃饭一样，谁真的关心你吃没吃、饱没饱？就算你的亲人再怎么关心你，也不能替你去吃。我们都知道，人不吃饭肯定是要饿死的，那你为什么不去给自己找吃的，却在埋怨没有人给你嘴里喂食呢？<br>为什么你学不到技术？<br>很多人在学习之路上已经饱尝了痛苦的滋味，因此在离开学校之后。他们不到万不得已，是决然不会去学习的。你不妨回顾一下，从参加工作以来到现在，自己哪段时间里学习最认真，进步最明显？<br>如果不出意外的话，应该就是你找到的第一份工作的试用期。因为不想失去自己通过努力争取到的工作机会，所以你不得不逼自己打起十二份精神来学习，结果居然以自己都无法想象的速度掌握了工作必备的知识和技能。<br>然而，大多数人在自己的能力满足当前工作的要求之后，就丧失了学习的动力。下班之后要追剧，要玩游戏，要打球，要谈恋爱……为啥我要学习？不学又不会失业！学这个有啥用？谁知道用得上用不上？等要用的时候再学呗！<br>其实， 学不到技术最核心的原因只有一个：动机不足。至于环境条件，只是影响学习效果的因素之一，但绝对不是最重要的因素。在一个恶劣的环境里选择放弃学习的人，不可能到了一个优越的环境里就会去主动学习，因为在他内心深处对学习是抗拒的。<br>难道说换上了Macbook Pro和4k显示器，坐在数千元的人体工学座椅上，下班后就会有兴趣看框架源码了吗？看电影、打游戏不是更舒服一些？<br>在我看来，学习力的源泉就是好奇心，也就是对新知识的渴求，以及对探索未知的冲动。我们的大脑是「用进废退」的，如果不定期给它输送新鲜的知识营养，它就会逐渐退化。有学习力的人一段时间不看书，不折腾点新玩意，大脑真的是会「饿」的。<br>程序员该怎么学习技术？<br>有的求职者觉得自己没学到技术，是因为公司不给机会，或者缺乏条件：<br>「上次的H5让小王做了，这次的微信小程序又给了小李……完全没我什么事啊！」<br>「公司最大一张表才10W数据，根本用不着分库分表啊！」<br>……<br>学习技术最有效的方式是阅读、实践和交流。公司没给你安排这方面的工作，那你自己都做了些什么呢？八小时之外的时间都用在哪了？有没有读源码？有没有看原版书？有没有泡技术社区？有没有尝试最新流行的技术？有没有尝试把它们用在公司的项目上？有没有主动去接触行业里使用这些技术的团队和大牛？<br>「看文档」其实是最快的学习方法。对于自己工作中常用到的技术，抽时间把官方文档通读一遍（其实篇幅都不大），绝对收获满满。没事的时候多翻翻自己使用的框架/系统/平台的API，看看有哪些自己不知道或者没用过的功能，想想这个功能可以用来做什么，能不能解决现存的问题，或者优化当下的解决方案。<br>如果你是前端工程师，通读HTTP协议和ECMAScript标准，就能秒杀95%的同行，不开玩笑。<br>「读源码」是深入学习开源技术的唯一途径。只有理解了某个功能在底层是如何实现的，你才能真正把握它更适合用来做什么，不能用来做什么。正如不明显汽车的构造和原理，我们也能把车开好。而如果多少知道一点，开起来就会更得心应手。当车出现问题时，也不至于完全束手无策，只能蹲在路边等待救援。<br>你一个框架用了N年了，却连一行源码都没读过？如果它是你女朋友，估计早该分手了。<br>「折腾」是学习任何技术的必经之路。在有保护的环境下进行大量的试错，是最高效的学习方法。现在虚拟机技术已经那么成熟，VPS也很便宜，你为什么不分分钟弄一个，然后在上面花式作死呢？<br>听说过无数次 rm -rf / 的事故，可你居然一次都没试过？知道输出啥样子么？<br>公司给你提供的最有价值的东西，就是实战的机会。 你所学习的技术，最终需要通过工作来变现。你有机会接触到真实的数据，了解真实的用户，观察真实系统是怎样运转的，积累真实的经验……<br>然而，所谓的机会，只属于已经提前准备好的人。 不要等到工作都安排到你身上了再去学习。公司不是你的试验田，你也不该拿用户当小白鼠。公司不给你机会，那只说明你还没有准备好。<br>后话<br>「吾生也有涯，而知也无涯 。以有涯随无涯，殆已！」*——《庄子·内篇·养生主第三》<br>技术世界就如同一片汪洋大海，细分领域真是多如牛毛。我们只是站在其中一个小岛上，怎么确定自己该朝哪个方向进发呢？<br>学习技术不外乎以下两个方向：<br>1、广度：整个使用链条由哪些环节构成？每个环节的作用是什么？都有哪些类似的可替代方案？它们之间有什么区别？各自优劣点是什么？……<br>2、深度：这个「技术 / 产品」的本质是什么？都能做什么？运作原理是什么？底层是如何实现的？可以做怎样的改进？……<br>不管你在做什么工作，都应该先把自己每天都要用的核心技术做到一定深度，再去拓展广度。 「什么都知道一点，但都不甚了解」是最可怕的，它会让你误以为自己已经很NB了。<br>学习，是一辈子的事。</p>\n","excerpt":"<p>进行社招面试时，有一个问题几乎是必问的：</p>\n<blockquote>\n<p>你为什么要离开上一家公司？</p>\n</blockquote>\n<p>其实这个问题主要是想试探一下求职者的核心诉求，并借此预估一下他在本公司工作的稳定性。常见的答案也无非就是这么几种：对薪酬不满意、干得不爽，或者是想换个环境。<br></p>","more":"<br>然而，我遇到过好几个初次跳槽的求职者给出的答案是：「在原来的公司学不到技术」。<br>一听到这个，我就不由得叹口气：今天这一小时又算是交代了，这人基本上没戏。因为根据我的经验，这句话如果由工作不满两年的人说出来，很大概率这是个不会学习不会感恩又特别爱抱怨的人。<br>程序员最核心的竞争力——「学习力」<br>如果有人问我：你在面试程序员时，最看中的是什么能力？那我的答案一定是：学习力。<br>互联网时代的技术来得快，去得更快。就像Flash这样曾经雄霸天下多年的技术，都有被人人唾弃的一天。如果没有足够强的学习能力，就无法跟上变化，被淘汰只是迟早的事。想想看，你苦心钻研多年引以为傲的技术，一夜之间就没有用武之地了，难免会有一种「身体被掏空」的感觉。<br>学习力强的程序员敢大胆地体验尝试新技术，他们的技术栈始终在保持不断地更新。他们能快速把握事物的本质，并判断出它能用来做什么，不能用来做什么。他们拥抱技术升级和革命，因为他们学习并掌握新技术的速度比其他人更快，所以他们永远不用担心失业。事实上，他们掌握的是「驾驶」和「学习驾驶」的技术，而不是「驾驶XX牌汽车」的技术。<br>而学习力差的程序员呢？为了继续停留在旧技术的舒适区，他们往往会抵制新技术的推广，甚至百般阻挠。因为那会使他们过去的经验统统无效，只能和后来者站在同一起跑线上。抱死一个框架好几年，脱离了框架啥都干不了的程序员实在太多了。事实上，这样的人不能驾驭技术，反而是被技术给奴役了。<br>同样是自行车，为什么山地车比公路车更普及更流行？除了皮实耐用价格低外，主要是因为它的通过性好，什么泥地沙地都不在话下，上下马路牙子跟玩一样。而公路车呢？只能老老实实地跑在平路上。<br>公司不是学校<br>面对这些因为「想学点技术」而换工作的求职者，评价他们「不思进取」貌似不太合适。但显然他们的思维模式还是被学校洗脑的那一套，没能真正地融入社会。也许他们认为，学习就是要由老师手把手带着，而自己之所以学不到技术，就是因为没遇到一个好leader，能替自己设计好成长路线，指出所有重难点，提供各种参考资料……<br>在中国传统文化里，不管是匠人还是武师，收徒都要找毫无根基的幼童。这一方面是为了保持师父的绝对权威，方便贯彻落实教学；另一方面是为了尽量延长学徒期，以考察徒弟的品性。拜师之后，徒弟便跟随师父一起生活，经过数年的言传身教，这才得以出师。<br>师父收徒的核心诉求，是「传承」自己的技艺和名声，希望徒弟日后能做出一番成就来光耀师门。这就要求徒弟流动性低、忠诚度高、归属感强。与其说是收徒，还不如说是在挑儿子，所以有句俗话叫作「一日为师，终身为父」。<br>然而公司是盈利性的商业组织，不是学校，更不是新手训练营。公司招聘员工的核心诉求，是生产出实实在在、对得起薪水的价值，而不是传承技艺。公司希望员工入职前就具备工作的能力，至少在经过短暂的培训和指导后就能独立开展工作，正所谓「能干就干，干不了走人」。<br>一般情况下，为了使新人尽快进入工作状态，公司会安排一位老员工来做一段时间的导师。但导师只有为你解惑的义务，却没有教你技术的责任。 因为导师自己手里还有做不完的工作，带新人又没什么利益可图，凭什么为你提供私人教练级的服务？能有耐心听完你的问题，指点一下方向，就已经很不错了。<br>学习是自己的事，没有人能替你去做。这就跟吃饭一样，谁真的关心你吃没吃、饱没饱？就算你的亲人再怎么关心你，也不能替你去吃。我们都知道，人不吃饭肯定是要饿死的，那你为什么不去给自己找吃的，却在埋怨没有人给你嘴里喂食呢？<br>为什么你学不到技术？<br>很多人在学习之路上已经饱尝了痛苦的滋味，因此在离开学校之后。他们不到万不得已，是决然不会去学习的。你不妨回顾一下，从参加工作以来到现在，自己哪段时间里学习最认真，进步最明显？<br>如果不出意外的话，应该就是你找到的第一份工作的试用期。因为不想失去自己通过努力争取到的工作机会，所以你不得不逼自己打起十二份精神来学习，结果居然以自己都无法想象的速度掌握了工作必备的知识和技能。<br>然而，大多数人在自己的能力满足当前工作的要求之后，就丧失了学习的动力。下班之后要追剧，要玩游戏，要打球，要谈恋爱……为啥我要学习？不学又不会失业！学这个有啥用？谁知道用得上用不上？等要用的时候再学呗！<br>其实， 学不到技术最核心的原因只有一个：动机不足。至于环境条件，只是影响学习效果的因素之一，但绝对不是最重要的因素。在一个恶劣的环境里选择放弃学习的人，不可能到了一个优越的环境里就会去主动学习，因为在他内心深处对学习是抗拒的。<br>难道说换上了Macbook Pro和4k显示器，坐在数千元的人体工学座椅上，下班后就会有兴趣看框架源码了吗？看电影、打游戏不是更舒服一些？<br>在我看来，学习力的源泉就是好奇心，也就是对新知识的渴求，以及对探索未知的冲动。我们的大脑是「用进废退」的，如果不定期给它输送新鲜的知识营养，它就会逐渐退化。有学习力的人一段时间不看书，不折腾点新玩意，大脑真的是会「饿」的。<br>程序员该怎么学习技术？<br>有的求职者觉得自己没学到技术，是因为公司不给机会，或者缺乏条件：<br>「上次的H5让小王做了，这次的微信小程序又给了小李……完全没我什么事啊！」<br>「公司最大一张表才10W数据，根本用不着分库分表啊！」<br>……<br>学习技术最有效的方式是阅读、实践和交流。公司没给你安排这方面的工作，那你自己都做了些什么呢？八小时之外的时间都用在哪了？有没有读源码？有没有看原版书？有没有泡技术社区？有没有尝试最新流行的技术？有没有尝试把它们用在公司的项目上？有没有主动去接触行业里使用这些技术的团队和大牛？<br>「看文档」其实是最快的学习方法。对于自己工作中常用到的技术，抽时间把官方文档通读一遍（其实篇幅都不大），绝对收获满满。没事的时候多翻翻自己使用的框架/系统/平台的API，看看有哪些自己不知道或者没用过的功能，想想这个功能可以用来做什么，能不能解决现存的问题，或者优化当下的解决方案。<br>如果你是前端工程师，通读HTTP协议和ECMAScript标准，就能秒杀95%的同行，不开玩笑。<br>「读源码」是深入学习开源技术的唯一途径。只有理解了某个功能在底层是如何实现的，你才能真正把握它更适合用来做什么，不能用来做什么。正如不明显汽车的构造和原理，我们也能把车开好。而如果多少知道一点，开起来就会更得心应手。当车出现问题时，也不至于完全束手无策，只能蹲在路边等待救援。<br>你一个框架用了N年了，却连一行源码都没读过？如果它是你女朋友，估计早该分手了。<br>「折腾」是学习任何技术的必经之路。在有保护的环境下进行大量的试错，是最高效的学习方法。现在虚拟机技术已经那么成熟，VPS也很便宜，你为什么不分分钟弄一个，然后在上面花式作死呢？<br>听说过无数次 rm -rf / 的事故，可你居然一次都没试过？知道输出啥样子么？<br>公司给你提供的最有价值的东西，就是实战的机会。 你所学习的技术，最终需要通过工作来变现。你有机会接触到真实的数据，了解真实的用户，观察真实系统是怎样运转的，积累真实的经验……<br>然而，所谓的机会，只属于已经提前准备好的人。 不要等到工作都安排到你身上了再去学习。公司不是你的试验田，你也不该拿用户当小白鼠。公司不给你机会，那只说明你还没有准备好。<br>后话<br>「吾生也有涯，而知也无涯 。以有涯随无涯，殆已！」*——《庄子·内篇·养生主第三》<br>技术世界就如同一片汪洋大海，细分领域真是多如牛毛。我们只是站在其中一个小岛上，怎么确定自己该朝哪个方向进发呢？<br>学习技术不外乎以下两个方向：<br>1、广度：整个使用链条由哪些环节构成？每个环节的作用是什么？都有哪些类似的可替代方案？它们之间有什么区别？各自优劣点是什么？……<br>2、深度：这个「技术 / 产品」的本质是什么？都能做什么？运作原理是什么？底层是如何实现的？可以做怎样的改进？……<br>不管你在做什么工作，都应该先把自己每天都要用的核心技术做到一定深度，再去拓展广度。 「什么都知道一点，但都不甚了解」是最可怕的，它会让你误以为自己已经很NB了。<br>学习，是一辈子的事。<p></p>"},{"title":"RPC框架学习","date":"2017-10-12T02:49:28.000Z","_content":"","source":"_posts/23RPC框架学习.md","raw":"---\ntitle: RPC框架学习\ndate: 2017-10-12 10:49:28\ntags: RPC\ncategories: \"RPC\"\n---\n","slug":"23RPC框架学习","published":1,"updated":"2017-10-12T08:16:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tca5000za7xwu5cvduxr","content":"","excerpt":"","more":""},{"title":"大型网站系统与Java中间件实战","date":"2017-10-12T06:13:46.000Z","_content":"","source":"_posts/24大型网站系统与Java中间件实战.md","raw":"---\ntitle: 大型网站系统与Java中间件实战\ndate: 2017-10-12 14:13:46\ntags: Book\ncategories: \"Book\"\n---\n","slug":"24大型网站系统与Java中间件实战","published":1,"updated":"2017-10-12T08:16:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tca80014a7xwqgsqcu1h","content":"","excerpt":"","more":""},{"title":"史上最全的Java新手问题汇总","date":"2017-09-30T03:08:18.000Z","_content":"> Java是目前最流行的编程语言之一——它可以用来编写Windows程序或者是Web应用，移动应用，网络程序，消费电子产品，机顶盒设备，它无处不在。\n有超过30亿的设备是运行在Java之上的。根据Oracle的统计数据，光是使用中的Java Card就有有50亿。超过900万程序员选择使用Java进行开发，它是最受开发人员欢迎的语言，同时也是最流行的开发平台。\n本文为那些准Java程序员们准备了一系列广为流传的Java最佳编程实践\n<!--more-->\n#### 优先返回空集合而非null\n如果程序要返回一个不包含任何值的集合，确保返回的是空集合而不是null。这能节省大量的”if else”检查。\n```\npublic class getLocationName {\n    return (null==cityName ? \"\": cityName);\n}\n```\n#### 谨慎操作字符串\n如果两个字符串在for循环中使用+操作符进行拼接，那么每次循环都会产生一个新的字符串对象。这不仅浪费内存空间同时还会影响性能。类似的，如果初始化字符串对象，尽量不要使用构造方法，而应该直接初始化。比方说：\n```\n//Slower Instantiation\nString bad = new String(\"Yet another string object\");\n//Faster Instantiation\nString good = \"Yet another string object\"\n避免无用对象\n```\n创建对象是Java中最昂贵的操作之一。因此最好在有需要的时候再进行对象的创建/初始化。如下：\n```\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Employees {\n\n    private List Employees;\n\n    public List getEmployees() {\n\n        //initialize only when required\n        if(null == Employees) {\n            Employees = new ArrayList();\n        }\n        return Employees;\n    }\n}\n```\n#### 数组与ArrayList之争\n\n开发人员经常会发现很难在数组和ArrayList间做选择。它们二者互有优劣。如何选择应该视情况而定。\n\nimport java.util.ArrayList;\n\npublic class arrayVsArrayList {\n\n    public static void main(String[] args) {\n        int[] myArray = new int[6];\n        myArray[7]= 10; // ArraysOutOfBoundException\n\n        //Declaration of ArrayList. Add and Remove of elements is easy.\n        ArrayList<Integer> myArrayList = new ArrayList<>();\n        myArrayList.add(1);\n        myArrayList.add(2);\n        myArrayList.add(3);\n        myArrayList.add(4);\n        myArrayList.add(5);\n        myArrayList.remove(0);\n\n        for(int i = 0; i < myArrayList.size(); i++) {\n        System.out.println(\"Element: \" + myArrayList.get(i));\n        }\n\n        //Multi-dimensional Array\n        int[][][] multiArray = new int [3][3][3];\n    }\n}\n数组是定长的，而ArrayList是变长的。由于数组长度是固定的，因此在声明数组时就已经分配好内存了。而数组的操作则会更快一些。另一方面，如果我们不知道数据的大小，那么过多的数据便会导致ArrayOutOfBoundException，而少了又会浪费存储空间。\nArrayList在增删元素方面要比数组简单。\n数组可以是多维的，但ArrayList只能是一维的。\ntry块的finally块没有被执行\n看下下面这段代码：\n\npublic class shutDownHooksDemo {\n    public static void main(String[] args) {\n        for(int i=0;i<5;i++)\n        {\n            try {\n                if(i==4) {\n                    System.out.println(\"Inside Try Block.Exiting without executing Finally block.\");\n                    System.exit(0);\n                }\n            }\n            finally {\n                System.out.println(\"Inside Finally Block.\");\n            }\n        }\n    }\n}\n从代码来看，貌似finally块中的println语句应该会被执行5次。但当程序运行后，你会发现finally块只执行了4次。第5次迭代的时候会触发exit函数的调用，于是这第5次的finally便永远也触发不到了。原因便是——System.exit会挂起所有线程的执行，包括当前线程。即便是try语句后的finally块，只要是执行了exit，便也无力回天了。\n\n在调用System.exit时，JVM会在关闭前执行两个结束任务：\n\n首先，它会执行完所有通过Runtime.addShutdownHook注册进来的终止的钩子程序。这一点很关键，因为它会释放JVM外部的资源。\n\n接下来的便是Finalizer了。可能是System.runFinalizersOnExit也可能是Runtime.runFinalizersOnExit。finalizer的使用已经被废弃有很长一段时间了。finalizer可以在存活对象上进行调用，即便是这些对象仍在被其它线程所使用。而这会导致不可预期的结果甚至是死锁。\n\npublic class shutDownHooksDemo {\n\n    public static void main(String[] args) {\n            for(int i=0;i<5;i++)\n            {\n                    final int final_i = i;\n                    try {\n                            Runtime.getRuntime().addShutdownHook(\n                                            new Thread() {\n                                            public void run() {\n                                            if(final_i==4) {\n                                            System.out.println(\"Inside Try Block.Exiting without executing Finally block.\");\n                                            System.exit(0);\n                                            }\n                                            }\n                                            });\n                    }\n                    finally {\n                            System.out.println(\"Inside Finally Block.\");\n                    }\n\n            }\n    }\n}\n判断奇数\n\n看下这几行代码，看看它们是否能用来准确地判断一个数是奇数？\n\npublic boolean oddOrNot(int num) {\n    return num % 2 == 1;\n}\n看似是对的，但是每执行四便会有一个错误的结果（用数据说话）。考虑到负奇数的情况，它除以2的结果就不会是1。因此，返回值是false，而这样是不对的。\n\n代码可以修改成这样：\n\npublic boolean oddOrNot(int num) {\n    return (num & 1) != 0;\n}\n这么写不光是负奇数的问题解决了，并且还是经过充分优化过的。因为算术运算和逻辑运行要比乘除运算更高效，计算的结果也会更快。\n\n单引号与双引号的区别\n\npublic class Haha {\n    public static void main(String args[]) {\n    System.out.print(\"H\" + \"a\");\n    System.out.print('H' + 'a');\n    }\n}\n看起来这段代码会返回”Haha”,但实际返回的是Ha169。原因就是用了双引号的时候，字符会被当作字符串处理，而如果是单引号的话，字符值会通过一个叫做基础类型拓宽的操作来转换成整型值。然后再将值相加得到169。\n\n一些防止内存泄露的小技巧\n\n内存泄露会导致软件的性能降级。由于Java是自动管理内存的，因此开发人员并没有太多办法介入。不过还是有一些方法能够用来防止内存泄露的。\n\n查询完数据后立即释放数据库连接\n尽可能使用finally块\n释放静态变量中的实例\n避免死锁\n死锁出现的原因有很多。避免死锁不是一句话就能解决的。通常来说，当某个同步对象在等待另一个同步对象所拥有的资源上的锁时，便会产生死锁。\n\n试着运行下下面的程序。它会告诉你什么是死锁。这个死锁是由于两个线程都在等待对方所拥有的资源，因此会产生死锁。它们会一直等待，没有谁会先放手。\n\npublic class DeadlockDemo {\n   public static Object addLock = new Object();\n   public static Object subLock = new Object();\n\n   public static void main(String args[]) {\n\n      MyAdditionThread add = new MyAdditionThread();\n      MySubtractionThread sub = new MySubtractionThread();\n      add.start();\n      sub.start();\n   }\nprivate static class MyAdditionThread extends Thread {\n      public void run() {\n         synchronized (addLock) {\n        int a = 10, b = 3;\n        int c = a + b;\n            System.out.println(\"Addition Thread: \" + c);\n            System.out.println(\"Holding First Lock...\");\n            try { Thread.sleep(10); }\n            catch (InterruptedException e) {}\n            System.out.println(\"Addition Thread: Waiting for AddLock...\");\n            synchronized (subLock) {\n               System.out.println(\"Threads: Holding Add and Sub Locks...\");\n            }\n         }\n      }\n   }\n   private static class MySubtractionThread extends Thread {\n      public void run() {\n         synchronized (subLock) {\n        int a = 10, b = 3;\n        int c = a - b;\n            System.out.println(\"Subtraction Thread: \" + c);\n            System.out.println(\"Holding Second Lock...\");\n            try { Thread.sleep(10); }\n            catch (InterruptedException e) {}\n            System.out.println(\"Subtraction  Thread: Waiting for SubLock...\");\n            synchronized (addLock) {\n               System.out.println(\"Threads: Holding Add and Sub Locks...\");\n            }\n         }\n      }\n   }\n}\n输出：\n\nAddition Thread: 13\nSubtraction Thread: 7\nHolding First Lock...\nHolding Second Lock...\nAddition Thread: Waiting for AddLock...\nSubtraction  Thread: Waiting for SubLock...\n但如果调用的顺序变一下的话，死锁的问题就解决了。\n\npublic class DeadlockSolutionDemo {\n   public static Object addLock = new Object();\n   public static Object subLock = new Object();\n\n   public static void main(String args[]) {\n\n      MyAdditionThread add = new MyAdditionThread();\n      MySubtractionThread sub = new MySubtractionThread();\n      add.start();\n      sub.start();\n   }\n\nprivate static class MyAdditionThread extends Thread {\n      public void run() {\n         synchronized (addLock) {\n        int a = 10, b = 3;\n        int c = a + b;\n            System.out.println(\"Addition Thread: \" + c);\n            System.out.println(\"Holding First Lock...\");\n            try { Thread.sleep(10); }\n            catch (InterruptedException e) {}\n            System.out.println(\"Addition Thread: Waiting for AddLock...\");\n            synchronized (subLock) {\n               System.out.println(\"Threads: Holding Add and Sub Locks...\");\n            }\n         }\n      }\n   }\n\n   private static class MySubtractionThread extends Thread {\n      public void run() {\n         synchronized (addLock) {\n        int a = 10, b = 3;\n        int c = a - b;\n            System.out.println(\"Subtraction Thread: \" + c);\n            System.out.println(\"Holding Second Lock...\");\n            try { Thread.sleep(10); }\n            catch (InterruptedException e) {}\n            System.out.println(\"Subtraction  Thread: Waiting for SubLock...\");\n            synchronized (subLock) {\n               System.out.println(\"Threads: Holding Add and Sub Locks...\");\n            }\n         }\n      }\n   }\n}\n输出：\n\nAddition Thread: 13\nHolding First Lock...\nAddition Thread: Waiting for AddLock...\nThreads: Holding Add and Sub Locks...\nSubtraction Thread: 7\nHolding Second Lock...\nSubtraction  Thread: Waiting for SubLock...\nThreads: Holding Add and Sub Locks...\n替Java省点内存\n\n某些Java程序是CPU密集型的，但它们会需要大量的内存。这类程序通常运行得很缓慢，因为它们对内存的需求很大。为了能提升这类应用的性能，可得给它们多留点内存。因此，假设我们有一台拥有10G内存的Tomcat服务器。在这台机器上，我们可以用如下的这条命令来分配内存:\n\nexport JAVA_OPTS=\"$JAVA_OPTS -Xms5000m -Xmx6000m -XX:PermSize=1024m -XX:MaxPermSize=2048m\"\nXms = 最小内存分配\nXmx = 最大内存分配\nXX:PermSize = JVM启动时的初始大小\nXX:MaxPermSize = JVM启动后可分配的最大空间\n如何计算Java中操作的耗时\n在Java中进行操作计时有两个标准的方法：System.currentTimeMillis()和System.nanoTime()。问题就在于，什么情况下该用哪个。从本质上来讲，他们的作用都是一样的，但有以下几点不同：\n\nSystem.currentTimeMillis()的精度在千分之一秒到千分之15秒之间（取决于系统）而System.nanoTime()则能到纳秒级。\nSystem.currentTimeMillis读操作耗时在数个CPU时钟左右。而System.nanoTime()则需要上百个。\nSystem.currentTimeMillis对应的是绝对时间（1970年1 月1日所经历的毫秒数），而System.nanoTime()则不与任何时间点相关。\nFloat还是double\n数据类型\t所用字节\t有效位数\nfloat\t4\t7\ndouble\t8\t15\n在对精度要求高的场景下，double类型相对float要更流行一些，理由如下：\n\n大多数处理器在处理float和double上所需的时间都是差不多的。而计算时间一样的前提下，double类型却能提供更高的精度。\n\n幂运算\n\nJava是通过异或操作来进行幂运算的。Java对于幂运算有两种处理方式：\n\n乘积：\n\ndouble square = double a * double a;                           // Optimized\ndouble cube = double a * double a * double a;                   // Non-optimized\ndouble cube = double a * double square;                       // Optimized\ndouble quad = double a * double a * double a * double a;          // Non-optimized\ndouble quad = double square * double square;                  // Optimized\npow方法：在无法使用乘积的情况下可以使用pow方法。\n\ndouble cube = Math.pow(base, exponent);\n不到万不得已不要使用Math.pow。比方说，当指数是小数的时候。因为Math.pow要比乘积慢300-600倍左右。\n\n如何处理空指针异常\n\n空指针异常是Java中很常见的异常。当你尝试调用一个null对象上的方法时便会抛出这个异常。比如：\n\nint noOfStudents = school.listStudents().count;\n在上述例子中，school为空或者listStudents()为空都可能会抛出了NullPointerException。因此最好检查下对象是否为空以避免类似情况。\n\nprivate int getListOfStudents(File[] files) {\n      if (files == null)\n        throw new NullPointerException(\"File list cannot be null\");\n    }\nJSON编码\n\nJSON是数据存储及传输的一种协议。与XML相比，它更易于使用。由于它非常轻量级以及自身的一些特性，现在JSON在网络上已经是越来越流行了。常见的数据结构都可以编码成JSON然后在各个网页间自由地传输。不过在开始编码前，你得先安装一个JSON解析器。在下面的例子中，我们将使用json.simple库来完成这项工作 (https://code.google.com/p/json-simple/)。\n\n下面是编码成JSON串的一个简单的例子。\n\nimport org.json.simple.JSONObject;\nimport org.json.simple.JSONArray;\n\npublic class JsonEncodeDemo {\n\n    public static void main(String[] args) {\n\n        JSONObject obj = new JSONObject();\n        obj.put(\"Novel Name\", \"Godaan\");\n        obj.put(\"Author\", \"Munshi Premchand\");\n\n        JSONArray novelDetails = new JSONArray();\n        novelDetails.add(\"Language: Hindi\");\n        novelDetails.add(\"Year of Publication: 1936\");\n        novelDetails.add(\"Publisher: Lokmanya Press\");\n\n        obj.put(\"Novel Details\", novelDetails);\n\n        System.out.print(obj);\n    }\n}\n输出：\n\n{\"Novel Name\":\"Godaan\",\"Novel Details\":[\"Language: Hindi\",\"Year of Publication: 1936\",\"Publisher: Lokmanya Press\"],\"Author\":\"Munshi Premchand\"}\nJSON解析\n\n开发人员要想解析JSON串，首先你得知道它的格式。下面例子有助于你来理解这一点：\n\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.json.simple.JSONArray;\nimport org.json.simple.JSONObject;\nimport org.json.simple.parser.JSONParser;\nimport org.json.simple.parser.ParseException;\n\npublic class JsonParseTest {\n\n    private static final String filePath = \"//home//user//Documents//jsonDemoFile.json\";\n\n    public static void main(String[] args) {\n\n        try {\n            // read the json file\n            FileReader reader = new FileReader(filePath);\n            JSONParser jsonParser = new JSONParser();\n            JSONObject jsonObject = (JSONObject)jsonParser.parse(reader);\n\n            // get a number from the JSON object\n            Long id =  (Long) jsonObject.get(\"id\");\n            System.out.println(\"The id is: \" + id);\n\n            // get a String from the JSON object\n            String   type = (String) jsonObject.get(\"type\");\n            System.out.println(\"The type is: \" + type);\n\n            // get a String from the JSON object\n            String   name = (String) jsonObject.get(\"name\");\n            System.out.println(\"The name is: \" + name);\n\n            // get a number from the JSON object\n            Double ppu =  (Double) jsonObject.get(\"ppu\");\n            System.out.println(\"The PPU is: \" + ppu);\n\n            // get an array from the JSON object\n            System.out.println(\"Batters:\");\n            JSONArray batterArray= (JSONArray) jsonObject.get(\"batters\");\n            Iterator i = batterArray.iterator();\n            // take each value from the json array separately\n            while (i.hasNext()) {\n                JSONObject innerObj = (JSONObject) i.next();\n                System.out.println(\"ID \"+ innerObj.get(\"id\") +\n                        \" type \" + innerObj.get(\"type\"));\n            }\n\n            // get an array from the JSON object\n            System.out.println(\"Topping:\");\n            JSONArray toppingArray= (JSONArray) jsonObject.get(\"topping\");\n            Iterator j = toppingArray.iterator();\n            // take each value from the json array separately\n            while (j.hasNext()) {\n                JSONObject innerObj = (JSONObject) j.next();\n                System.out.println(\"ID \"+ innerObj.get(\"id\") +\n                        \" type \" + innerObj.get(\"type\"));\n            }\n\n        } catch (FileNotFoundException ex) {\n            ex.printStackTrace();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        } catch (ParseException ex) {\n            ex.printStackTrace();\n        } catch (NullPointerException ex) {\n            ex.printStackTrace();\n        }\n\n    }\n\n}\njsonDemoFile.json\n\n{\n    \"id\": 0001,\n    \"type\": \"donut\",\n    \"name\": \"Cake\",\n    \"ppu\": 0.55,\n    \"batters\":\n        [\n            { \"id\": 1001, \"type\": \"Regular\" },\n            { \"id\": 1002, \"type\": \"Chocolate\" },\n            { \"id\": 1003, \"type\": \"Blueberry\" },\n            { \"id\": 1004, \"type\": \"Devil's Food\" }\n        ],\n    \"topping\":\n        [\n            { \"id\": 5001, \"type\": \"None\" },\n            { \"id\": 5002, \"type\": \"Glazed\" },\n            { \"id\": 5005, \"type\": \"Sugar\" },\n            { \"id\": 5007, \"type\": \"Powdered Sugar\" },\n            { \"id\": 5006, \"type\": \"Chocolate with Sprinkles\" },\n            { \"id\": 5003, \"type\": \"Chocolate\" },\n            { \"id\": 5004, \"type\": \"Maple\" }\n        ]\n}\nThe id is: 1\nThe type is: donut\nThe name is: Cake\nThe PPU is: 0.55\nBatters:\nID 1001 type Regular\nID 1002 type Chocolate\nID 1003 type Blueberry\nID 1004 type Devil's Food\nTopping:\nID 5001 type None\nID 5002 type Glazed\nID 5005 type Sugar\nID 5007 type Powdered Sugar\nID 5006 type Chocolate with Sprinkles\nID 5003 type Chocolate\nID 5004 type Maple\n简单字符串查找\n\nJava提供了一个库函数叫做indexOf()。这个方法可以用在String对象上，它返回的是要查找的字符串所在的位置序号。如果查找不到则会返回-1。\n\n列出目录下的文件\n\n你可以用下面的代码来列出目录下的文件。这个程序会遍历某个目录下的所有子目录及文件，并存储到一个数组里，然后通过遍历数组来列出所有文件。\n\nimport java.io.*;\n\npublic class ListContents {\n    public static void main(String[] args) {\n        File file = new File(\"//home//user//Documents/\");\n        String[] files = file.list();\n\n        System.out.println(\"Listing contents of \" + file.getPath());\n        for(int i=0 ; i < files.length ; i++)\n        {\n            System.out.println(files[i]);\n        }\n    }\n}\n一个简单的IO程序\n\nJava提供了FileInputStream以及FileOutputStream类来进行文件的读写操作。FileInputStream的构造方法会接收输入文件的路径作为入参然后创建出一个文件的输入流。同样的，FileOutputStream的构造方法也会接收一个文件路径作为入参然后创建出文件的输出流。在处理完文件之后，一个很重要的操作就是要记得”close”掉这些流。\n\nimport java.io.*;\n\npublic class myIODemo {\n    public static void main(String args[]) throws IOException {\n        FileInputStream in = null;\n        FileOutputStream out = null;\n\n        try {\n            in = new FileInputStream(\"//home//user//Documents//InputFile.txt\");\n            out = new FileOutputStream(\"//home//user//Documents//OutputFile.txt\");\n\n            int c;\n            while((c = in.read()) != -1) {\n                out.write(c);\n            }\n        } finally {\n            if(in != null) {\n                in.close();\n            }\n            if(out != null) {\n                out.close();\n            }\n        }\n    }\n}\n在Java中执行某个shell命令\n\nJava提供了Runtime类来执行shell命令。由于这些是外部的命令，因此异常处理就显得异常重要。在下面的例子中，我们将通过一个简单的例子来演示一下。我们会在shell命令行中打开一个pdf文件。\n\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\npublic class ShellCommandExec {\n\n    public static void main(String[] args) {\n        String gnomeOpenCommand = \"gnome-open //home//user//Documents//MyDoc.pdf\";\n\n        try {\n            Runtime rt = Runtime.getRuntime();\n            Process processObj = rt.exec(gnomeOpenCommand);\n\n            InputStream stdin = processObj.getErrorStream();\n            InputStreamReader isr = new InputStreamReader(stdin);\n            BufferedReader br = new BufferedReader(isr);\n\n            String myoutput = \"\";\n\n            while ((myoutput=br.readLine()) != null) {\n                myoutput = myoutput+\"/n\";\n            }\n            System.out.println(myoutput);\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n使用正则\n\n正则表达式的结构摘录如下（来源: Oracle官网）\n\n字符\n\nx\t字符x\n/\t反斜杠\n/0n\t8进制值为0n的字符(0<=n<=7)\n/0nn\n/0mnn\t8进制值为0mnn的字符(0 <= m <= 3, 0<=n<=7)\n/xhh\t16进制值为0xhh的字符\n/uhhhh\t16进制值为0xhhhh的字符\n/x{h…h}\t16进制值为0xh…h的字符(Character.MINCODEPOINT <= 0xh…h <= Character.MAXCODEPOINT)\n/t\t制表符(‘/u0009′)\n/n\t换行符(‘/u000A’)\n/r\t回车(‘/u000D’)\n/f\t分页符(‘/u000C’)\n/a\t警告符(‘/u0007′)\n/e\tESC(‘/u001B’)\n/cx\tctrl+x\n字符分类\n\n[abc]\ta, b或c\n[^abc]\tabc以外的任意字符\n[a-zA-Z]\ta到z以及A到Z\n[a-d[m-p]]\ta到d或者m到p[a-dm-p]则是取并集\n[a-z&&[def]]\td,e或f(交集)\n[ad-z]\n[a-z&&[^bc]]\ta到z但不包括b和c\n[a-z&&[^m-p]]\ta到z但不包括mp:也就是[a-lq-z]\n预定义字符\n\n.\t任意字符，有可能包括换行符\n/d\t0到9的数字\n/D\t0到9以外的字符\n/s\t空格符[ /t/n/x0B/f/r]\n/S\t非空格符[^/s]\n/w\t字母[a-zA-Z_0-9]\n/W\t非字母[^/w]\n边界匹配\n\n^\t行首\n$\t行末\n/b\t单词边界\n/A\t输入的起始位置\n/G\t前一个匹配的末尾\n/Z\t输入的结束位置，仅用于最后的结束符\n/z\t输入的结束位置\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RegexMatches\n{\n    private static String pattern =  \"^[_A-Za-z0-9-]+(//.[_A-Za-z0-9-]+)*@[A-Za-z0-9]+(//.[A-Za-z0-9]+)*(//.[A-Za-z]{2,})$\";\n    private static Pattern mypattern = Pattern.compile(pattern);\n\n    public static void main( String args[] ){\n\n        String valEmail1 = \"testemail@domain.com\";\n        String invalEmail1 = \"....@domain.com\";\n        String invalEmail2 = \".$$%%@domain.com\";\n        String valEmail2 = \"test.email@domain.com\";\n\n        System.out.println(\"Is Email ID1 valid? \"+validateEMailID(valEmail1));\n        System.out.println(\"Is Email ID1 valid? \"+validateEMailID(invalEmail1));\n        System.out.println(\"Is Email ID1 valid? \"+validateEMailID(invalEmail2));\n        System.out.println(\"Is Email ID1 valid? \"+validateEMailID(valEmail2));\n\n    }\n\n    public static boolean validateEMailID(String emailID) {\n        Matcher mtch = mypattern.matcher(emailID);\n        if(mtch.matches()){\n            return true;\n        }\n        return false;\n    }\n}\nJava Swing的简单示例\n\n有了Java的swing，你便可以编写GUI应用了。Java所提供的javax包中就包含了swing。使用swing来编写GUI程序首先需要继承下JFrame。然后在里面添加Box，然后便可以往里面添加诸如按钮，多选按钮，文本框等控件了。这些Box是放在Container的最外层的。\n\nimport java.awt.*;\nimport javax.swing.*;\n\npublic class SwingsDemo extends JFrame\n{\n    public SwingsDemo()\n    {\n        String path = \"//home//user//Documents//images\";\n        Container contentPane = getContentPane();\n        contentPane.setLayout(new FlowLayout());\n\n        Box myHorizontalBox = Box. createHorizontalBox();\n        Box myVerticleBox = Box. createVerticalBox();\n\n        myHorizontalBox.add(new JButton(\"My Button 1\"));\n        myHorizontalBox.add(new JButton(\"My Button 2\"));\n        myHorizontalBox.add(new JButton(\"My Button 3\"));\n\n        myVerticleBox.add(new JButton(new ImageIcon(path + \"//Image1.jpg\")));\n        myVerticleBox.add(new JButton(new ImageIcon(path + \"//Image2.jpg\")));\n        myVerticleBox.add(new JButton(new ImageIcon(path + \"//Image3.jpg\")));\n\n        contentPane.add(myHorizontalBox);\n        contentPane.add(myVerticleBox);\n\n        pack();\n        setVisible(true);\n    }\n\n    public static void main(String args[]) {\n        new SwingsDemo();\n    }\n}\n使用Java播放音频\n\n在Java中，播放音频是一个很常见的需求，尤其是在游戏开发里面。\n\n下面这个DEMO演示了如何在Java中播放音频。\n\nimport java.io.*;\nimport java.net.URL;\nimport javax.sound.sampled.*;\nimport javax.swing.*;\n\n// To play sound using Clip, the process need to be alive.\n// Hence, we use a Swing application.\npublic class playSoundDemo extends JFrame {\n\n   // Constructor\n   public playSoundDemo() {\n      this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n      this.setTitle(\"Play Sound Demo\");\n      this.setSize(300, 200);\n      this.setVisible(true);\n\n      try {\n         URL url = this.getClass().getResource(\"MyAudio.wav\");\n         AudioInputStream audioIn = AudioSystem.getAudioInputStream(url);\n         Clip clip = AudioSystem.getClip();\n         clip.open(audioIn);\n         clip.start();\n      } catch (UnsupportedAudioFileException e) {\n         e.printStackTrace();\n      } catch (IOException e) {\n         e.printStackTrace();\n      } catch (LineUnavailableException e) {\n         e.printStackTrace();\n      }\n   }\n\n   public static void main(String[] args) {\n      new playSoundDemo();\n   }\n}\n导出PDF文件\n\n将表格导出成pdf也是一个比较常见的需求。通过itextpdf，导出pdf也不是什么难事。\n\nimport java.io.FileOutputStream;\nimport com.itextpdf.text.Document;\nimport com.itextpdf.text.Paragraph;\nimport com.itextpdf.text.pdf.PdfPCell;\nimport com.itextpdf.text.pdf.PdfPTable;\nimport com.itextpdf.text.pdf.PdfWriter;\n\npublic class DrawPdf {\n\n      public static void main(String[] args) throws Exception {\n        Document document = new Document();\n        PdfWriter.getInstance(document, new FileOutputStream(\"Employee.pdf\"));\n        document.open();\n\n        Paragraph para = new Paragraph(\"Employee Table\");\n        para.setSpacingAfter(20);\n        document.add(para);\n\n        PdfPTable table = new PdfPTable(3);\n        PdfPCell cell = new PdfPCell(new Paragraph(\"First Name\"));\n\n        table.addCell(cell);\n        table.addCell(\"Last Name\");\n        table.addCell(\"Gender\");\n        table.addCell(\"Ram\");\n        table.addCell(\"Kumar\");\n        table.addCell(\"Male\");\n        table.addCell(\"Lakshmi\");\n        table.addCell(\"Devi\");\n        table.addCell(\"Female\");\n\n        document.add(table);\n\n        document.close();\n      }\n    }\n邮件发送\n\n在Java中发送邮件也很简单。你只需装一下Java Mail这个jar包，放到你的类路径里即可。在下面的代码中，我们设置了几个基础属性，然后便可以发送邮件了：\n\nimport java.util.*;\nimport javax.mail.*;\nimport javax.mail.internet.*;\n\npublic class SendEmail\n{\n    public static void main(String [] args)\n    {\n        String to = \"recipient@gmail.com\";\n        String from = \"sender@gmail.com\";\n        String host = \"localhost\";\n\n        Properties properties = System.getProperties();\n        properties.setProperty(\"mail.smtp.host\", host);\n        Session session = Session.getDefaultInstance(properties);\n\n        try{\n            MimeMessage message = new MimeMessage(session);\n            message.setFrom(new InternetAddress(from));\n\n            message.addRecipient(Message.RecipientType.TO,new InternetAddress(to));\n\n            message.setSubject(\"My Email Subject\");\n            message.setText(\"My Message Body\");\n            Transport.send(message);\n            System.out.println(\"Sent successfully!\");\n        }\n        catch (MessagingException ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n计算时间\n\n许多程序都需要精确的时间计量。Java提供了一个System的静态方法来支持这一功能：\n\ncurrentTimeMillis()：返回当前时间自新纪元时间以来的毫秒值，long类型。\n\nlong startTime = System.currentTimeMillis();\nlong estimatedTime = System.currentTimeMillis() - startTime;\nnanoTime()：返回系统计时器当前的精确时间，纳秒值，这也是long类型。nanoTime()主要是用于计算相对时间而非绝对时间。\n\nlong startTime = System.nanoTime();\nlong estimatedTime = System.nanoTime() - startTime;\n图片缩放\n\n图片缩放可以通过AffineTransform来完成。首先要生成一个输入图片的图片缓冲，然后通过它来渲染出缩放后的图片。\n\nimport java.awt.Graphics2D;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport javax.imageio.ImageIO;\n\npublic class RescaleImage {\n  public static void main(String[] args) throws Exception {\n    BufferedImage imgSource = ImageIO.read(new File(\"images//Image3.jpg\"));\n    BufferedImage imgDestination = new BufferedImage(100, 100, BufferedImage.TYPE_INT_RGB);\n    Graphics2D g = imgDestination.createGraphics();\n    AffineTransform affinetransformation = AffineTransform.getScaleInstance(2, 2);\n    g.drawRenderedImage(imgSource, affinetransformation);\n    ImageIO.write(imgDestination, \"JPG\", new File(\"outImage.jpg\"));\n  }\n}\n捕获鼠标动作\n\n实现了MouseMotionListner接口后，便可以捕获鼠标事件了。 当鼠标进入到某个特定区域时便会触发MouseMoved事件，你便能捕获到这个移动的动作了。通过一个例子来看下：\n\nimport java.awt.event.*;\nimport javax.swing.*;\n\npublic class MouseCaptureDemo extends JFrame implements MouseMotionListener\n{\n    public JLabel mouseHoverStatus;\n\n    public static void main(String args[])\n    {\n        new MouseCaptureDemo();\n    }\n\n    MouseCaptureDemo()\n    {\n        setSize(500, 500);\n        setTitle(\"Frame displaying Coordinates of Mouse Motion\");\n\n        mouseHoverStatus = new JLabel(\"No Mouse Hover Detected.\", JLabel.CENTER);\n        add(mouseHoverStatus);\n        addMouseMotionListener(this);\n        setVisible(true);\n    }\n\n    public void mouseMoved(MouseEvent e)\n    {\n        mouseHoverStatus.setText(\"Mouse Cursor Coordinates => X:\"+e.getX()+\" | Y:\"+e.getY());\n    }\n\n    public void mouseDragged(MouseEvent e)\n    {}\n}\nFileOutputStream Vs. FileWriter\n\n在Java中有两种写文件的方式：FileOutputStream与FileWriter。开发人员经常会在它们之间犹豫不决。下面这个例子能帮忙你更好地理解在不同的场景下应该选择何种方案。首先我们来看一下实现：\n\n使用FileOutputStream：\n\nFile foutput = new File(file_location_string);\nFileOutputStream fos = new FileOutputStream(foutput);\nBufferedWriter output = new BufferedWriter(new OutputStreamWriter(fos));\noutput.write(\"Buffered Content\");\n使用FileWriter：\n\nFileWriter fstream = new FileWriter(file_location_string);\nBufferedWriter output = new BufferedWriter(fstream);\noutput.write(\"Buffered Content\");\n根据Java的接口规范：\n\nFileOutputStream是用于写入原始字节流比如图片流数据。如果是要写入字符流，则应该考虑使用FileWriter。\n\n这样就很清楚了，写图片应该使用FileOutputStream而写文本则应该选择FileWriter。\n\n附加建议\n\n集合的使用\n\nJava提供了许多集合类——比如，Vector，Stack，Hashtable等。所以鼓励开发人员尽可能地使用这些集合类有如下原因：\n\n使用集合使得代码的可重用度更高。\n集合类使得代码的结构更良好，更易于理解与维护。\n最重要的是这些集合类都经过充分的测试，代码质量很高。\n1-50-500规则\n\n在大型软件系统中，代码的可维护性是件很有挑战的工作。新加入的开发人员经常会抱怨这些情况：单片代码（Monolithic Code）,意大利面式代码（spaghetti code, 常用于描述捆绑在一起并且低内聚的类和方法）。保持代码的整洁与可维护有一条很简单的规则：\n\n10：包内的类不超过10个\n50：方法的代码行数不超过50\n500：类的代码行数不超过500\nSOLID设计准则\nSOLID是Robert Martin提出的一套设计准则的简称。根据他的准则：\n一个类应当有仅只有一个任务/职责。执行多个任务的类会让人觉得困惑。\n\n单一职责原则\n开闭原则\t开发人员应当优先考虑扩展现有的软件功能，而不是是修改它。\n里氏替换原则\t子类必须能够替换掉他们的父类型\n接口隔离原则\t和单一职责原则类似，但它特指的是接口层。每个接口都应当只负责一项任务。\n依赖反转原则\t依赖抽象而不是具体实现。也就是说每个模块都应当通过一个抽象层与其它模块进行解耦。\n设计模式的使用\n\n设计模式能帮助开发人员更好地在软件中应用软件的设计准则。它还为开发人员提供了跨语言的通用平台。设计模式中的标准术语能让开发人员更容易进行沟通。\n\n关于文档\n\n不要上来就开始写代码。制定计划，准备，编写文档，检查然后再去实现。首先，先把需求记下来。然后去准备设计文档。合理地去假设举证。互相review方案然后进行确认。\n\n使用equals而非==\n\n==是用来比较对象引用的，它会检查两个操作数指向的是不是同一个对象（不是相同的对象，而是同一个对象）。而”equals”则比较的是两个字符串是不是相同（假设是字符串对象）。\n\n避免使用浮点数\n\n只有当确实有必要的时候才使用浮点数。比方说，使用浮点数来表示卢比或者派萨就很容易产生问题——这种情况应当使用BigDecimal。而浮点数更多地是用于测量。","source":"_posts/22史上最全的Java-新手问题汇总.md","raw":"---\ntitle: 史上最全的Java新手问题汇总\ndate: 2017-09-30 11:08:18\ntags: 面试 Java\ncategories: \"Java\"\n---\n> Java是目前最流行的编程语言之一——它可以用来编写Windows程序或者是Web应用，移动应用，网络程序，消费电子产品，机顶盒设备，它无处不在。\n有超过30亿的设备是运行在Java之上的。根据Oracle的统计数据，光是使用中的Java Card就有有50亿。超过900万程序员选择使用Java进行开发，它是最受开发人员欢迎的语言，同时也是最流行的开发平台。\n本文为那些准Java程序员们准备了一系列广为流传的Java最佳编程实践\n<!--more-->\n#### 优先返回空集合而非null\n如果程序要返回一个不包含任何值的集合，确保返回的是空集合而不是null。这能节省大量的”if else”检查。\n```\npublic class getLocationName {\n    return (null==cityName ? \"\": cityName);\n}\n```\n#### 谨慎操作字符串\n如果两个字符串在for循环中使用+操作符进行拼接，那么每次循环都会产生一个新的字符串对象。这不仅浪费内存空间同时还会影响性能。类似的，如果初始化字符串对象，尽量不要使用构造方法，而应该直接初始化。比方说：\n```\n//Slower Instantiation\nString bad = new String(\"Yet another string object\");\n//Faster Instantiation\nString good = \"Yet another string object\"\n避免无用对象\n```\n创建对象是Java中最昂贵的操作之一。因此最好在有需要的时候再进行对象的创建/初始化。如下：\n```\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Employees {\n\n    private List Employees;\n\n    public List getEmployees() {\n\n        //initialize only when required\n        if(null == Employees) {\n            Employees = new ArrayList();\n        }\n        return Employees;\n    }\n}\n```\n#### 数组与ArrayList之争\n\n开发人员经常会发现很难在数组和ArrayList间做选择。它们二者互有优劣。如何选择应该视情况而定。\n\nimport java.util.ArrayList;\n\npublic class arrayVsArrayList {\n\n    public static void main(String[] args) {\n        int[] myArray = new int[6];\n        myArray[7]= 10; // ArraysOutOfBoundException\n\n        //Declaration of ArrayList. Add and Remove of elements is easy.\n        ArrayList<Integer> myArrayList = new ArrayList<>();\n        myArrayList.add(1);\n        myArrayList.add(2);\n        myArrayList.add(3);\n        myArrayList.add(4);\n        myArrayList.add(5);\n        myArrayList.remove(0);\n\n        for(int i = 0; i < myArrayList.size(); i++) {\n        System.out.println(\"Element: \" + myArrayList.get(i));\n        }\n\n        //Multi-dimensional Array\n        int[][][] multiArray = new int [3][3][3];\n    }\n}\n数组是定长的，而ArrayList是变长的。由于数组长度是固定的，因此在声明数组时就已经分配好内存了。而数组的操作则会更快一些。另一方面，如果我们不知道数据的大小，那么过多的数据便会导致ArrayOutOfBoundException，而少了又会浪费存储空间。\nArrayList在增删元素方面要比数组简单。\n数组可以是多维的，但ArrayList只能是一维的。\ntry块的finally块没有被执行\n看下下面这段代码：\n\npublic class shutDownHooksDemo {\n    public static void main(String[] args) {\n        for(int i=0;i<5;i++)\n        {\n            try {\n                if(i==4) {\n                    System.out.println(\"Inside Try Block.Exiting without executing Finally block.\");\n                    System.exit(0);\n                }\n            }\n            finally {\n                System.out.println(\"Inside Finally Block.\");\n            }\n        }\n    }\n}\n从代码来看，貌似finally块中的println语句应该会被执行5次。但当程序运行后，你会发现finally块只执行了4次。第5次迭代的时候会触发exit函数的调用，于是这第5次的finally便永远也触发不到了。原因便是——System.exit会挂起所有线程的执行，包括当前线程。即便是try语句后的finally块，只要是执行了exit，便也无力回天了。\n\n在调用System.exit时，JVM会在关闭前执行两个结束任务：\n\n首先，它会执行完所有通过Runtime.addShutdownHook注册进来的终止的钩子程序。这一点很关键，因为它会释放JVM外部的资源。\n\n接下来的便是Finalizer了。可能是System.runFinalizersOnExit也可能是Runtime.runFinalizersOnExit。finalizer的使用已经被废弃有很长一段时间了。finalizer可以在存活对象上进行调用，即便是这些对象仍在被其它线程所使用。而这会导致不可预期的结果甚至是死锁。\n\npublic class shutDownHooksDemo {\n\n    public static void main(String[] args) {\n            for(int i=0;i<5;i++)\n            {\n                    final int final_i = i;\n                    try {\n                            Runtime.getRuntime().addShutdownHook(\n                                            new Thread() {\n                                            public void run() {\n                                            if(final_i==4) {\n                                            System.out.println(\"Inside Try Block.Exiting without executing Finally block.\");\n                                            System.exit(0);\n                                            }\n                                            }\n                                            });\n                    }\n                    finally {\n                            System.out.println(\"Inside Finally Block.\");\n                    }\n\n            }\n    }\n}\n判断奇数\n\n看下这几行代码，看看它们是否能用来准确地判断一个数是奇数？\n\npublic boolean oddOrNot(int num) {\n    return num % 2 == 1;\n}\n看似是对的，但是每执行四便会有一个错误的结果（用数据说话）。考虑到负奇数的情况，它除以2的结果就不会是1。因此，返回值是false，而这样是不对的。\n\n代码可以修改成这样：\n\npublic boolean oddOrNot(int num) {\n    return (num & 1) != 0;\n}\n这么写不光是负奇数的问题解决了，并且还是经过充分优化过的。因为算术运算和逻辑运行要比乘除运算更高效，计算的结果也会更快。\n\n单引号与双引号的区别\n\npublic class Haha {\n    public static void main(String args[]) {\n    System.out.print(\"H\" + \"a\");\n    System.out.print('H' + 'a');\n    }\n}\n看起来这段代码会返回”Haha”,但实际返回的是Ha169。原因就是用了双引号的时候，字符会被当作字符串处理，而如果是单引号的话，字符值会通过一个叫做基础类型拓宽的操作来转换成整型值。然后再将值相加得到169。\n\n一些防止内存泄露的小技巧\n\n内存泄露会导致软件的性能降级。由于Java是自动管理内存的，因此开发人员并没有太多办法介入。不过还是有一些方法能够用来防止内存泄露的。\n\n查询完数据后立即释放数据库连接\n尽可能使用finally块\n释放静态变量中的实例\n避免死锁\n死锁出现的原因有很多。避免死锁不是一句话就能解决的。通常来说，当某个同步对象在等待另一个同步对象所拥有的资源上的锁时，便会产生死锁。\n\n试着运行下下面的程序。它会告诉你什么是死锁。这个死锁是由于两个线程都在等待对方所拥有的资源，因此会产生死锁。它们会一直等待，没有谁会先放手。\n\npublic class DeadlockDemo {\n   public static Object addLock = new Object();\n   public static Object subLock = new Object();\n\n   public static void main(String args[]) {\n\n      MyAdditionThread add = new MyAdditionThread();\n      MySubtractionThread sub = new MySubtractionThread();\n      add.start();\n      sub.start();\n   }\nprivate static class MyAdditionThread extends Thread {\n      public void run() {\n         synchronized (addLock) {\n        int a = 10, b = 3;\n        int c = a + b;\n            System.out.println(\"Addition Thread: \" + c);\n            System.out.println(\"Holding First Lock...\");\n            try { Thread.sleep(10); }\n            catch (InterruptedException e) {}\n            System.out.println(\"Addition Thread: Waiting for AddLock...\");\n            synchronized (subLock) {\n               System.out.println(\"Threads: Holding Add and Sub Locks...\");\n            }\n         }\n      }\n   }\n   private static class MySubtractionThread extends Thread {\n      public void run() {\n         synchronized (subLock) {\n        int a = 10, b = 3;\n        int c = a - b;\n            System.out.println(\"Subtraction Thread: \" + c);\n            System.out.println(\"Holding Second Lock...\");\n            try { Thread.sleep(10); }\n            catch (InterruptedException e) {}\n            System.out.println(\"Subtraction  Thread: Waiting for SubLock...\");\n            synchronized (addLock) {\n               System.out.println(\"Threads: Holding Add and Sub Locks...\");\n            }\n         }\n      }\n   }\n}\n输出：\n\nAddition Thread: 13\nSubtraction Thread: 7\nHolding First Lock...\nHolding Second Lock...\nAddition Thread: Waiting for AddLock...\nSubtraction  Thread: Waiting for SubLock...\n但如果调用的顺序变一下的话，死锁的问题就解决了。\n\npublic class DeadlockSolutionDemo {\n   public static Object addLock = new Object();\n   public static Object subLock = new Object();\n\n   public static void main(String args[]) {\n\n      MyAdditionThread add = new MyAdditionThread();\n      MySubtractionThread sub = new MySubtractionThread();\n      add.start();\n      sub.start();\n   }\n\nprivate static class MyAdditionThread extends Thread {\n      public void run() {\n         synchronized (addLock) {\n        int a = 10, b = 3;\n        int c = a + b;\n            System.out.println(\"Addition Thread: \" + c);\n            System.out.println(\"Holding First Lock...\");\n            try { Thread.sleep(10); }\n            catch (InterruptedException e) {}\n            System.out.println(\"Addition Thread: Waiting for AddLock...\");\n            synchronized (subLock) {\n               System.out.println(\"Threads: Holding Add and Sub Locks...\");\n            }\n         }\n      }\n   }\n\n   private static class MySubtractionThread extends Thread {\n      public void run() {\n         synchronized (addLock) {\n        int a = 10, b = 3;\n        int c = a - b;\n            System.out.println(\"Subtraction Thread: \" + c);\n            System.out.println(\"Holding Second Lock...\");\n            try { Thread.sleep(10); }\n            catch (InterruptedException e) {}\n            System.out.println(\"Subtraction  Thread: Waiting for SubLock...\");\n            synchronized (subLock) {\n               System.out.println(\"Threads: Holding Add and Sub Locks...\");\n            }\n         }\n      }\n   }\n}\n输出：\n\nAddition Thread: 13\nHolding First Lock...\nAddition Thread: Waiting for AddLock...\nThreads: Holding Add and Sub Locks...\nSubtraction Thread: 7\nHolding Second Lock...\nSubtraction  Thread: Waiting for SubLock...\nThreads: Holding Add and Sub Locks...\n替Java省点内存\n\n某些Java程序是CPU密集型的，但它们会需要大量的内存。这类程序通常运行得很缓慢，因为它们对内存的需求很大。为了能提升这类应用的性能，可得给它们多留点内存。因此，假设我们有一台拥有10G内存的Tomcat服务器。在这台机器上，我们可以用如下的这条命令来分配内存:\n\nexport JAVA_OPTS=\"$JAVA_OPTS -Xms5000m -Xmx6000m -XX:PermSize=1024m -XX:MaxPermSize=2048m\"\nXms = 最小内存分配\nXmx = 最大内存分配\nXX:PermSize = JVM启动时的初始大小\nXX:MaxPermSize = JVM启动后可分配的最大空间\n如何计算Java中操作的耗时\n在Java中进行操作计时有两个标准的方法：System.currentTimeMillis()和System.nanoTime()。问题就在于，什么情况下该用哪个。从本质上来讲，他们的作用都是一样的，但有以下几点不同：\n\nSystem.currentTimeMillis()的精度在千分之一秒到千分之15秒之间（取决于系统）而System.nanoTime()则能到纳秒级。\nSystem.currentTimeMillis读操作耗时在数个CPU时钟左右。而System.nanoTime()则需要上百个。\nSystem.currentTimeMillis对应的是绝对时间（1970年1 月1日所经历的毫秒数），而System.nanoTime()则不与任何时间点相关。\nFloat还是double\n数据类型\t所用字节\t有效位数\nfloat\t4\t7\ndouble\t8\t15\n在对精度要求高的场景下，double类型相对float要更流行一些，理由如下：\n\n大多数处理器在处理float和double上所需的时间都是差不多的。而计算时间一样的前提下，double类型却能提供更高的精度。\n\n幂运算\n\nJava是通过异或操作来进行幂运算的。Java对于幂运算有两种处理方式：\n\n乘积：\n\ndouble square = double a * double a;                           // Optimized\ndouble cube = double a * double a * double a;                   // Non-optimized\ndouble cube = double a * double square;                       // Optimized\ndouble quad = double a * double a * double a * double a;          // Non-optimized\ndouble quad = double square * double square;                  // Optimized\npow方法：在无法使用乘积的情况下可以使用pow方法。\n\ndouble cube = Math.pow(base, exponent);\n不到万不得已不要使用Math.pow。比方说，当指数是小数的时候。因为Math.pow要比乘积慢300-600倍左右。\n\n如何处理空指针异常\n\n空指针异常是Java中很常见的异常。当你尝试调用一个null对象上的方法时便会抛出这个异常。比如：\n\nint noOfStudents = school.listStudents().count;\n在上述例子中，school为空或者listStudents()为空都可能会抛出了NullPointerException。因此最好检查下对象是否为空以避免类似情况。\n\nprivate int getListOfStudents(File[] files) {\n      if (files == null)\n        throw new NullPointerException(\"File list cannot be null\");\n    }\nJSON编码\n\nJSON是数据存储及传输的一种协议。与XML相比，它更易于使用。由于它非常轻量级以及自身的一些特性，现在JSON在网络上已经是越来越流行了。常见的数据结构都可以编码成JSON然后在各个网页间自由地传输。不过在开始编码前，你得先安装一个JSON解析器。在下面的例子中，我们将使用json.simple库来完成这项工作 (https://code.google.com/p/json-simple/)。\n\n下面是编码成JSON串的一个简单的例子。\n\nimport org.json.simple.JSONObject;\nimport org.json.simple.JSONArray;\n\npublic class JsonEncodeDemo {\n\n    public static void main(String[] args) {\n\n        JSONObject obj = new JSONObject();\n        obj.put(\"Novel Name\", \"Godaan\");\n        obj.put(\"Author\", \"Munshi Premchand\");\n\n        JSONArray novelDetails = new JSONArray();\n        novelDetails.add(\"Language: Hindi\");\n        novelDetails.add(\"Year of Publication: 1936\");\n        novelDetails.add(\"Publisher: Lokmanya Press\");\n\n        obj.put(\"Novel Details\", novelDetails);\n\n        System.out.print(obj);\n    }\n}\n输出：\n\n{\"Novel Name\":\"Godaan\",\"Novel Details\":[\"Language: Hindi\",\"Year of Publication: 1936\",\"Publisher: Lokmanya Press\"],\"Author\":\"Munshi Premchand\"}\nJSON解析\n\n开发人员要想解析JSON串，首先你得知道它的格式。下面例子有助于你来理解这一点：\n\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.json.simple.JSONArray;\nimport org.json.simple.JSONObject;\nimport org.json.simple.parser.JSONParser;\nimport org.json.simple.parser.ParseException;\n\npublic class JsonParseTest {\n\n    private static final String filePath = \"//home//user//Documents//jsonDemoFile.json\";\n\n    public static void main(String[] args) {\n\n        try {\n            // read the json file\n            FileReader reader = new FileReader(filePath);\n            JSONParser jsonParser = new JSONParser();\n            JSONObject jsonObject = (JSONObject)jsonParser.parse(reader);\n\n            // get a number from the JSON object\n            Long id =  (Long) jsonObject.get(\"id\");\n            System.out.println(\"The id is: \" + id);\n\n            // get a String from the JSON object\n            String   type = (String) jsonObject.get(\"type\");\n            System.out.println(\"The type is: \" + type);\n\n            // get a String from the JSON object\n            String   name = (String) jsonObject.get(\"name\");\n            System.out.println(\"The name is: \" + name);\n\n            // get a number from the JSON object\n            Double ppu =  (Double) jsonObject.get(\"ppu\");\n            System.out.println(\"The PPU is: \" + ppu);\n\n            // get an array from the JSON object\n            System.out.println(\"Batters:\");\n            JSONArray batterArray= (JSONArray) jsonObject.get(\"batters\");\n            Iterator i = batterArray.iterator();\n            // take each value from the json array separately\n            while (i.hasNext()) {\n                JSONObject innerObj = (JSONObject) i.next();\n                System.out.println(\"ID \"+ innerObj.get(\"id\") +\n                        \" type \" + innerObj.get(\"type\"));\n            }\n\n            // get an array from the JSON object\n            System.out.println(\"Topping:\");\n            JSONArray toppingArray= (JSONArray) jsonObject.get(\"topping\");\n            Iterator j = toppingArray.iterator();\n            // take each value from the json array separately\n            while (j.hasNext()) {\n                JSONObject innerObj = (JSONObject) j.next();\n                System.out.println(\"ID \"+ innerObj.get(\"id\") +\n                        \" type \" + innerObj.get(\"type\"));\n            }\n\n        } catch (FileNotFoundException ex) {\n            ex.printStackTrace();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        } catch (ParseException ex) {\n            ex.printStackTrace();\n        } catch (NullPointerException ex) {\n            ex.printStackTrace();\n        }\n\n    }\n\n}\njsonDemoFile.json\n\n{\n    \"id\": 0001,\n    \"type\": \"donut\",\n    \"name\": \"Cake\",\n    \"ppu\": 0.55,\n    \"batters\":\n        [\n            { \"id\": 1001, \"type\": \"Regular\" },\n            { \"id\": 1002, \"type\": \"Chocolate\" },\n            { \"id\": 1003, \"type\": \"Blueberry\" },\n            { \"id\": 1004, \"type\": \"Devil's Food\" }\n        ],\n    \"topping\":\n        [\n            { \"id\": 5001, \"type\": \"None\" },\n            { \"id\": 5002, \"type\": \"Glazed\" },\n            { \"id\": 5005, \"type\": \"Sugar\" },\n            { \"id\": 5007, \"type\": \"Powdered Sugar\" },\n            { \"id\": 5006, \"type\": \"Chocolate with Sprinkles\" },\n            { \"id\": 5003, \"type\": \"Chocolate\" },\n            { \"id\": 5004, \"type\": \"Maple\" }\n        ]\n}\nThe id is: 1\nThe type is: donut\nThe name is: Cake\nThe PPU is: 0.55\nBatters:\nID 1001 type Regular\nID 1002 type Chocolate\nID 1003 type Blueberry\nID 1004 type Devil's Food\nTopping:\nID 5001 type None\nID 5002 type Glazed\nID 5005 type Sugar\nID 5007 type Powdered Sugar\nID 5006 type Chocolate with Sprinkles\nID 5003 type Chocolate\nID 5004 type Maple\n简单字符串查找\n\nJava提供了一个库函数叫做indexOf()。这个方法可以用在String对象上，它返回的是要查找的字符串所在的位置序号。如果查找不到则会返回-1。\n\n列出目录下的文件\n\n你可以用下面的代码来列出目录下的文件。这个程序会遍历某个目录下的所有子目录及文件，并存储到一个数组里，然后通过遍历数组来列出所有文件。\n\nimport java.io.*;\n\npublic class ListContents {\n    public static void main(String[] args) {\n        File file = new File(\"//home//user//Documents/\");\n        String[] files = file.list();\n\n        System.out.println(\"Listing contents of \" + file.getPath());\n        for(int i=0 ; i < files.length ; i++)\n        {\n            System.out.println(files[i]);\n        }\n    }\n}\n一个简单的IO程序\n\nJava提供了FileInputStream以及FileOutputStream类来进行文件的读写操作。FileInputStream的构造方法会接收输入文件的路径作为入参然后创建出一个文件的输入流。同样的，FileOutputStream的构造方法也会接收一个文件路径作为入参然后创建出文件的输出流。在处理完文件之后，一个很重要的操作就是要记得”close”掉这些流。\n\nimport java.io.*;\n\npublic class myIODemo {\n    public static void main(String args[]) throws IOException {\n        FileInputStream in = null;\n        FileOutputStream out = null;\n\n        try {\n            in = new FileInputStream(\"//home//user//Documents//InputFile.txt\");\n            out = new FileOutputStream(\"//home//user//Documents//OutputFile.txt\");\n\n            int c;\n            while((c = in.read()) != -1) {\n                out.write(c);\n            }\n        } finally {\n            if(in != null) {\n                in.close();\n            }\n            if(out != null) {\n                out.close();\n            }\n        }\n    }\n}\n在Java中执行某个shell命令\n\nJava提供了Runtime类来执行shell命令。由于这些是外部的命令，因此异常处理就显得异常重要。在下面的例子中，我们将通过一个简单的例子来演示一下。我们会在shell命令行中打开一个pdf文件。\n\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\npublic class ShellCommandExec {\n\n    public static void main(String[] args) {\n        String gnomeOpenCommand = \"gnome-open //home//user//Documents//MyDoc.pdf\";\n\n        try {\n            Runtime rt = Runtime.getRuntime();\n            Process processObj = rt.exec(gnomeOpenCommand);\n\n            InputStream stdin = processObj.getErrorStream();\n            InputStreamReader isr = new InputStreamReader(stdin);\n            BufferedReader br = new BufferedReader(isr);\n\n            String myoutput = \"\";\n\n            while ((myoutput=br.readLine()) != null) {\n                myoutput = myoutput+\"/n\";\n            }\n            System.out.println(myoutput);\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n使用正则\n\n正则表达式的结构摘录如下（来源: Oracle官网）\n\n字符\n\nx\t字符x\n/\t反斜杠\n/0n\t8进制值为0n的字符(0<=n<=7)\n/0nn\n/0mnn\t8进制值为0mnn的字符(0 <= m <= 3, 0<=n<=7)\n/xhh\t16进制值为0xhh的字符\n/uhhhh\t16进制值为0xhhhh的字符\n/x{h…h}\t16进制值为0xh…h的字符(Character.MINCODEPOINT <= 0xh…h <= Character.MAXCODEPOINT)\n/t\t制表符(‘/u0009′)\n/n\t换行符(‘/u000A’)\n/r\t回车(‘/u000D’)\n/f\t分页符(‘/u000C’)\n/a\t警告符(‘/u0007′)\n/e\tESC(‘/u001B’)\n/cx\tctrl+x\n字符分类\n\n[abc]\ta, b或c\n[^abc]\tabc以外的任意字符\n[a-zA-Z]\ta到z以及A到Z\n[a-d[m-p]]\ta到d或者m到p[a-dm-p]则是取并集\n[a-z&&[def]]\td,e或f(交集)\n[ad-z]\n[a-z&&[^bc]]\ta到z但不包括b和c\n[a-z&&[^m-p]]\ta到z但不包括mp:也就是[a-lq-z]\n预定义字符\n\n.\t任意字符，有可能包括换行符\n/d\t0到9的数字\n/D\t0到9以外的字符\n/s\t空格符[ /t/n/x0B/f/r]\n/S\t非空格符[^/s]\n/w\t字母[a-zA-Z_0-9]\n/W\t非字母[^/w]\n边界匹配\n\n^\t行首\n$\t行末\n/b\t单词边界\n/A\t输入的起始位置\n/G\t前一个匹配的末尾\n/Z\t输入的结束位置，仅用于最后的结束符\n/z\t输入的结束位置\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RegexMatches\n{\n    private static String pattern =  \"^[_A-Za-z0-9-]+(//.[_A-Za-z0-9-]+)*@[A-Za-z0-9]+(//.[A-Za-z0-9]+)*(//.[A-Za-z]{2,})$\";\n    private static Pattern mypattern = Pattern.compile(pattern);\n\n    public static void main( String args[] ){\n\n        String valEmail1 = \"testemail@domain.com\";\n        String invalEmail1 = \"....@domain.com\";\n        String invalEmail2 = \".$$%%@domain.com\";\n        String valEmail2 = \"test.email@domain.com\";\n\n        System.out.println(\"Is Email ID1 valid? \"+validateEMailID(valEmail1));\n        System.out.println(\"Is Email ID1 valid? \"+validateEMailID(invalEmail1));\n        System.out.println(\"Is Email ID1 valid? \"+validateEMailID(invalEmail2));\n        System.out.println(\"Is Email ID1 valid? \"+validateEMailID(valEmail2));\n\n    }\n\n    public static boolean validateEMailID(String emailID) {\n        Matcher mtch = mypattern.matcher(emailID);\n        if(mtch.matches()){\n            return true;\n        }\n        return false;\n    }\n}\nJava Swing的简单示例\n\n有了Java的swing，你便可以编写GUI应用了。Java所提供的javax包中就包含了swing。使用swing来编写GUI程序首先需要继承下JFrame。然后在里面添加Box，然后便可以往里面添加诸如按钮，多选按钮，文本框等控件了。这些Box是放在Container的最外层的。\n\nimport java.awt.*;\nimport javax.swing.*;\n\npublic class SwingsDemo extends JFrame\n{\n    public SwingsDemo()\n    {\n        String path = \"//home//user//Documents//images\";\n        Container contentPane = getContentPane();\n        contentPane.setLayout(new FlowLayout());\n\n        Box myHorizontalBox = Box. createHorizontalBox();\n        Box myVerticleBox = Box. createVerticalBox();\n\n        myHorizontalBox.add(new JButton(\"My Button 1\"));\n        myHorizontalBox.add(new JButton(\"My Button 2\"));\n        myHorizontalBox.add(new JButton(\"My Button 3\"));\n\n        myVerticleBox.add(new JButton(new ImageIcon(path + \"//Image1.jpg\")));\n        myVerticleBox.add(new JButton(new ImageIcon(path + \"//Image2.jpg\")));\n        myVerticleBox.add(new JButton(new ImageIcon(path + \"//Image3.jpg\")));\n\n        contentPane.add(myHorizontalBox);\n        contentPane.add(myVerticleBox);\n\n        pack();\n        setVisible(true);\n    }\n\n    public static void main(String args[]) {\n        new SwingsDemo();\n    }\n}\n使用Java播放音频\n\n在Java中，播放音频是一个很常见的需求，尤其是在游戏开发里面。\n\n下面这个DEMO演示了如何在Java中播放音频。\n\nimport java.io.*;\nimport java.net.URL;\nimport javax.sound.sampled.*;\nimport javax.swing.*;\n\n// To play sound using Clip, the process need to be alive.\n// Hence, we use a Swing application.\npublic class playSoundDemo extends JFrame {\n\n   // Constructor\n   public playSoundDemo() {\n      this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n      this.setTitle(\"Play Sound Demo\");\n      this.setSize(300, 200);\n      this.setVisible(true);\n\n      try {\n         URL url = this.getClass().getResource(\"MyAudio.wav\");\n         AudioInputStream audioIn = AudioSystem.getAudioInputStream(url);\n         Clip clip = AudioSystem.getClip();\n         clip.open(audioIn);\n         clip.start();\n      } catch (UnsupportedAudioFileException e) {\n         e.printStackTrace();\n      } catch (IOException e) {\n         e.printStackTrace();\n      } catch (LineUnavailableException e) {\n         e.printStackTrace();\n      }\n   }\n\n   public static void main(String[] args) {\n      new playSoundDemo();\n   }\n}\n导出PDF文件\n\n将表格导出成pdf也是一个比较常见的需求。通过itextpdf，导出pdf也不是什么难事。\n\nimport java.io.FileOutputStream;\nimport com.itextpdf.text.Document;\nimport com.itextpdf.text.Paragraph;\nimport com.itextpdf.text.pdf.PdfPCell;\nimport com.itextpdf.text.pdf.PdfPTable;\nimport com.itextpdf.text.pdf.PdfWriter;\n\npublic class DrawPdf {\n\n      public static void main(String[] args) throws Exception {\n        Document document = new Document();\n        PdfWriter.getInstance(document, new FileOutputStream(\"Employee.pdf\"));\n        document.open();\n\n        Paragraph para = new Paragraph(\"Employee Table\");\n        para.setSpacingAfter(20);\n        document.add(para);\n\n        PdfPTable table = new PdfPTable(3);\n        PdfPCell cell = new PdfPCell(new Paragraph(\"First Name\"));\n\n        table.addCell(cell);\n        table.addCell(\"Last Name\");\n        table.addCell(\"Gender\");\n        table.addCell(\"Ram\");\n        table.addCell(\"Kumar\");\n        table.addCell(\"Male\");\n        table.addCell(\"Lakshmi\");\n        table.addCell(\"Devi\");\n        table.addCell(\"Female\");\n\n        document.add(table);\n\n        document.close();\n      }\n    }\n邮件发送\n\n在Java中发送邮件也很简单。你只需装一下Java Mail这个jar包，放到你的类路径里即可。在下面的代码中，我们设置了几个基础属性，然后便可以发送邮件了：\n\nimport java.util.*;\nimport javax.mail.*;\nimport javax.mail.internet.*;\n\npublic class SendEmail\n{\n    public static void main(String [] args)\n    {\n        String to = \"recipient@gmail.com\";\n        String from = \"sender@gmail.com\";\n        String host = \"localhost\";\n\n        Properties properties = System.getProperties();\n        properties.setProperty(\"mail.smtp.host\", host);\n        Session session = Session.getDefaultInstance(properties);\n\n        try{\n            MimeMessage message = new MimeMessage(session);\n            message.setFrom(new InternetAddress(from));\n\n            message.addRecipient(Message.RecipientType.TO,new InternetAddress(to));\n\n            message.setSubject(\"My Email Subject\");\n            message.setText(\"My Message Body\");\n            Transport.send(message);\n            System.out.println(\"Sent successfully!\");\n        }\n        catch (MessagingException ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n计算时间\n\n许多程序都需要精确的时间计量。Java提供了一个System的静态方法来支持这一功能：\n\ncurrentTimeMillis()：返回当前时间自新纪元时间以来的毫秒值，long类型。\n\nlong startTime = System.currentTimeMillis();\nlong estimatedTime = System.currentTimeMillis() - startTime;\nnanoTime()：返回系统计时器当前的精确时间，纳秒值，这也是long类型。nanoTime()主要是用于计算相对时间而非绝对时间。\n\nlong startTime = System.nanoTime();\nlong estimatedTime = System.nanoTime() - startTime;\n图片缩放\n\n图片缩放可以通过AffineTransform来完成。首先要生成一个输入图片的图片缓冲，然后通过它来渲染出缩放后的图片。\n\nimport java.awt.Graphics2D;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport javax.imageio.ImageIO;\n\npublic class RescaleImage {\n  public static void main(String[] args) throws Exception {\n    BufferedImage imgSource = ImageIO.read(new File(\"images//Image3.jpg\"));\n    BufferedImage imgDestination = new BufferedImage(100, 100, BufferedImage.TYPE_INT_RGB);\n    Graphics2D g = imgDestination.createGraphics();\n    AffineTransform affinetransformation = AffineTransform.getScaleInstance(2, 2);\n    g.drawRenderedImage(imgSource, affinetransformation);\n    ImageIO.write(imgDestination, \"JPG\", new File(\"outImage.jpg\"));\n  }\n}\n捕获鼠标动作\n\n实现了MouseMotionListner接口后，便可以捕获鼠标事件了。 当鼠标进入到某个特定区域时便会触发MouseMoved事件，你便能捕获到这个移动的动作了。通过一个例子来看下：\n\nimport java.awt.event.*;\nimport javax.swing.*;\n\npublic class MouseCaptureDemo extends JFrame implements MouseMotionListener\n{\n    public JLabel mouseHoverStatus;\n\n    public static void main(String args[])\n    {\n        new MouseCaptureDemo();\n    }\n\n    MouseCaptureDemo()\n    {\n        setSize(500, 500);\n        setTitle(\"Frame displaying Coordinates of Mouse Motion\");\n\n        mouseHoverStatus = new JLabel(\"No Mouse Hover Detected.\", JLabel.CENTER);\n        add(mouseHoverStatus);\n        addMouseMotionListener(this);\n        setVisible(true);\n    }\n\n    public void mouseMoved(MouseEvent e)\n    {\n        mouseHoverStatus.setText(\"Mouse Cursor Coordinates => X:\"+e.getX()+\" | Y:\"+e.getY());\n    }\n\n    public void mouseDragged(MouseEvent e)\n    {}\n}\nFileOutputStream Vs. FileWriter\n\n在Java中有两种写文件的方式：FileOutputStream与FileWriter。开发人员经常会在它们之间犹豫不决。下面这个例子能帮忙你更好地理解在不同的场景下应该选择何种方案。首先我们来看一下实现：\n\n使用FileOutputStream：\n\nFile foutput = new File(file_location_string);\nFileOutputStream fos = new FileOutputStream(foutput);\nBufferedWriter output = new BufferedWriter(new OutputStreamWriter(fos));\noutput.write(\"Buffered Content\");\n使用FileWriter：\n\nFileWriter fstream = new FileWriter(file_location_string);\nBufferedWriter output = new BufferedWriter(fstream);\noutput.write(\"Buffered Content\");\n根据Java的接口规范：\n\nFileOutputStream是用于写入原始字节流比如图片流数据。如果是要写入字符流，则应该考虑使用FileWriter。\n\n这样就很清楚了，写图片应该使用FileOutputStream而写文本则应该选择FileWriter。\n\n附加建议\n\n集合的使用\n\nJava提供了许多集合类——比如，Vector，Stack，Hashtable等。所以鼓励开发人员尽可能地使用这些集合类有如下原因：\n\n使用集合使得代码的可重用度更高。\n集合类使得代码的结构更良好，更易于理解与维护。\n最重要的是这些集合类都经过充分的测试，代码质量很高。\n1-50-500规则\n\n在大型软件系统中，代码的可维护性是件很有挑战的工作。新加入的开发人员经常会抱怨这些情况：单片代码（Monolithic Code）,意大利面式代码（spaghetti code, 常用于描述捆绑在一起并且低内聚的类和方法）。保持代码的整洁与可维护有一条很简单的规则：\n\n10：包内的类不超过10个\n50：方法的代码行数不超过50\n500：类的代码行数不超过500\nSOLID设计准则\nSOLID是Robert Martin提出的一套设计准则的简称。根据他的准则：\n一个类应当有仅只有一个任务/职责。执行多个任务的类会让人觉得困惑。\n\n单一职责原则\n开闭原则\t开发人员应当优先考虑扩展现有的软件功能，而不是是修改它。\n里氏替换原则\t子类必须能够替换掉他们的父类型\n接口隔离原则\t和单一职责原则类似，但它特指的是接口层。每个接口都应当只负责一项任务。\n依赖反转原则\t依赖抽象而不是具体实现。也就是说每个模块都应当通过一个抽象层与其它模块进行解耦。\n设计模式的使用\n\n设计模式能帮助开发人员更好地在软件中应用软件的设计准则。它还为开发人员提供了跨语言的通用平台。设计模式中的标准术语能让开发人员更容易进行沟通。\n\n关于文档\n\n不要上来就开始写代码。制定计划，准备，编写文档，检查然后再去实现。首先，先把需求记下来。然后去准备设计文档。合理地去假设举证。互相review方案然后进行确认。\n\n使用equals而非==\n\n==是用来比较对象引用的，它会检查两个操作数指向的是不是同一个对象（不是相同的对象，而是同一个对象）。而”equals”则比较的是两个字符串是不是相同（假设是字符串对象）。\n\n避免使用浮点数\n\n只有当确实有必要的时候才使用浮点数。比方说，使用浮点数来表示卢比或者派萨就很容易产生问题——这种情况应当使用BigDecimal。而浮点数更多地是用于测量。","slug":"22史上最全的Java-新手问题汇总","published":1,"updated":"2017-09-30T08:44:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tca90016a7xwcdtb4y0z","content":"<blockquote>\n<p>Java是目前最流行的编程语言之一——它可以用来编写Windows程序或者是Web应用，移动应用，网络程序，消费电子产品，机顶盒设备，它无处不在。<br>有超过30亿的设备是运行在Java之上的。根据Oracle的统计数据，光是使用中的Java Card就有有50亿。超过900万程序员选择使用Java进行开发，它是最受开发人员欢迎的语言，同时也是最流行的开发平台。<br>本文为那些准Java程序员们准备了一系列广为流传的Java最佳编程实践<br><a id=\"more\"></a></p>\n<h4 id=\"优先返回空集合而非null\"><a href=\"#优先返回空集合而非null\" class=\"headerlink\" title=\"优先返回空集合而非null\"></a>优先返回空集合而非null</h4><p>如果程序要返回一个不包含任何值的集合，确保返回的是空集合而不是null。这能节省大量的”if else”检查。<br><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">getLocationName</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"literal\">null</span>==cityName ? <span class=\"string\">\"\"</span>: cityName);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"谨慎操作字符串\"><a href=\"#谨慎操作字符串\" class=\"headerlink\" title=\"谨慎操作字符串\"></a>谨慎操作字符串</h4><p>如果两个字符串在for循环中使用+操作符进行拼接，那么每次循环都会产生一个新的字符串对象。这不仅浪费内存空间同时还会影响性能。类似的，如果初始化字符串对象，尽量不要使用构造方法，而应该直接初始化。比方说：<br><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Slower Instantiation</span></div><div class=\"line\"><span class=\"keyword\">String</span> bad = <span class=\"keyword\">new</span> <span class=\"keyword\">String</span>(<span class=\"string\">\"Yet another string object\"</span>);</div><div class=\"line\"><span class=\"comment\">//Faster Instantiation</span></div><div class=\"line\"><span class=\"keyword\">String</span> good = <span class=\"string\">\"Yet another string object\"</span></div><div class=\"line\">避免无用对象</div></pre></td></tr></table></figure></p>\n<p>创建对象是Java中最昂贵的操作之一。因此最好在有需要的时候再进行对象的创建/初始化。如下：<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">import</span> java.util.ArrayList;</span></div><div class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">import</span> java.util.List;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employees</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> List Employees;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> List getEmployees() &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//initialize only when required</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span> == Employees) &#123;</div><div class=\"line\">            Employees = <span class=\"keyword\">new</span> ArrayList();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> Employees;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"数组与ArrayList之争\"><a href=\"#数组与ArrayList之争\" class=\"headerlink\" title=\"数组与ArrayList之争\"></a>数组与ArrayList之争</h4><p>开发人员经常会发现很难在数组和ArrayList间做选择。它们二者互有优劣。如何选择应该视情况而定。</p>\n<p>import java.util.ArrayList;</p>\n<p>public class arrayVsArrayList {</p>\n<pre><code>public static void main(String[] args) {\n    int[] myArray = new int[6];\n    myArray[7]= 10; // ArraysOutOfBoundException\n\n    //Declaration of ArrayList. Add and Remove of elements is easy.\n    ArrayList&lt;Integer&gt; myArrayList = new ArrayList&lt;&gt;();\n    myArrayList.add(1);\n    myArrayList.add(2);\n    myArrayList.add(3);\n    myArrayList.add(4);\n    myArrayList.add(5);\n    myArrayList.remove(0);\n\n    for(int i = 0; i &lt; myArrayList.size(); i++) {\n    System.out.println(&quot;Element: &quot; + myArrayList.get(i));\n    }\n\n    //Multi-dimensional Array\n    int[][][] multiArray = new int [3][3][3];\n}\n</code></pre><p>}<br>数组是定长的，而ArrayList是变长的。由于数组长度是固定的，因此在声明数组时就已经分配好内存了。而数组的操作则会更快一些。另一方面，如果我们不知道数据的大小，那么过多的数据便会导致ArrayOutOfBoundException，而少了又会浪费存储空间。<br>ArrayList在增删元素方面要比数组简单。<br>数组可以是多维的，但ArrayList只能是一维的。<br>try块的finally块没有被执行<br>看下下面这段代码：</p>\n<p>public class shutDownHooksDemo {<br>    public static void main(String[] args) {<br>        for(int i=0;i&lt;5;i++)<br>        {<br>            try {<br>                if(i==4) {<br>                    System.out.println(“Inside Try Block.Exiting without executing Finally block.”);<br>                    System.exit(0);<br>                }<br>            }<br>            finally {<br>                System.out.println(“Inside Finally Block.”);<br>            }<br>        }<br>    }<br>}<br>从代码来看，貌似finally块中的println语句应该会被执行5次。但当程序运行后，你会发现finally块只执行了4次。第5次迭代的时候会触发exit函数的调用，于是这第5次的finally便永远也触发不到了。原因便是——System.exit会挂起所有线程的执行，包括当前线程。即便是try语句后的finally块，只要是执行了exit，便也无力回天了。</p>\n<p>在调用System.exit时，JVM会在关闭前执行两个结束任务：</p>\n<p>首先，它会执行完所有通过Runtime.addShutdownHook注册进来的终止的钩子程序。这一点很关键，因为它会释放JVM外部的资源。</p>\n<p>接下来的便是Finalizer了。可能是System.runFinalizersOnExit也可能是Runtime.runFinalizersOnExit。finalizer的使用已经被废弃有很长一段时间了。finalizer可以在存活对象上进行调用，即便是这些对象仍在被其它线程所使用。而这会导致不可预期的结果甚至是死锁。</p>\n<p>public class shutDownHooksDemo {</p>\n<pre><code>public static void main(String[] args) {\n        for(int i=0;i&lt;5;i++)\n        {\n                final int final_i = i;\n                try {\n                        Runtime.getRuntime().addShutdownHook(\n                                        new Thread() {\n                                        public void run() {\n                                        if(final_i==4) {\n                                        System.out.println(&quot;Inside Try Block.Exiting without executing Finally block.&quot;);\n                                        System.exit(0);\n                                        }\n                                        }\n                                        });\n                }\n                finally {\n                        System.out.println(&quot;Inside Finally Block.&quot;);\n                }\n\n        }\n}\n</code></pre><p>}<br>判断奇数</p>\n<p>看下这几行代码，看看它们是否能用来准确地判断一个数是奇数？</p>\n<p>public boolean oddOrNot(int num) {<br>    return num % 2 == 1;<br>}<br>看似是对的，但是每执行四便会有一个错误的结果（用数据说话）。考虑到负奇数的情况，它除以2的结果就不会是1。因此，返回值是false，而这样是不对的。</p>\n<p>代码可以修改成这样：</p>\n<p>public boolean oddOrNot(int num) {<br>    return (num &amp; 1) != 0;<br>}<br>这么写不光是负奇数的问题解决了，并且还是经过充分优化过的。因为算术运算和逻辑运行要比乘除运算更高效，计算的结果也会更快。</p>\n<p>单引号与双引号的区别</p>\n<p>public class Haha {<br>    public static void main(String args[]) {<br>    System.out.print(“H” + “a”);<br>    System.out.print(‘H’ + ‘a’);<br>    }<br>}<br>看起来这段代码会返回”Haha”,但实际返回的是Ha169。原因就是用了双引号的时候，字符会被当作字符串处理，而如果是单引号的话，字符值会通过一个叫做基础类型拓宽的操作来转换成整型值。然后再将值相加得到169。</p>\n<p>一些防止内存泄露的小技巧</p>\n<p>内存泄露会导致软件的性能降级。由于Java是自动管理内存的，因此开发人员并没有太多办法介入。不过还是有一些方法能够用来防止内存泄露的。</p>\n<p>查询完数据后立即释放数据库连接<br>尽可能使用finally块<br>释放静态变量中的实例<br>避免死锁<br>死锁出现的原因有很多。避免死锁不是一句话就能解决的。通常来说，当某个同步对象在等待另一个同步对象所拥有的资源上的锁时，便会产生死锁。</p>\n<p>试着运行下下面的程序。它会告诉你什么是死锁。这个死锁是由于两个线程都在等待对方所拥有的资源，因此会产生死锁。它们会一直等待，没有谁会先放手。</p>\n<p>public class DeadlockDemo {<br>   public static Object addLock = new Object();<br>   public static Object subLock = new Object();</p>\n<p>   public static void main(String args[]) {</p>\n<pre><code>MyAdditionThread add = new MyAdditionThread();\nMySubtractionThread sub = new MySubtractionThread();\nadd.start();\nsub.start();\n</code></pre><p>   }<br>private static class MyAdditionThread extends Thread {<br>      public void run() {<br>         synchronized (addLock) {<br>        int a = 10, b = 3;<br>        int c = a + b;<br>            System.out.println(“Addition Thread: “ + c);<br>            System.out.println(“Holding First Lock…”);<br>            try { Thread.sleep(10); }<br>            catch (InterruptedException e) {}<br>            System.out.println(“Addition Thread: Waiting for AddLock…”);<br>            synchronized (subLock) {<br>               System.out.println(“Threads: Holding Add and Sub Locks…”);<br>            }<br>         }<br>      }<br>   }<br>   private static class MySubtractionThread extends Thread {<br>      public void run() {<br>         synchronized (subLock) {<br>        int a = 10, b = 3;<br>        int c = a - b;<br>            System.out.println(“Subtraction Thread: “ + c);<br>            System.out.println(“Holding Second Lock…”);<br>            try { Thread.sleep(10); }<br>            catch (InterruptedException e) {}<br>            System.out.println(“Subtraction  Thread: Waiting for SubLock…”);<br>            synchronized (addLock) {<br>               System.out.println(“Threads: Holding Add and Sub Locks…”);<br>            }<br>         }<br>      }<br>   }<br>}<br>输出：</p>\n<p>Addition Thread: 13<br>Subtraction Thread: 7<br>Holding First Lock…<br>Holding Second Lock…<br>Addition Thread: Waiting for AddLock…<br>Subtraction  Thread: Waiting for SubLock…<br>但如果调用的顺序变一下的话，死锁的问题就解决了。</p>\n<p>public class DeadlockSolutionDemo {<br>   public static Object addLock = new Object();<br>   public static Object subLock = new Object();</p>\n<p>   public static void main(String args[]) {</p>\n<pre><code>MyAdditionThread add = new MyAdditionThread();\nMySubtractionThread sub = new MySubtractionThread();\nadd.start();\nsub.start();\n</code></pre><p>   }</p>\n<p>private static class MyAdditionThread extends Thread {<br>      public void run() {<br>         synchronized (addLock) {<br>        int a = 10, b = 3;<br>        int c = a + b;<br>            System.out.println(“Addition Thread: “ + c);<br>            System.out.println(“Holding First Lock…”);<br>            try { Thread.sleep(10); }<br>            catch (InterruptedException e) {}<br>            System.out.println(“Addition Thread: Waiting for AddLock…”);<br>            synchronized (subLock) {<br>               System.out.println(“Threads: Holding Add and Sub Locks…”);<br>            }<br>         }<br>      }<br>   }</p>\n<p>   private static class MySubtractionThread extends Thread {<br>      public void run() {<br>         synchronized (addLock) {<br>        int a = 10, b = 3;<br>        int c = a - b;<br>            System.out.println(“Subtraction Thread: “ + c);<br>            System.out.println(“Holding Second Lock…”);<br>            try { Thread.sleep(10); }<br>            catch (InterruptedException e) {}<br>            System.out.println(“Subtraction  Thread: Waiting for SubLock…”);<br>            synchronized (subLock) {<br>               System.out.println(“Threads: Holding Add and Sub Locks…”);<br>            }<br>         }<br>      }<br>   }<br>}<br>输出：</p>\n<p>Addition Thread: 13<br>Holding First Lock…<br>Addition Thread: Waiting for AddLock…<br>Threads: Holding Add and Sub Locks…<br>Subtraction Thread: 7<br>Holding Second Lock…<br>Subtraction  Thread: Waiting for SubLock…<br>Threads: Holding Add and Sub Locks…<br>替Java省点内存</p>\n<p>某些Java程序是CPU密集型的，但它们会需要大量的内存。这类程序通常运行得很缓慢，因为它们对内存的需求很大。为了能提升这类应用的性能，可得给它们多留点内存。因此，假设我们有一台拥有10G内存的Tomcat服务器。在这台机器上，我们可以用如下的这条命令来分配内存:</p>\n<p>export JAVA_OPTS=”$JAVA_OPTS -Xms5000m -Xmx6000m -XX:PermSize=1024m -XX:MaxPermSize=2048m”<br>Xms = 最小内存分配<br>Xmx = 最大内存分配<br>XX:PermSize = JVM启动时的初始大小<br>XX:MaxPermSize = JVM启动后可分配的最大空间<br>如何计算Java中操作的耗时<br>在Java中进行操作计时有两个标准的方法：System.currentTimeMillis()和System.nanoTime()。问题就在于，什么情况下该用哪个。从本质上来讲，他们的作用都是一样的，但有以下几点不同：</p>\n<p>System.currentTimeMillis()的精度在千分之一秒到千分之15秒之间（取决于系统）而System.nanoTime()则能到纳秒级。<br>System.currentTimeMillis读操作耗时在数个CPU时钟左右。而System.nanoTime()则需要上百个。<br>System.currentTimeMillis对应的是绝对时间（1970年1 月1日所经历的毫秒数），而System.nanoTime()则不与任何时间点相关。<br>Float还是double<br>数据类型    所用字节    有效位数<br>float    4    7<br>double    8    15<br>在对精度要求高的场景下，double类型相对float要更流行一些，理由如下：</p>\n<p>大多数处理器在处理float和double上所需的时间都是差不多的。而计算时间一样的前提下，double类型却能提供更高的精度。</p>\n<p>幂运算</p>\n<p>Java是通过异或操作来进行幂运算的。Java对于幂运算有两种处理方式：</p>\n<p>乘积：</p>\n<p>double square = double a <em> double a;                           // Optimized<br>double cube = double a </em> double a <em> double a;                   // Non-optimized<br>double cube = double a </em> double square;                       // Optimized<br>double quad = double a <em> double a </em> double a <em> double a;          // Non-optimized<br>double quad = double square </em> double square;                  // Optimized<br>pow方法：在无法使用乘积的情况下可以使用pow方法。</p>\n<p>double cube = Math.pow(base, exponent);<br>不到万不得已不要使用Math.pow。比方说，当指数是小数的时候。因为Math.pow要比乘积慢300-600倍左右。</p>\n<p>如何处理空指针异常</p>\n<p>空指针异常是Java中很常见的异常。当你尝试调用一个null对象上的方法时便会抛出这个异常。比如：</p>\n<p>int noOfStudents = school.listStudents().count;<br>在上述例子中，school为空或者listStudents()为空都可能会抛出了NullPointerException。因此最好检查下对象是否为空以避免类似情况。</p>\n<p>private int getListOfStudents(File[] files) {<br>      if (files == null)<br>        throw new NullPointerException(“File list cannot be null”);<br>    }<br>JSON编码</p>\n<p>JSON是数据存储及传输的一种协议。与XML相比，它更易于使用。由于它非常轻量级以及自身的一些特性，现在JSON在网络上已经是越来越流行了。常见的数据结构都可以编码成JSON然后在各个网页间自由地传输。不过在开始编码前，你得先安装一个JSON解析器。在下面的例子中，我们将使用json.simple库来完成这项工作 (<a href=\"https://code.google.com/p/json-simple/)。\" target=\"_blank\" rel=\"external\">https://code.google.com/p/json-simple/)。</a></p>\n<p>下面是编码成JSON串的一个简单的例子。</p>\n<p>import org.json.simple.JSONObject;<br>import org.json.simple.JSONArray;</p>\n<p>public class JsonEncodeDemo {</p>\n<pre><code>public static void main(String[] args) {\n\n    JSONObject obj = new JSONObject();\n    obj.put(&quot;Novel Name&quot;, &quot;Godaan&quot;);\n    obj.put(&quot;Author&quot;, &quot;Munshi Premchand&quot;);\n\n    JSONArray novelDetails = new JSONArray();\n    novelDetails.add(&quot;Language: Hindi&quot;);\n    novelDetails.add(&quot;Year of Publication: 1936&quot;);\n    novelDetails.add(&quot;Publisher: Lokmanya Press&quot;);\n\n    obj.put(&quot;Novel Details&quot;, novelDetails);\n\n    System.out.print(obj);\n}\n</code></pre><p>}<br>输出：</p>\n<p>{“Novel Name”:”Godaan”,”Novel Details”:[“Language: Hindi”,”Year of Publication: 1936”,”Publisher: Lokmanya Press”],”Author”:”Munshi Premchand”}<br>JSON解析</p>\n<p>开发人员要想解析JSON串，首先你得知道它的格式。下面例子有助于你来理解这一点：</p>\n<p>import java.io.FileNotFoundException;<br>import java.io.FileReader;<br>import java.io.IOException;<br>import java.util.Iterator;</p>\n<p>import org.json.simple.JSONArray;<br>import org.json.simple.JSONObject;<br>import org.json.simple.parser.JSONParser;<br>import org.json.simple.parser.ParseException;</p>\n<p>public class JsonParseTest {</p>\n<pre><code>private static final String filePath = &quot;//home//user//Documents//jsonDemoFile.json&quot;;\n\npublic static void main(String[] args) {\n\n    try {\n        // read the json file\n        FileReader reader = new FileReader(filePath);\n        JSONParser jsonParser = new JSONParser();\n        JSONObject jsonObject = (JSONObject)jsonParser.parse(reader);\n\n        // get a number from the JSON object\n        Long id =  (Long) jsonObject.get(&quot;id&quot;);\n        System.out.println(&quot;The id is: &quot; + id);\n\n        // get a String from the JSON object\n        String   type = (String) jsonObject.get(&quot;type&quot;);\n        System.out.println(&quot;The type is: &quot; + type);\n\n        // get a String from the JSON object\n        String   name = (String) jsonObject.get(&quot;name&quot;);\n        System.out.println(&quot;The name is: &quot; + name);\n\n        // get a number from the JSON object\n        Double ppu =  (Double) jsonObject.get(&quot;ppu&quot;);\n        System.out.println(&quot;The PPU is: &quot; + ppu);\n\n        // get an array from the JSON object\n        System.out.println(&quot;Batters:&quot;);\n        JSONArray batterArray= (JSONArray) jsonObject.get(&quot;batters&quot;);\n        Iterator i = batterArray.iterator();\n        // take each value from the json array separately\n        while (i.hasNext()) {\n            JSONObject innerObj = (JSONObject) i.next();\n            System.out.println(&quot;ID &quot;+ innerObj.get(&quot;id&quot;) +\n                    &quot; type &quot; + innerObj.get(&quot;type&quot;));\n        }\n\n        // get an array from the JSON object\n        System.out.println(&quot;Topping:&quot;);\n        JSONArray toppingArray= (JSONArray) jsonObject.get(&quot;topping&quot;);\n        Iterator j = toppingArray.iterator();\n        // take each value from the json array separately\n        while (j.hasNext()) {\n            JSONObject innerObj = (JSONObject) j.next();\n            System.out.println(&quot;ID &quot;+ innerObj.get(&quot;id&quot;) +\n                    &quot; type &quot; + innerObj.get(&quot;type&quot;));\n        }\n\n    } catch (FileNotFoundException ex) {\n        ex.printStackTrace();\n    } catch (IOException ex) {\n        ex.printStackTrace();\n    } catch (ParseException ex) {\n        ex.printStackTrace();\n    } catch (NullPointerException ex) {\n        ex.printStackTrace();\n    }\n\n}\n</code></pre><p>}<br>jsonDemoFile.json</p>\n<p>{<br>    “id”: 0001,<br>    “type”: “donut”,<br>    “name”: “Cake”,<br>    “ppu”: 0.55,<br>    “batters”:<br>        [<br>            { “id”: 1001, “type”: “Regular” },<br>            { “id”: 1002, “type”: “Chocolate” },<br>            { “id”: 1003, “type”: “Blueberry” },<br>            { “id”: 1004, “type”: “Devil’s Food” }<br>        ],<br>    “topping”:<br>        [<br>            { “id”: 5001, “type”: “None” },<br>            { “id”: 5002, “type”: “Glazed” },<br>            { “id”: 5005, “type”: “Sugar” },<br>            { “id”: 5007, “type”: “Powdered Sugar” },<br>            { “id”: 5006, “type”: “Chocolate with Sprinkles” },<br>            { “id”: 5003, “type”: “Chocolate” },<br>            { “id”: 5004, “type”: “Maple” }<br>        ]<br>}<br>The id is: 1<br>The type is: donut<br>The name is: Cake<br>The PPU is: 0.55<br>Batters:<br>ID 1001 type Regular<br>ID 1002 type Chocolate<br>ID 1003 type Blueberry<br>ID 1004 type Devil’s Food<br>Topping:<br>ID 5001 type None<br>ID 5002 type Glazed<br>ID 5005 type Sugar<br>ID 5007 type Powdered Sugar<br>ID 5006 type Chocolate with Sprinkles<br>ID 5003 type Chocolate<br>ID 5004 type Maple<br>简单字符串查找</p>\n<p>Java提供了一个库函数叫做indexOf()。这个方法可以用在String对象上，它返回的是要查找的字符串所在的位置序号。如果查找不到则会返回-1。</p>\n<p>列出目录下的文件</p>\n<p>你可以用下面的代码来列出目录下的文件。这个程序会遍历某个目录下的所有子目录及文件，并存储到一个数组里，然后通过遍历数组来列出所有文件。</p>\n<p>import java.io.*;</p>\n<p>public class ListContents {<br>    public static void main(String[] args) {<br>        File file = new File(“//home//user//Documents/“);<br>        String[] files = file.list();</p>\n<pre><code>    System.out.println(&quot;Listing contents of &quot; + file.getPath());\n    for(int i=0 ; i &lt; files.length ; i++)\n    {\n        System.out.println(files[i]);\n    }\n}\n</code></pre><p>}<br>一个简单的IO程序</p>\n<p>Java提供了FileInputStream以及FileOutputStream类来进行文件的读写操作。FileInputStream的构造方法会接收输入文件的路径作为入参然后创建出一个文件的输入流。同样的，FileOutputStream的构造方法也会接收一个文件路径作为入参然后创建出文件的输出流。在处理完文件之后，一个很重要的操作就是要记得”close”掉这些流。</p>\n<p>import java.io.*;</p>\n<p>public class myIODemo {<br>    public static void main(String args[]) throws IOException {<br>        FileInputStream in = null;<br>        FileOutputStream out = null;</p>\n<pre><code>    try {\n        in = new FileInputStream(&quot;//home//user//Documents//InputFile.txt&quot;);\n        out = new FileOutputStream(&quot;//home//user//Documents//OutputFile.txt&quot;);\n\n        int c;\n        while((c = in.read()) != -1) {\n            out.write(c);\n        }\n    } finally {\n        if(in != null) {\n            in.close();\n        }\n        if(out != null) {\n            out.close();\n        }\n    }\n}\n</code></pre><p>}<br>在Java中执行某个shell命令</p>\n<p>Java提供了Runtime类来执行shell命令。由于这些是外部的命令，因此异常处理就显得异常重要。在下面的例子中，我们将通过一个简单的例子来演示一下。我们会在shell命令行中打开一个pdf文件。</p>\n<p>import java.io.BufferedReader;<br>import java.io.InputStream;<br>import java.io.InputStreamReader;</p>\n<p>public class ShellCommandExec {</p>\n<pre><code>public static void main(String[] args) {\n    String gnomeOpenCommand = &quot;gnome-open //home//user//Documents//MyDoc.pdf&quot;;\n\n    try {\n        Runtime rt = Runtime.getRuntime();\n        Process processObj = rt.exec(gnomeOpenCommand);\n\n        InputStream stdin = processObj.getErrorStream();\n        InputStreamReader isr = new InputStreamReader(stdin);\n        BufferedReader br = new BufferedReader(isr);\n\n        String myoutput = &quot;&quot;;\n\n        while ((myoutput=br.readLine()) != null) {\n            myoutput = myoutput+&quot;/n&quot;;\n        }\n        System.out.println(myoutput);\n    }\n    catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n</code></pre><p>}<br>使用正则</p>\n<p>正则表达式的结构摘录如下（来源: Oracle官网）</p>\n<p>字符</p>\n<p>x    字符x<br>/    反斜杠<br>/0n    8进制值为0n的字符(0&lt;=n&lt;=7)<br>/0nn<br>/0mnn    8进制值为0mnn的字符(0 &lt;= m &lt;= 3, 0&lt;=n&lt;=7)<br>/xhh    16进制值为0xhh的字符<br>/uhhhh    16进制值为0xhhhh的字符<br>/x{h…h}    16进制值为0xh…h的字符(Character.MINCODEPOINT &lt;= 0xh…h &lt;= Character.MAXCODEPOINT)<br>/t    制表符(‘/u0009′)<br>/n    换行符(‘/u000A’)<br>/r    回车(‘/u000D’)<br>/f    分页符(‘/u000C’)<br>/a    警告符(‘/u0007′)<br>/e    ESC(‘/u001B’)<br>/cx    ctrl+x<br>字符分类</p>\n<p>[abc]    a, b或c<br>[^abc]    abc以外的任意字符<br>[a-zA-Z]    a到z以及A到Z<br>[a-d[m-p]]    a到d或者m到p[a-dm-p]则是取并集<br>[a-z&amp;&amp;[def]]    d,e或f(交集)<br>[ad-z]<br>[a-z&amp;&amp;[^bc]]    a到z但不包括b和c<br>[a-z&amp;&amp;[^m-p]]    a到z但不包括mp:也就是[a-lq-z]<br>预定义字符</p>\n<p>.    任意字符，有可能包括换行符<br>/d    0到9的数字<br>/D    0到9以外的字符<br>/s    空格符[ /t/n/x0B/f/r]<br>/S    非空格符[^/s]<br>/w    字母[a-zA-Z_0-9]<br>/W    非字母[^/w]<br>边界匹配</p>\n<p>^    行首<br>$    行末<br>/b    单词边界<br>/A    输入的起始位置<br>/G    前一个匹配的末尾<br>/Z    输入的结束位置，仅用于最后的结束符<br>/z    输入的结束位置<br>import java.util.regex.Matcher;<br>import java.util.regex.Pattern;</p>\n<p>public class RegexMatches<br>{<br>    private static String pattern =  “^[_A-Za-z0-9-]+(//.[_A-Za-z0-9-]+)<em>@[A-Za-z0-9]+(//.[A-Za-z0-9]+)</em>(//.[A-Za-z]{2,})$”;<br>    private static Pattern mypattern = Pattern.compile(pattern);</p>\n<pre><code>public static void main( String args[] ){\n\n    String valEmail1 = &quot;testemail@domain.com&quot;;\n    String invalEmail1 = &quot;....@domain.com&quot;;\n    String invalEmail2 = &quot;.$$%%@domain.com&quot;;\n    String valEmail2 = &quot;test.email@domain.com&quot;;\n\n    System.out.println(&quot;Is Email ID1 valid? &quot;+validateEMailID(valEmail1));\n    System.out.println(&quot;Is Email ID1 valid? &quot;+validateEMailID(invalEmail1));\n    System.out.println(&quot;Is Email ID1 valid? &quot;+validateEMailID(invalEmail2));\n    System.out.println(&quot;Is Email ID1 valid? &quot;+validateEMailID(valEmail2));\n\n}\n\npublic static boolean validateEMailID(String emailID) {\n    Matcher mtch = mypattern.matcher(emailID);\n    if(mtch.matches()){\n        return true;\n    }\n    return false;\n}\n</code></pre><p>}<br>Java Swing的简单示例</p>\n<p>有了Java的swing，你便可以编写GUI应用了。Java所提供的javax包中就包含了swing。使用swing来编写GUI程序首先需要继承下JFrame。然后在里面添加Box，然后便可以往里面添加诸如按钮，多选按钮，文本框等控件了。这些Box是放在Container的最外层的。</p>\n<p>import java.awt.<em>;<br>import javax.swing.</em>;</p>\n<p>public class SwingsDemo extends JFrame<br>{<br>    public SwingsDemo()<br>    {<br>        String path = “//home//user//Documents//images”;<br>        Container contentPane = getContentPane();<br>        contentPane.setLayout(new FlowLayout());</p>\n<pre><code>    Box myHorizontalBox = Box. createHorizontalBox();\n    Box myVerticleBox = Box. createVerticalBox();\n\n    myHorizontalBox.add(new JButton(&quot;My Button 1&quot;));\n    myHorizontalBox.add(new JButton(&quot;My Button 2&quot;));\n    myHorizontalBox.add(new JButton(&quot;My Button 3&quot;));\n\n    myVerticleBox.add(new JButton(new ImageIcon(path + &quot;//Image1.jpg&quot;)));\n    myVerticleBox.add(new JButton(new ImageIcon(path + &quot;//Image2.jpg&quot;)));\n    myVerticleBox.add(new JButton(new ImageIcon(path + &quot;//Image3.jpg&quot;)));\n\n    contentPane.add(myHorizontalBox);\n    contentPane.add(myVerticleBox);\n\n    pack();\n    setVisible(true);\n}\n\npublic static void main(String args[]) {\n    new SwingsDemo();\n}\n</code></pre><p>}<br>使用Java播放音频</p>\n<p>在Java中，播放音频是一个很常见的需求，尤其是在游戏开发里面。</p>\n<p>下面这个DEMO演示了如何在Java中播放音频。</p>\n<p>import java.io.<em>;<br>import java.net.URL;<br>import javax.sound.sampled.</em>;<br>import javax.swing.*;</p>\n<p>// To play sound using Clip, the process need to be alive.<br>// Hence, we use a Swing application.<br>public class playSoundDemo extends JFrame {</p>\n<p>   // Constructor<br>   public playSoundDemo() {<br>      this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br>      this.setTitle(“Play Sound Demo”);<br>      this.setSize(300, 200);<br>      this.setVisible(true);</p>\n<pre><code>try {\n   URL url = this.getClass().getResource(&quot;MyAudio.wav&quot;);\n   AudioInputStream audioIn = AudioSystem.getAudioInputStream(url);\n   Clip clip = AudioSystem.getClip();\n   clip.open(audioIn);\n   clip.start();\n} catch (UnsupportedAudioFileException e) {\n   e.printStackTrace();\n} catch (IOException e) {\n   e.printStackTrace();\n} catch (LineUnavailableException e) {\n   e.printStackTrace();\n}\n</code></pre><p>   }</p>\n<p>   public static void main(String[] args) {<br>      new playSoundDemo();<br>   }<br>}<br>导出PDF文件</p>\n<p>将表格导出成pdf也是一个比较常见的需求。通过itextpdf，导出pdf也不是什么难事。</p>\n<p>import java.io.FileOutputStream;<br>import com.itextpdf.text.Document;<br>import com.itextpdf.text.Paragraph;<br>import com.itextpdf.text.pdf.PdfPCell;<br>import com.itextpdf.text.pdf.PdfPTable;<br>import com.itextpdf.text.pdf.PdfWriter;</p>\n<p>public class DrawPdf {</p>\n<pre><code>  public static void main(String[] args) throws Exception {\n    Document document = new Document();\n    PdfWriter.getInstance(document, new FileOutputStream(&quot;Employee.pdf&quot;));\n    document.open();\n\n    Paragraph para = new Paragraph(&quot;Employee Table&quot;);\n    para.setSpacingAfter(20);\n    document.add(para);\n\n    PdfPTable table = new PdfPTable(3);\n    PdfPCell cell = new PdfPCell(new Paragraph(&quot;First Name&quot;));\n\n    table.addCell(cell);\n    table.addCell(&quot;Last Name&quot;);\n    table.addCell(&quot;Gender&quot;);\n    table.addCell(&quot;Ram&quot;);\n    table.addCell(&quot;Kumar&quot;);\n    table.addCell(&quot;Male&quot;);\n    table.addCell(&quot;Lakshmi&quot;);\n    table.addCell(&quot;Devi&quot;);\n    table.addCell(&quot;Female&quot;);\n\n    document.add(table);\n\n    document.close();\n  }\n}\n</code></pre><p>邮件发送</p>\n<p>在Java中发送邮件也很简单。你只需装一下Java Mail这个jar包，放到你的类路径里即可。在下面的代码中，我们设置了几个基础属性，然后便可以发送邮件了：</p>\n<p>import java.util.<em>;<br>import javax.mail.</em>;<br>import javax.mail.internet.*;</p>\n<p>public class SendEmail<br>{<br>    public static void main(String [] args)<br>    {<br>        String to = “recipient@gmail.com”;<br>        String from = “sender@gmail.com”;<br>        String host = “localhost”;</p>\n<pre><code>    Properties properties = System.getProperties();\n    properties.setProperty(&quot;mail.smtp.host&quot;, host);\n    Session session = Session.getDefaultInstance(properties);\n\n    try{\n        MimeMessage message = new MimeMessage(session);\n        message.setFrom(new InternetAddress(from));\n\n        message.addRecipient(Message.RecipientType.TO,new InternetAddress(to));\n\n        message.setSubject(&quot;My Email Subject&quot;);\n        message.setText(&quot;My Message Body&quot;);\n        Transport.send(message);\n        System.out.println(&quot;Sent successfully!&quot;);\n    }\n    catch (MessagingException ex) {\n        ex.printStackTrace();\n    }\n}\n</code></pre><p>}<br>计算时间</p>\n<p>许多程序都需要精确的时间计量。Java提供了一个System的静态方法来支持这一功能：</p>\n<p>currentTimeMillis()：返回当前时间自新纪元时间以来的毫秒值，long类型。</p>\n<p>long startTime = System.currentTimeMillis();<br>long estimatedTime = System.currentTimeMillis() - startTime;<br>nanoTime()：返回系统计时器当前的精确时间，纳秒值，这也是long类型。nanoTime()主要是用于计算相对时间而非绝对时间。</p>\n<p>long startTime = System.nanoTime();<br>long estimatedTime = System.nanoTime() - startTime;<br>图片缩放</p>\n<p>图片缩放可以通过AffineTransform来完成。首先要生成一个输入图片的图片缓冲，然后通过它来渲染出缩放后的图片。</p>\n<p>import java.awt.Graphics2D;<br>import java.awt.geom.AffineTransform;<br>import java.awt.image.BufferedImage;<br>import java.io.File;<br>import javax.imageio.ImageIO;</p>\n<p>public class RescaleImage {<br>  public static void main(String[] args) throws Exception {<br>    BufferedImage imgSource = ImageIO.read(new File(“images//Image3.jpg”));<br>    BufferedImage imgDestination = new BufferedImage(100, 100, BufferedImage.TYPE_INT_RGB);<br>    Graphics2D g = imgDestination.createGraphics();<br>    AffineTransform affinetransformation = AffineTransform.getScaleInstance(2, 2);<br>    g.drawRenderedImage(imgSource, affinetransformation);<br>    ImageIO.write(imgDestination, “JPG”, new File(“outImage.jpg”));<br>  }<br>}<br>捕获鼠标动作</p>\n<p>实现了MouseMotionListner接口后，便可以捕获鼠标事件了。 当鼠标进入到某个特定区域时便会触发MouseMoved事件，你便能捕获到这个移动的动作了。通过一个例子来看下：</p>\n<p>import java.awt.event.<em>;<br>import javax.swing.</em>;</p>\n<p>public class MouseCaptureDemo extends JFrame implements MouseMotionListener<br>{<br>    public JLabel mouseHoverStatus;</p>\n<pre><code>public static void main(String args[])\n{\n    new MouseCaptureDemo();\n}\n\nMouseCaptureDemo()\n{\n    setSize(500, 500);\n    setTitle(&quot;Frame displaying Coordinates of Mouse Motion&quot;);\n\n    mouseHoverStatus = new JLabel(&quot;No Mouse Hover Detected.&quot;, JLabel.CENTER);\n    add(mouseHoverStatus);\n    addMouseMotionListener(this);\n    setVisible(true);\n}\n\npublic void mouseMoved(MouseEvent e)\n{\n    mouseHoverStatus.setText(&quot;Mouse Cursor Coordinates =&gt; X:&quot;+e.getX()+&quot; | Y:&quot;+e.getY());\n}\n\npublic void mouseDragged(MouseEvent e)\n{}\n</code></pre><p>}<br>FileOutputStream Vs. FileWriter</p>\n<p>在Java中有两种写文件的方式：FileOutputStream与FileWriter。开发人员经常会在它们之间犹豫不决。下面这个例子能帮忙你更好地理解在不同的场景下应该选择何种方案。首先我们来看一下实现：</p>\n<p>使用FileOutputStream：</p>\n<p>File foutput = new File(file_location_string);<br>FileOutputStream fos = new FileOutputStream(foutput);<br>BufferedWriter output = new BufferedWriter(new OutputStreamWriter(fos));<br>output.write(“Buffered Content”);<br>使用FileWriter：</p>\n<p>FileWriter fstream = new FileWriter(file_location_string);<br>BufferedWriter output = new BufferedWriter(fstream);<br>output.write(“Buffered Content”);<br>根据Java的接口规范：</p>\n<p>FileOutputStream是用于写入原始字节流比如图片流数据。如果是要写入字符流，则应该考虑使用FileWriter。</p>\n<p>这样就很清楚了，写图片应该使用FileOutputStream而写文本则应该选择FileWriter。</p>\n<p>附加建议</p>\n<p>集合的使用</p>\n<p>Java提供了许多集合类——比如，Vector，Stack，Hashtable等。所以鼓励开发人员尽可能地使用这些集合类有如下原因：</p>\n<p>使用集合使得代码的可重用度更高。<br>集合类使得代码的结构更良好，更易于理解与维护。<br>最重要的是这些集合类都经过充分的测试，代码质量很高。<br>1-50-500规则</p>\n<p>在大型软件系统中，代码的可维护性是件很有挑战的工作。新加入的开发人员经常会抱怨这些情况：单片代码（Monolithic Code）,意大利面式代码（spaghetti code, 常用于描述捆绑在一起并且低内聚的类和方法）。保持代码的整洁与可维护有一条很简单的规则：</p>\n<p>10：包内的类不超过10个<br>50：方法的代码行数不超过50<br>500：类的代码行数不超过500<br>SOLID设计准则<br>SOLID是Robert Martin提出的一套设计准则的简称。根据他的准则：<br>一个类应当有仅只有一个任务/职责。执行多个任务的类会让人觉得困惑。</p>\n<p>单一职责原则<br>开闭原则    开发人员应当优先考虑扩展现有的软件功能，而不是是修改它。<br>里氏替换原则    子类必须能够替换掉他们的父类型<br>接口隔离原则    和单一职责原则类似，但它特指的是接口层。每个接口都应当只负责一项任务。<br>依赖反转原则    依赖抽象而不是具体实现。也就是说每个模块都应当通过一个抽象层与其它模块进行解耦。<br>设计模式的使用</p>\n<p>设计模式能帮助开发人员更好地在软件中应用软件的设计准则。它还为开发人员提供了跨语言的通用平台。设计模式中的标准术语能让开发人员更容易进行沟通。</p>\n<p>关于文档</p>\n<p>不要上来就开始写代码。制定计划，准备，编写文档，检查然后再去实现。首先，先把需求记下来。然后去准备设计文档。合理地去假设举证。互相review方案然后进行确认。</p>\n<p>使用equals而非==</p>\n<p>==是用来比较对象引用的，它会检查两个操作数指向的是不是同一个对象（不是相同的对象，而是同一个对象）。而”equals”则比较的是两个字符串是不是相同（假设是字符串对象）。</p>\n<p>避免使用浮点数</p>\n<p>只有当确实有必要的时候才使用浮点数。比方说，使用浮点数来表示卢比或者派萨就很容易产生问题——这种情况应当使用BigDecimal。而浮点数更多地是用于测量。</p>\n","excerpt":"<blockquote>\n<p>Java是目前最流行的编程语言之一——它可以用来编写Windows程序或者是Web应用，移动应用，网络程序，消费电子产品，机顶盒设备，它无处不在。<br>有超过30亿的设备是运行在Java之上的。根据Oracle的统计数据，光是使用中的Java Card就有有50亿。超过900万程序员选择使用Java进行开发，它是最受开发人员欢迎的语言，同时也是最流行的开发平台。<br>本文为那些准Java程序员们准备了一系列广为流传的Java最佳编程实践<br></p></blockquote>","more":"<p></p>\n<h4 id=\"优先返回空集合而非null\"><a href=\"#优先返回空集合而非null\" class=\"headerlink\" title=\"优先返回空集合而非null\"></a>优先返回空集合而非null</h4><p>如果程序要返回一个不包含任何值的集合，确保返回的是空集合而不是null。这能节省大量的”if else”检查。<br><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">getLocationName</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"literal\">null</span>==cityName ? <span class=\"string\">\"\"</span>: cityName);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n\n<h4 id=\"谨慎操作字符串\"><a href=\"#谨慎操作字符串\" class=\"headerlink\" title=\"谨慎操作字符串\"></a>谨慎操作字符串</h4><p>如果两个字符串在for循环中使用+操作符进行拼接，那么每次循环都会产生一个新的字符串对象。这不仅浪费内存空间同时还会影响性能。类似的，如果初始化字符串对象，尽量不要使用构造方法，而应该直接初始化。比方说：<br><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Slower Instantiation</span></div><div class=\"line\"><span class=\"keyword\">String</span> bad = <span class=\"keyword\">new</span> <span class=\"keyword\">String</span>(<span class=\"string\">\"Yet another string object\"</span>);</div><div class=\"line\"><span class=\"comment\">//Faster Instantiation</span></div><div class=\"line\"><span class=\"keyword\">String</span> good = <span class=\"string\">\"Yet another string object\"</span></div><div class=\"line\">避免无用对象</div></pre></td></tr></table></figure></p>\n<p>创建对象是Java中最昂贵的操作之一。因此最好在有需要的时候再进行对象的创建/初始化。如下：<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">import</span> java.util.ArrayList;</span></div><div class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">import</span> java.util.List;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employees</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> List Employees;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> List getEmployees() &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//initialize only when required</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span> == Employees) &#123;</div><div class=\"line\">            Employees = <span class=\"keyword\">new</span> ArrayList();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> Employees;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"数组与ArrayList之争\"><a href=\"#数组与ArrayList之争\" class=\"headerlink\" title=\"数组与ArrayList之争\"></a>数组与ArrayList之争</h4><p>开发人员经常会发现很难在数组和ArrayList间做选择。它们二者互有优劣。如何选择应该视情况而定。</p>\n<p>import java.util.ArrayList;</p>\n<p>public class arrayVsArrayList {</p>\n<pre><code>public static void main(String[] args) {\n    int[] myArray = new int[6];\n    myArray[7]= 10; // ArraysOutOfBoundException\n\n    //Declaration of ArrayList. Add and Remove of elements is easy.\n    ArrayList&lt;Integer&gt; myArrayList = new ArrayList&lt;&gt;();\n    myArrayList.add(1);\n    myArrayList.add(2);\n    myArrayList.add(3);\n    myArrayList.add(4);\n    myArrayList.add(5);\n    myArrayList.remove(0);\n\n    for(int i = 0; i &lt; myArrayList.size(); i++) {\n    System.out.println(&quot;Element: &quot; + myArrayList.get(i));\n    }\n\n    //Multi-dimensional Array\n    int[][][] multiArray = new int [3][3][3];\n}\n</code></pre><p>}<br>数组是定长的，而ArrayList是变长的。由于数组长度是固定的，因此在声明数组时就已经分配好内存了。而数组的操作则会更快一些。另一方面，如果我们不知道数据的大小，那么过多的数据便会导致ArrayOutOfBoundException，而少了又会浪费存储空间。<br>ArrayList在增删元素方面要比数组简单。<br>数组可以是多维的，但ArrayList只能是一维的。<br>try块的finally块没有被执行<br>看下下面这段代码：</p>\n<p>public class shutDownHooksDemo {<br>    public static void main(String[] args) {<br>        for(int i=0;i&lt;5;i++)<br>        {<br>            try {<br>                if(i==4) {<br>                    System.out.println(“Inside Try Block.Exiting without executing Finally block.”);<br>                    System.exit(0);<br>                }<br>            }<br>            finally {<br>                System.out.println(“Inside Finally Block.”);<br>            }<br>        }<br>    }<br>}<br>从代码来看，貌似finally块中的println语句应该会被执行5次。但当程序运行后，你会发现finally块只执行了4次。第5次迭代的时候会触发exit函数的调用，于是这第5次的finally便永远也触发不到了。原因便是——System.exit会挂起所有线程的执行，包括当前线程。即便是try语句后的finally块，只要是执行了exit，便也无力回天了。</p>\n<p>在调用System.exit时，JVM会在关闭前执行两个结束任务：</p>\n<p>首先，它会执行完所有通过Runtime.addShutdownHook注册进来的终止的钩子程序。这一点很关键，因为它会释放JVM外部的资源。</p>\n<p>接下来的便是Finalizer了。可能是System.runFinalizersOnExit也可能是Runtime.runFinalizersOnExit。finalizer的使用已经被废弃有很长一段时间了。finalizer可以在存活对象上进行调用，即便是这些对象仍在被其它线程所使用。而这会导致不可预期的结果甚至是死锁。</p>\n<p>public class shutDownHooksDemo {</p>\n<pre><code>public static void main(String[] args) {\n        for(int i=0;i&lt;5;i++)\n        {\n                final int final_i = i;\n                try {\n                        Runtime.getRuntime().addShutdownHook(\n                                        new Thread() {\n                                        public void run() {\n                                        if(final_i==4) {\n                                        System.out.println(&quot;Inside Try Block.Exiting without executing Finally block.&quot;);\n                                        System.exit(0);\n                                        }\n                                        }\n                                        });\n                }\n                finally {\n                        System.out.println(&quot;Inside Finally Block.&quot;);\n                }\n\n        }\n}\n</code></pre><p>}<br>判断奇数</p>\n<p>看下这几行代码，看看它们是否能用来准确地判断一个数是奇数？</p>\n<p>public boolean oddOrNot(int num) {<br>    return num % 2 == 1;<br>}<br>看似是对的，但是每执行四便会有一个错误的结果（用数据说话）。考虑到负奇数的情况，它除以2的结果就不会是1。因此，返回值是false，而这样是不对的。</p>\n<p>代码可以修改成这样：</p>\n<p>public boolean oddOrNot(int num) {<br>    return (num &amp; 1) != 0;<br>}<br>这么写不光是负奇数的问题解决了，并且还是经过充分优化过的。因为算术运算和逻辑运行要比乘除运算更高效，计算的结果也会更快。</p>\n<p>单引号与双引号的区别</p>\n<p>public class Haha {<br>    public static void main(String args[]) {<br>    System.out.print(“H” + “a”);<br>    System.out.print(‘H’ + ‘a’);<br>    }<br>}<br>看起来这段代码会返回”Haha”,但实际返回的是Ha169。原因就是用了双引号的时候，字符会被当作字符串处理，而如果是单引号的话，字符值会通过一个叫做基础类型拓宽的操作来转换成整型值。然后再将值相加得到169。</p>\n<p>一些防止内存泄露的小技巧</p>\n<p>内存泄露会导致软件的性能降级。由于Java是自动管理内存的，因此开发人员并没有太多办法介入。不过还是有一些方法能够用来防止内存泄露的。</p>\n<p>查询完数据后立即释放数据库连接<br>尽可能使用finally块<br>释放静态变量中的实例<br>避免死锁<br>死锁出现的原因有很多。避免死锁不是一句话就能解决的。通常来说，当某个同步对象在等待另一个同步对象所拥有的资源上的锁时，便会产生死锁。</p>\n<p>试着运行下下面的程序。它会告诉你什么是死锁。这个死锁是由于两个线程都在等待对方所拥有的资源，因此会产生死锁。它们会一直等待，没有谁会先放手。</p>\n<p>public class DeadlockDemo {<br>   public static Object addLock = new Object();<br>   public static Object subLock = new Object();</p>\n<p>   public static void main(String args[]) {</p>\n<pre><code>MyAdditionThread add = new MyAdditionThread();\nMySubtractionThread sub = new MySubtractionThread();\nadd.start();\nsub.start();\n</code></pre><p>   }<br>private static class MyAdditionThread extends Thread {<br>      public void run() {<br>         synchronized (addLock) {<br>        int a = 10, b = 3;<br>        int c = a + b;<br>            System.out.println(“Addition Thread: “ + c);<br>            System.out.println(“Holding First Lock…”);<br>            try { Thread.sleep(10); }<br>            catch (InterruptedException e) {}<br>            System.out.println(“Addition Thread: Waiting for AddLock…”);<br>            synchronized (subLock) {<br>               System.out.println(“Threads: Holding Add and Sub Locks…”);<br>            }<br>         }<br>      }<br>   }<br>   private static class MySubtractionThread extends Thread {<br>      public void run() {<br>         synchronized (subLock) {<br>        int a = 10, b = 3;<br>        int c = a - b;<br>            System.out.println(“Subtraction Thread: “ + c);<br>            System.out.println(“Holding Second Lock…”);<br>            try { Thread.sleep(10); }<br>            catch (InterruptedException e) {}<br>            System.out.println(“Subtraction  Thread: Waiting for SubLock…”);<br>            synchronized (addLock) {<br>               System.out.println(“Threads: Holding Add and Sub Locks…”);<br>            }<br>         }<br>      }<br>   }<br>}<br>输出：</p>\n<p>Addition Thread: 13<br>Subtraction Thread: 7<br>Holding First Lock…<br>Holding Second Lock…<br>Addition Thread: Waiting for AddLock…<br>Subtraction  Thread: Waiting for SubLock…<br>但如果调用的顺序变一下的话，死锁的问题就解决了。</p>\n<p>public class DeadlockSolutionDemo {<br>   public static Object addLock = new Object();<br>   public static Object subLock = new Object();</p>\n<p>   public static void main(String args[]) {</p>\n<pre><code>MyAdditionThread add = new MyAdditionThread();\nMySubtractionThread sub = new MySubtractionThread();\nadd.start();\nsub.start();\n</code></pre><p>   }</p>\n<p>private static class MyAdditionThread extends Thread {<br>      public void run() {<br>         synchronized (addLock) {<br>        int a = 10, b = 3;<br>        int c = a + b;<br>            System.out.println(“Addition Thread: “ + c);<br>            System.out.println(“Holding First Lock…”);<br>            try { Thread.sleep(10); }<br>            catch (InterruptedException e) {}<br>            System.out.println(“Addition Thread: Waiting for AddLock…”);<br>            synchronized (subLock) {<br>               System.out.println(“Threads: Holding Add and Sub Locks…”);<br>            }<br>         }<br>      }<br>   }</p>\n<p>   private static class MySubtractionThread extends Thread {<br>      public void run() {<br>         synchronized (addLock) {<br>        int a = 10, b = 3;<br>        int c = a - b;<br>            System.out.println(“Subtraction Thread: “ + c);<br>            System.out.println(“Holding Second Lock…”);<br>            try { Thread.sleep(10); }<br>            catch (InterruptedException e) {}<br>            System.out.println(“Subtraction  Thread: Waiting for SubLock…”);<br>            synchronized (subLock) {<br>               System.out.println(“Threads: Holding Add and Sub Locks…”);<br>            }<br>         }<br>      }<br>   }<br>}<br>输出：</p>\n<p>Addition Thread: 13<br>Holding First Lock…<br>Addition Thread: Waiting for AddLock…<br>Threads: Holding Add and Sub Locks…<br>Subtraction Thread: 7<br>Holding Second Lock…<br>Subtraction  Thread: Waiting for SubLock…<br>Threads: Holding Add and Sub Locks…<br>替Java省点内存</p>\n<p>某些Java程序是CPU密集型的，但它们会需要大量的内存。这类程序通常运行得很缓慢，因为它们对内存的需求很大。为了能提升这类应用的性能，可得给它们多留点内存。因此，假设我们有一台拥有10G内存的Tomcat服务器。在这台机器上，我们可以用如下的这条命令来分配内存:</p>\n<p>export JAVA_OPTS=”$JAVA_OPTS -Xms5000m -Xmx6000m -XX:PermSize=1024m -XX:MaxPermSize=2048m”<br>Xms = 最小内存分配<br>Xmx = 最大内存分配<br>XX:PermSize = JVM启动时的初始大小<br>XX:MaxPermSize = JVM启动后可分配的最大空间<br>如何计算Java中操作的耗时<br>在Java中进行操作计时有两个标准的方法：System.currentTimeMillis()和System.nanoTime()。问题就在于，什么情况下该用哪个。从本质上来讲，他们的作用都是一样的，但有以下几点不同：</p>\n<p>System.currentTimeMillis()的精度在千分之一秒到千分之15秒之间（取决于系统）而System.nanoTime()则能到纳秒级。<br>System.currentTimeMillis读操作耗时在数个CPU时钟左右。而System.nanoTime()则需要上百个。<br>System.currentTimeMillis对应的是绝对时间（1970年1 月1日所经历的毫秒数），而System.nanoTime()则不与任何时间点相关。<br>Float还是double<br>数据类型    所用字节    有效位数<br>float    4    7<br>double    8    15<br>在对精度要求高的场景下，double类型相对float要更流行一些，理由如下：</p>\n<p>大多数处理器在处理float和double上所需的时间都是差不多的。而计算时间一样的前提下，double类型却能提供更高的精度。</p>\n<p>幂运算</p>\n<p>Java是通过异或操作来进行幂运算的。Java对于幂运算有两种处理方式：</p>\n<p>乘积：</p>\n<p>double square = double a <em> double a;                           // Optimized<br>double cube = double a </em> double a <em> double a;                   // Non-optimized<br>double cube = double a </em> double square;                       // Optimized<br>double quad = double a <em> double a </em> double a <em> double a;          // Non-optimized<br>double quad = double square </em> double square;                  // Optimized<br>pow方法：在无法使用乘积的情况下可以使用pow方法。</p>\n<p>double cube = Math.pow(base, exponent);<br>不到万不得已不要使用Math.pow。比方说，当指数是小数的时候。因为Math.pow要比乘积慢300-600倍左右。</p>\n<p>如何处理空指针异常</p>\n<p>空指针异常是Java中很常见的异常。当你尝试调用一个null对象上的方法时便会抛出这个异常。比如：</p>\n<p>int noOfStudents = school.listStudents().count;<br>在上述例子中，school为空或者listStudents()为空都可能会抛出了NullPointerException。因此最好检查下对象是否为空以避免类似情况。</p>\n<p>private int getListOfStudents(File[] files) {<br>      if (files == null)<br>        throw new NullPointerException(“File list cannot be null”);<br>    }<br>JSON编码</p>\n<p>JSON是数据存储及传输的一种协议。与XML相比，它更易于使用。由于它非常轻量级以及自身的一些特性，现在JSON在网络上已经是越来越流行了。常见的数据结构都可以编码成JSON然后在各个网页间自由地传输。不过在开始编码前，你得先安装一个JSON解析器。在下面的例子中，我们将使用json.simple库来完成这项工作 (<a href=\"https://code.google.com/p/json-simple/)。\">https://code.google.com/p/json-simple/)。</a></p>\n<p>下面是编码成JSON串的一个简单的例子。</p>\n<p>import org.json.simple.JSONObject;<br>import org.json.simple.JSONArray;</p>\n<p>public class JsonEncodeDemo {</p>\n<pre><code>public static void main(String[] args) {\n\n    JSONObject obj = new JSONObject();\n    obj.put(&quot;Novel Name&quot;, &quot;Godaan&quot;);\n    obj.put(&quot;Author&quot;, &quot;Munshi Premchand&quot;);\n\n    JSONArray novelDetails = new JSONArray();\n    novelDetails.add(&quot;Language: Hindi&quot;);\n    novelDetails.add(&quot;Year of Publication: 1936&quot;);\n    novelDetails.add(&quot;Publisher: Lokmanya Press&quot;);\n\n    obj.put(&quot;Novel Details&quot;, novelDetails);\n\n    System.out.print(obj);\n}\n</code></pre><p>}<br>输出：</p>\n<p>{“Novel Name”:”Godaan”,”Novel Details”:[“Language: Hindi”,”Year of Publication: 1936”,”Publisher: Lokmanya Press”],”Author”:”Munshi Premchand”}<br>JSON解析</p>\n<p>开发人员要想解析JSON串，首先你得知道它的格式。下面例子有助于你来理解这一点：</p>\n<p>import java.io.FileNotFoundException;<br>import java.io.FileReader;<br>import java.io.IOException;<br>import java.util.Iterator;</p>\n<p>import org.json.simple.JSONArray;<br>import org.json.simple.JSONObject;<br>import org.json.simple.parser.JSONParser;<br>import org.json.simple.parser.ParseException;</p>\n<p>public class JsonParseTest {</p>\n<pre><code>private static final String filePath = &quot;//home//user//Documents//jsonDemoFile.json&quot;;\n\npublic static void main(String[] args) {\n\n    try {\n        // read the json file\n        FileReader reader = new FileReader(filePath);\n        JSONParser jsonParser = new JSONParser();\n        JSONObject jsonObject = (JSONObject)jsonParser.parse(reader);\n\n        // get a number from the JSON object\n        Long id =  (Long) jsonObject.get(&quot;id&quot;);\n        System.out.println(&quot;The id is: &quot; + id);\n\n        // get a String from the JSON object\n        String   type = (String) jsonObject.get(&quot;type&quot;);\n        System.out.println(&quot;The type is: &quot; + type);\n\n        // get a String from the JSON object\n        String   name = (String) jsonObject.get(&quot;name&quot;);\n        System.out.println(&quot;The name is: &quot; + name);\n\n        // get a number from the JSON object\n        Double ppu =  (Double) jsonObject.get(&quot;ppu&quot;);\n        System.out.println(&quot;The PPU is: &quot; + ppu);\n\n        // get an array from the JSON object\n        System.out.println(&quot;Batters:&quot;);\n        JSONArray batterArray= (JSONArray) jsonObject.get(&quot;batters&quot;);\n        Iterator i = batterArray.iterator();\n        // take each value from the json array separately\n        while (i.hasNext()) {\n            JSONObject innerObj = (JSONObject) i.next();\n            System.out.println(&quot;ID &quot;+ innerObj.get(&quot;id&quot;) +\n                    &quot; type &quot; + innerObj.get(&quot;type&quot;));\n        }\n\n        // get an array from the JSON object\n        System.out.println(&quot;Topping:&quot;);\n        JSONArray toppingArray= (JSONArray) jsonObject.get(&quot;topping&quot;);\n        Iterator j = toppingArray.iterator();\n        // take each value from the json array separately\n        while (j.hasNext()) {\n            JSONObject innerObj = (JSONObject) j.next();\n            System.out.println(&quot;ID &quot;+ innerObj.get(&quot;id&quot;) +\n                    &quot; type &quot; + innerObj.get(&quot;type&quot;));\n        }\n\n    } catch (FileNotFoundException ex) {\n        ex.printStackTrace();\n    } catch (IOException ex) {\n        ex.printStackTrace();\n    } catch (ParseException ex) {\n        ex.printStackTrace();\n    } catch (NullPointerException ex) {\n        ex.printStackTrace();\n    }\n\n}\n</code></pre><p>}<br>jsonDemoFile.json</p>\n<p>{<br>    “id”: 0001,<br>    “type”: “donut”,<br>    “name”: “Cake”,<br>    “ppu”: 0.55,<br>    “batters”:<br>        [<br>            { “id”: 1001, “type”: “Regular” },<br>            { “id”: 1002, “type”: “Chocolate” },<br>            { “id”: 1003, “type”: “Blueberry” },<br>            { “id”: 1004, “type”: “Devil’s Food” }<br>        ],<br>    “topping”:<br>        [<br>            { “id”: 5001, “type”: “None” },<br>            { “id”: 5002, “type”: “Glazed” },<br>            { “id”: 5005, “type”: “Sugar” },<br>            { “id”: 5007, “type”: “Powdered Sugar” },<br>            { “id”: 5006, “type”: “Chocolate with Sprinkles” },<br>            { “id”: 5003, “type”: “Chocolate” },<br>            { “id”: 5004, “type”: “Maple” }<br>        ]<br>}<br>The id is: 1<br>The type is: donut<br>The name is: Cake<br>The PPU is: 0.55<br>Batters:<br>ID 1001 type Regular<br>ID 1002 type Chocolate<br>ID 1003 type Blueberry<br>ID 1004 type Devil’s Food<br>Topping:<br>ID 5001 type None<br>ID 5002 type Glazed<br>ID 5005 type Sugar<br>ID 5007 type Powdered Sugar<br>ID 5006 type Chocolate with Sprinkles<br>ID 5003 type Chocolate<br>ID 5004 type Maple<br>简单字符串查找</p>\n<p>Java提供了一个库函数叫做indexOf()。这个方法可以用在String对象上，它返回的是要查找的字符串所在的位置序号。如果查找不到则会返回-1。</p>\n<p>列出目录下的文件</p>\n<p>你可以用下面的代码来列出目录下的文件。这个程序会遍历某个目录下的所有子目录及文件，并存储到一个数组里，然后通过遍历数组来列出所有文件。</p>\n<p>import java.io.*;</p>\n<p>public class ListContents {<br>    public static void main(String[] args) {<br>        File file = new File(“//home//user//Documents/“);<br>        String[] files = file.list();</p>\n<pre><code>    System.out.println(&quot;Listing contents of &quot; + file.getPath());\n    for(int i=0 ; i &lt; files.length ; i++)\n    {\n        System.out.println(files[i]);\n    }\n}\n</code></pre><p>}<br>一个简单的IO程序</p>\n<p>Java提供了FileInputStream以及FileOutputStream类来进行文件的读写操作。FileInputStream的构造方法会接收输入文件的路径作为入参然后创建出一个文件的输入流。同样的，FileOutputStream的构造方法也会接收一个文件路径作为入参然后创建出文件的输出流。在处理完文件之后，一个很重要的操作就是要记得”close”掉这些流。</p>\n<p>import java.io.*;</p>\n<p>public class myIODemo {<br>    public static void main(String args[]) throws IOException {<br>        FileInputStream in = null;<br>        FileOutputStream out = null;</p>\n<pre><code>    try {\n        in = new FileInputStream(&quot;//home//user//Documents//InputFile.txt&quot;);\n        out = new FileOutputStream(&quot;//home//user//Documents//OutputFile.txt&quot;);\n\n        int c;\n        while((c = in.read()) != -1) {\n            out.write(c);\n        }\n    } finally {\n        if(in != null) {\n            in.close();\n        }\n        if(out != null) {\n            out.close();\n        }\n    }\n}\n</code></pre><p>}<br>在Java中执行某个shell命令</p>\n<p>Java提供了Runtime类来执行shell命令。由于这些是外部的命令，因此异常处理就显得异常重要。在下面的例子中，我们将通过一个简单的例子来演示一下。我们会在shell命令行中打开一个pdf文件。</p>\n<p>import java.io.BufferedReader;<br>import java.io.InputStream;<br>import java.io.InputStreamReader;</p>\n<p>public class ShellCommandExec {</p>\n<pre><code>public static void main(String[] args) {\n    String gnomeOpenCommand = &quot;gnome-open //home//user//Documents//MyDoc.pdf&quot;;\n\n    try {\n        Runtime rt = Runtime.getRuntime();\n        Process processObj = rt.exec(gnomeOpenCommand);\n\n        InputStream stdin = processObj.getErrorStream();\n        InputStreamReader isr = new InputStreamReader(stdin);\n        BufferedReader br = new BufferedReader(isr);\n\n        String myoutput = &quot;&quot;;\n\n        while ((myoutput=br.readLine()) != null) {\n            myoutput = myoutput+&quot;/n&quot;;\n        }\n        System.out.println(myoutput);\n    }\n    catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n</code></pre><p>}<br>使用正则</p>\n<p>正则表达式的结构摘录如下（来源: Oracle官网）</p>\n<p>字符</p>\n<p>x    字符x<br>/    反斜杠<br>/0n    8进制值为0n的字符(0&lt;=n&lt;=7)<br>/0nn<br>/0mnn    8进制值为0mnn的字符(0 &lt;= m &lt;= 3, 0&lt;=n&lt;=7)<br>/xhh    16进制值为0xhh的字符<br>/uhhhh    16进制值为0xhhhh的字符<br>/x{h…h}    16进制值为0xh…h的字符(Character.MINCODEPOINT &lt;= 0xh…h &lt;= Character.MAXCODEPOINT)<br>/t    制表符(‘/u0009′)<br>/n    换行符(‘/u000A’)<br>/r    回车(‘/u000D’)<br>/f    分页符(‘/u000C’)<br>/a    警告符(‘/u0007′)<br>/e    ESC(‘/u001B’)<br>/cx    ctrl+x<br>字符分类</p>\n<p>[abc]    a, b或c<br>[^abc]    abc以外的任意字符<br>[a-zA-Z]    a到z以及A到Z<br>[a-d[m-p]]    a到d或者m到p[a-dm-p]则是取并集<br>[a-z&amp;&amp;[def]]    d,e或f(交集)<br>[ad-z]<br>[a-z&amp;&amp;[^bc]]    a到z但不包括b和c<br>[a-z&amp;&amp;[^m-p]]    a到z但不包括mp:也就是[a-lq-z]<br>预定义字符</p>\n<p>.    任意字符，有可能包括换行符<br>/d    0到9的数字<br>/D    0到9以外的字符<br>/s    空格符[ /t/n/x0B/f/r]<br>/S    非空格符[^/s]<br>/w    字母[a-zA-Z_0-9]<br>/W    非字母[^/w]<br>边界匹配</p>\n<p>^    行首<br>$    行末<br>/b    单词边界<br>/A    输入的起始位置<br>/G    前一个匹配的末尾<br>/Z    输入的结束位置，仅用于最后的结束符<br>/z    输入的结束位置<br>import java.util.regex.Matcher;<br>import java.util.regex.Pattern;</p>\n<p>public class RegexMatches<br>{<br>    private static String pattern =  “^[_A-Za-z0-9-]+(//.[_A-Za-z0-9-]+)<em>@[A-Za-z0-9]+(//.[A-Za-z0-9]+)</em>(//.[A-Za-z]{2,})$”;<br>    private static Pattern mypattern = Pattern.compile(pattern);</p>\n<pre><code>public static void main( String args[] ){\n\n    String valEmail1 = &quot;testemail@domain.com&quot;;\n    String invalEmail1 = &quot;....@domain.com&quot;;\n    String invalEmail2 = &quot;.$$%%@domain.com&quot;;\n    String valEmail2 = &quot;test.email@domain.com&quot;;\n\n    System.out.println(&quot;Is Email ID1 valid? &quot;+validateEMailID(valEmail1));\n    System.out.println(&quot;Is Email ID1 valid? &quot;+validateEMailID(invalEmail1));\n    System.out.println(&quot;Is Email ID1 valid? &quot;+validateEMailID(invalEmail2));\n    System.out.println(&quot;Is Email ID1 valid? &quot;+validateEMailID(valEmail2));\n\n}\n\npublic static boolean validateEMailID(String emailID) {\n    Matcher mtch = mypattern.matcher(emailID);\n    if(mtch.matches()){\n        return true;\n    }\n    return false;\n}\n</code></pre><p>}<br>Java Swing的简单示例</p>\n<p>有了Java的swing，你便可以编写GUI应用了。Java所提供的javax包中就包含了swing。使用swing来编写GUI程序首先需要继承下JFrame。然后在里面添加Box，然后便可以往里面添加诸如按钮，多选按钮，文本框等控件了。这些Box是放在Container的最外层的。</p>\n<p>import java.awt.<em>;<br>import javax.swing.</em>;</p>\n<p>public class SwingsDemo extends JFrame<br>{<br>    public SwingsDemo()<br>    {<br>        String path = “//home//user//Documents//images”;<br>        Container contentPane = getContentPane();<br>        contentPane.setLayout(new FlowLayout());</p>\n<pre><code>    Box myHorizontalBox = Box. createHorizontalBox();\n    Box myVerticleBox = Box. createVerticalBox();\n\n    myHorizontalBox.add(new JButton(&quot;My Button 1&quot;));\n    myHorizontalBox.add(new JButton(&quot;My Button 2&quot;));\n    myHorizontalBox.add(new JButton(&quot;My Button 3&quot;));\n\n    myVerticleBox.add(new JButton(new ImageIcon(path + &quot;//Image1.jpg&quot;)));\n    myVerticleBox.add(new JButton(new ImageIcon(path + &quot;//Image2.jpg&quot;)));\n    myVerticleBox.add(new JButton(new ImageIcon(path + &quot;//Image3.jpg&quot;)));\n\n    contentPane.add(myHorizontalBox);\n    contentPane.add(myVerticleBox);\n\n    pack();\n    setVisible(true);\n}\n\npublic static void main(String args[]) {\n    new SwingsDemo();\n}\n</code></pre><p>}<br>使用Java播放音频</p>\n<p>在Java中，播放音频是一个很常见的需求，尤其是在游戏开发里面。</p>\n<p>下面这个DEMO演示了如何在Java中播放音频。</p>\n<p>import java.io.<em>;<br>import java.net.URL;<br>import javax.sound.sampled.</em>;<br>import javax.swing.*;</p>\n<p>// To play sound using Clip, the process need to be alive.<br>// Hence, we use a Swing application.<br>public class playSoundDemo extends JFrame {</p>\n<p>   // Constructor<br>   public playSoundDemo() {<br>      this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br>      this.setTitle(“Play Sound Demo”);<br>      this.setSize(300, 200);<br>      this.setVisible(true);</p>\n<pre><code>try {\n   URL url = this.getClass().getResource(&quot;MyAudio.wav&quot;);\n   AudioInputStream audioIn = AudioSystem.getAudioInputStream(url);\n   Clip clip = AudioSystem.getClip();\n   clip.open(audioIn);\n   clip.start();\n} catch (UnsupportedAudioFileException e) {\n   e.printStackTrace();\n} catch (IOException e) {\n   e.printStackTrace();\n} catch (LineUnavailableException e) {\n   e.printStackTrace();\n}\n</code></pre><p>   }</p>\n<p>   public static void main(String[] args) {<br>      new playSoundDemo();<br>   }<br>}<br>导出PDF文件</p>\n<p>将表格导出成pdf也是一个比较常见的需求。通过itextpdf，导出pdf也不是什么难事。</p>\n<p>import java.io.FileOutputStream;<br>import com.itextpdf.text.Document;<br>import com.itextpdf.text.Paragraph;<br>import com.itextpdf.text.pdf.PdfPCell;<br>import com.itextpdf.text.pdf.PdfPTable;<br>import com.itextpdf.text.pdf.PdfWriter;</p>\n<p>public class DrawPdf {</p>\n<pre><code>  public static void main(String[] args) throws Exception {\n    Document document = new Document();\n    PdfWriter.getInstance(document, new FileOutputStream(&quot;Employee.pdf&quot;));\n    document.open();\n\n    Paragraph para = new Paragraph(&quot;Employee Table&quot;);\n    para.setSpacingAfter(20);\n    document.add(para);\n\n    PdfPTable table = new PdfPTable(3);\n    PdfPCell cell = new PdfPCell(new Paragraph(&quot;First Name&quot;));\n\n    table.addCell(cell);\n    table.addCell(&quot;Last Name&quot;);\n    table.addCell(&quot;Gender&quot;);\n    table.addCell(&quot;Ram&quot;);\n    table.addCell(&quot;Kumar&quot;);\n    table.addCell(&quot;Male&quot;);\n    table.addCell(&quot;Lakshmi&quot;);\n    table.addCell(&quot;Devi&quot;);\n    table.addCell(&quot;Female&quot;);\n\n    document.add(table);\n\n    document.close();\n  }\n}\n</code></pre><p>邮件发送</p>\n<p>在Java中发送邮件也很简单。你只需装一下Java Mail这个jar包，放到你的类路径里即可。在下面的代码中，我们设置了几个基础属性，然后便可以发送邮件了：</p>\n<p>import java.util.<em>;<br>import javax.mail.</em>;<br>import javax.mail.internet.*;</p>\n<p>public class SendEmail<br>{<br>    public static void main(String [] args)<br>    {<br>        String to = “recipient@gmail.com”;<br>        String from = “sender@gmail.com”;<br>        String host = “localhost”;</p>\n<pre><code>    Properties properties = System.getProperties();\n    properties.setProperty(&quot;mail.smtp.host&quot;, host);\n    Session session = Session.getDefaultInstance(properties);\n\n    try{\n        MimeMessage message = new MimeMessage(session);\n        message.setFrom(new InternetAddress(from));\n\n        message.addRecipient(Message.RecipientType.TO,new InternetAddress(to));\n\n        message.setSubject(&quot;My Email Subject&quot;);\n        message.setText(&quot;My Message Body&quot;);\n        Transport.send(message);\n        System.out.println(&quot;Sent successfully!&quot;);\n    }\n    catch (MessagingException ex) {\n        ex.printStackTrace();\n    }\n}\n</code></pre><p>}<br>计算时间</p>\n<p>许多程序都需要精确的时间计量。Java提供了一个System的静态方法来支持这一功能：</p>\n<p>currentTimeMillis()：返回当前时间自新纪元时间以来的毫秒值，long类型。</p>\n<p>long startTime = System.currentTimeMillis();<br>long estimatedTime = System.currentTimeMillis() - startTime;<br>nanoTime()：返回系统计时器当前的精确时间，纳秒值，这也是long类型。nanoTime()主要是用于计算相对时间而非绝对时间。</p>\n<p>long startTime = System.nanoTime();<br>long estimatedTime = System.nanoTime() - startTime;<br>图片缩放</p>\n<p>图片缩放可以通过AffineTransform来完成。首先要生成一个输入图片的图片缓冲，然后通过它来渲染出缩放后的图片。</p>\n<p>import java.awt.Graphics2D;<br>import java.awt.geom.AffineTransform;<br>import java.awt.image.BufferedImage;<br>import java.io.File;<br>import javax.imageio.ImageIO;</p>\n<p>public class RescaleImage {<br>  public static void main(String[] args) throws Exception {<br>    BufferedImage imgSource = ImageIO.read(new File(“images//Image3.jpg”));<br>    BufferedImage imgDestination = new BufferedImage(100, 100, BufferedImage.TYPE_INT_RGB);<br>    Graphics2D g = imgDestination.createGraphics();<br>    AffineTransform affinetransformation = AffineTransform.getScaleInstance(2, 2);<br>    g.drawRenderedImage(imgSource, affinetransformation);<br>    ImageIO.write(imgDestination, “JPG”, new File(“outImage.jpg”));<br>  }<br>}<br>捕获鼠标动作</p>\n<p>实现了MouseMotionListner接口后，便可以捕获鼠标事件了。 当鼠标进入到某个特定区域时便会触发MouseMoved事件，你便能捕获到这个移动的动作了。通过一个例子来看下：</p>\n<p>import java.awt.event.<em>;<br>import javax.swing.</em>;</p>\n<p>public class MouseCaptureDemo extends JFrame implements MouseMotionListener<br>{<br>    public JLabel mouseHoverStatus;</p>\n<pre><code>public static void main(String args[])\n{\n    new MouseCaptureDemo();\n}\n\nMouseCaptureDemo()\n{\n    setSize(500, 500);\n    setTitle(&quot;Frame displaying Coordinates of Mouse Motion&quot;);\n\n    mouseHoverStatus = new JLabel(&quot;No Mouse Hover Detected.&quot;, JLabel.CENTER);\n    add(mouseHoverStatus);\n    addMouseMotionListener(this);\n    setVisible(true);\n}\n\npublic void mouseMoved(MouseEvent e)\n{\n    mouseHoverStatus.setText(&quot;Mouse Cursor Coordinates =&gt; X:&quot;+e.getX()+&quot; | Y:&quot;+e.getY());\n}\n\npublic void mouseDragged(MouseEvent e)\n{}\n</code></pre><p>}<br>FileOutputStream Vs. FileWriter</p>\n<p>在Java中有两种写文件的方式：FileOutputStream与FileWriter。开发人员经常会在它们之间犹豫不决。下面这个例子能帮忙你更好地理解在不同的场景下应该选择何种方案。首先我们来看一下实现：</p>\n<p>使用FileOutputStream：</p>\n<p>File foutput = new File(file_location_string);<br>FileOutputStream fos = new FileOutputStream(foutput);<br>BufferedWriter output = new BufferedWriter(new OutputStreamWriter(fos));<br>output.write(“Buffered Content”);<br>使用FileWriter：</p>\n<p>FileWriter fstream = new FileWriter(file_location_string);<br>BufferedWriter output = new BufferedWriter(fstream);<br>output.write(“Buffered Content”);<br>根据Java的接口规范：</p>\n<p>FileOutputStream是用于写入原始字节流比如图片流数据。如果是要写入字符流，则应该考虑使用FileWriter。</p>\n<p>这样就很清楚了，写图片应该使用FileOutputStream而写文本则应该选择FileWriter。</p>\n<p>附加建议</p>\n<p>集合的使用</p>\n<p>Java提供了许多集合类——比如，Vector，Stack，Hashtable等。所以鼓励开发人员尽可能地使用这些集合类有如下原因：</p>\n<p>使用集合使得代码的可重用度更高。<br>集合类使得代码的结构更良好，更易于理解与维护。<br>最重要的是这些集合类都经过充分的测试，代码质量很高。<br>1-50-500规则</p>\n<p>在大型软件系统中，代码的可维护性是件很有挑战的工作。新加入的开发人员经常会抱怨这些情况：单片代码（Monolithic Code）,意大利面式代码（spaghetti code, 常用于描述捆绑在一起并且低内聚的类和方法）。保持代码的整洁与可维护有一条很简单的规则：</p>\n<p>10：包内的类不超过10个<br>50：方法的代码行数不超过50<br>500：类的代码行数不超过500<br>SOLID设计准则<br>SOLID是Robert Martin提出的一套设计准则的简称。根据他的准则：<br>一个类应当有仅只有一个任务/职责。执行多个任务的类会让人觉得困惑。</p>\n<p>单一职责原则<br>开闭原则    开发人员应当优先考虑扩展现有的软件功能，而不是是修改它。<br>里氏替换原则    子类必须能够替换掉他们的父类型<br>接口隔离原则    和单一职责原则类似，但它特指的是接口层。每个接口都应当只负责一项任务。<br>依赖反转原则    依赖抽象而不是具体实现。也就是说每个模块都应当通过一个抽象层与其它模块进行解耦。<br>设计模式的使用</p>\n<p>设计模式能帮助开发人员更好地在软件中应用软件的设计准则。它还为开发人员提供了跨语言的通用平台。设计模式中的标准术语能让开发人员更容易进行沟通。</p>\n<p>关于文档</p>\n<p>不要上来就开始写代码。制定计划，准备，编写文档，检查然后再去实现。首先，先把需求记下来。然后去准备设计文档。合理地去假设举证。互相review方案然后进行确认。</p>\n<p>使用equals而非==</p>\n<p>==是用来比较对象引用的，它会检查两个操作数指向的是不是同一个对象（不是相同的对象，而是同一个对象）。而”equals”则比较的是两个字符串是不是相同（假设是字符串对象）。</p>\n<p>避免使用浮点数</p>\n<p>只有当确实有必要的时候才使用浮点数。比方说，使用浮点数来表示卢比或者派萨就很容易产生问题——这种情况应当使用BigDecimal。而浮点数更多地是用于测量。</p>"},{"title":"Hello, jasonlife.top!","date":"2016-12-09T03:11:11.000Z","toc":true,"_content":"原来一直在CSDN搞自己的博客,后来了解到github可以搭建静态博客,可以自己定制主题,非常酷炫,索性就动起来。\n我的网站:http://jasonlife.top/\n<!--more-->\n#### 一、HEXO命令\n1. hexo new \"postName\" -> 新建文章\n2. hexo clean -> 清缓存数据\n3. hexo generate -> hexo g 生成静态页面\n4. hexo server -> hexo s 启动本地服务，进行文章预览调试\n5. hexo deploy -> hexo d 部署到github\n6. hexo help -> 查看帮助\n7. hexo version -> 查看版本\n\n#### 二、用到的工具或技术\n1. [github](https://github.com/)\n2. [git](https://git-scm.com/)\n3. [hexo](https://hexo.io/)\n4. [maupassant主题](https://github.com/tufu9441/maupassant-hexo.git)\n5. [markdown](http://wowubuntu.com/markdown/index.html)\n\n#### 三、搭建博客的参考文档:\n1. http://blog.csdn.net/u010053344/article/details/50545304\n2. http://www.tuicool.com/articles/ueI7naV\n3. https://www.haomwei.com/technology/maupassant-hexo.html\n4. https://hexo.io/\n5. http://www.jianshu.com/p/465830080ea9\n6. http://www.jianshu.com/p/1e402922ee32\n","source":"_posts/1Hello.md","raw":"---\ntitle: Hello, jasonlife.top!\ndate: 2016-12-09 11:11:11\ntags: Tech\ncategories: \"博客技术\"\ntoc: true\n---\n原来一直在CSDN搞自己的博客,后来了解到github可以搭建静态博客,可以自己定制主题,非常酷炫,索性就动起来。\n我的网站:http://jasonlife.top/\n<!--more-->\n#### 一、HEXO命令\n1. hexo new \"postName\" -> 新建文章\n2. hexo clean -> 清缓存数据\n3. hexo generate -> hexo g 生成静态页面\n4. hexo server -> hexo s 启动本地服务，进行文章预览调试\n5. hexo deploy -> hexo d 部署到github\n6. hexo help -> 查看帮助\n7. hexo version -> 查看版本\n\n#### 二、用到的工具或技术\n1. [github](https://github.com/)\n2. [git](https://git-scm.com/)\n3. [hexo](https://hexo.io/)\n4. [maupassant主题](https://github.com/tufu9441/maupassant-hexo.git)\n5. [markdown](http://wowubuntu.com/markdown/index.html)\n\n#### 三、搭建博客的参考文档:\n1. http://blog.csdn.net/u010053344/article/details/50545304\n2. http://www.tuicool.com/articles/ueI7naV\n3. https://www.haomwei.com/technology/maupassant-hexo.html\n4. https://hexo.io/\n5. http://www.jianshu.com/p/465830080ea9\n6. http://www.jianshu.com/p/1e402922ee32\n","slug":"1Hello","published":1,"updated":"2018-11-28T07:43:18.940Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tcaa0019a7xw2gh0w2w2","content":"<p>原来一直在CSDN搞自己的博客,后来了解到github可以搭建静态博客,可以自己定制主题,非常酷炫,索性就动起来。<br>我的网站:<a href=\"http://jasonlife.top/\">http://jasonlife.top/</a><br><a id=\"more\"></a></p>\n<h4 id=\"一、HEXO命令\"><a href=\"#一、HEXO命令\" class=\"headerlink\" title=\"一、HEXO命令\"></a>一、HEXO命令</h4><ol>\n<li>hexo new “postName” -&gt; 新建文章</li>\n<li>hexo clean -&gt; 清缓存数据</li>\n<li>hexo generate -&gt; hexo g 生成静态页面</li>\n<li>hexo server -&gt; hexo s 启动本地服务，进行文章预览调试</li>\n<li>hexo deploy -&gt; hexo d 部署到github</li>\n<li>hexo help -&gt; 查看帮助</li>\n<li>hexo version -&gt; 查看版本</li>\n</ol>\n<h4 id=\"二、用到的工具或技术\"><a href=\"#二、用到的工具或技术\" class=\"headerlink\" title=\"二、用到的工具或技术\"></a>二、用到的工具或技术</h4><ol>\n<li><a href=\"https://github.com/\" target=\"_blank\" rel=\"external\">github</a></li>\n<li><a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"external\">git</a></li>\n<li><a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">hexo</a></li>\n<li><a href=\"https://github.com/tufu9441/maupassant-hexo.git\" target=\"_blank\" rel=\"external\">maupassant主题</a></li>\n<li><a href=\"http://wowubuntu.com/markdown/index.html\" target=\"_blank\" rel=\"external\">markdown</a></li>\n</ol>\n<h4 id=\"三、搭建博客的参考文档\"><a href=\"#三、搭建博客的参考文档\" class=\"headerlink\" title=\"三、搭建博客的参考文档:\"></a>三、搭建博客的参考文档:</h4><ol>\n<li><a href=\"http://blog.csdn.net/u010053344/article/details/50545304\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/u010053344/article/details/50545304</a></li>\n<li><a href=\"http://www.tuicool.com/articles/ueI7naV\" target=\"_blank\" rel=\"external\">http://www.tuicool.com/articles/ueI7naV</a></li>\n<li><a href=\"https://www.haomwei.com/technology/maupassant-hexo.html\" target=\"_blank\" rel=\"external\">https://www.haomwei.com/technology/maupassant-hexo.html</a></li>\n<li><a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">https://hexo.io/</a></li>\n<li><a href=\"http://www.jianshu.com/p/465830080ea9\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/465830080ea9</a></li>\n<li><a href=\"http://www.jianshu.com/p/1e402922ee32\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/1e402922ee32</a></li>\n</ol>\n","excerpt":"<p>原来一直在CSDN搞自己的博客,后来了解到github可以搭建静态博客,可以自己定制主题,非常酷炫,索性就动起来。<br>我的网站:<a href=\"http://jasonlife.top/\">http://jasonlife.top/</a><br></p>","more":"<p></p>\n<h4 id=\"一、HEXO命令\"><a href=\"#一、HEXO命令\" class=\"headerlink\" title=\"一、HEXO命令\"></a>一、HEXO命令</h4><ol>\n<li>hexo new “postName” -&gt; 新建文章</li>\n<li>hexo clean -&gt; 清缓存数据</li>\n<li>hexo generate -&gt; hexo g 生成静态页面</li>\n<li>hexo server -&gt; hexo s 启动本地服务，进行文章预览调试</li>\n<li>hexo deploy -&gt; hexo d 部署到github</li>\n<li>hexo help -&gt; 查看帮助</li>\n<li>hexo version -&gt; 查看版本</li>\n</ol>\n<h4 id=\"二、用到的工具或技术\"><a href=\"#二、用到的工具或技术\" class=\"headerlink\" title=\"二、用到的工具或技术\"></a>二、用到的工具或技术</h4><ol>\n<li><a href=\"https://github.com/\">github</a></li>\n<li><a href=\"https://git-scm.com/\">git</a></li>\n<li><a href=\"https://hexo.io/\">hexo</a></li>\n<li><a href=\"https://github.com/tufu9441/maupassant-hexo.git\">maupassant主题</a></li>\n<li><a href=\"http://wowubuntu.com/markdown/index.html\">markdown</a></li>\n</ol>\n<h4 id=\"三、搭建博客的参考文档\"><a href=\"#三、搭建博客的参考文档\" class=\"headerlink\" title=\"三、搭建博客的参考文档:\"></a>三、搭建博客的参考文档:</h4><ol>\n<li><a href=\"http://blog.csdn.net/u010053344/article/details/50545304\">http://blog.csdn.net/u010053344/article/details/50545304</a></li>\n<li><a href=\"http://www.tuicool.com/articles/ueI7naV\">http://www.tuicool.com/articles/ueI7naV</a></li>\n<li><a href=\"https://www.haomwei.com/technology/maupassant-hexo.html\">https://www.haomwei.com/technology/maupassant-hexo.html</a></li>\n<li><a href=\"https://hexo.io/\">https://hexo.io/</a></li>\n<li><a href=\"http://www.jianshu.com/p/465830080ea9\">http://www.jianshu.com/p/465830080ea9</a></li>\n<li><a href=\"http://www.jianshu.com/p/1e402922ee32\">http://www.jianshu.com/p/1e402922ee32</a></li>\n</ol>"},{"title":"高并发服务设计——缓存","date":"2017-10-12T08:15:50.000Z","_content":"1. 缓存回收策略\n1.1 基于空间\n即设置缓存的存储空间，如设置为10MB，当达到存储空间时，按照一定的策略移除数据。\n1.2 基于容量\n基于容量指缓存设置了最大大小，当缓存的条目超过最大大小，则按照一定的策略将旧数据移除。\n<!--more-->\n1.3 基于时间\nTTL(Time To Live)：存活期，即缓存数据从缓存中创建时间开始直到它到期的一个时间段(不管在这个时间段内有没有访问都将过期)。\nTTI(Time To Idle)：空闲期，即缓存数据多久没被访问过将从缓存中移除的时间。\n1.4 基于Java对象引用\n软引用：如果一个对象是软引用，那么当JVM堆内存不足时，垃圾回收器可以回收这些对象。软引用适合用来做缓存，从而当JVM堆内存不足时，可以回收这些对象腾出一些空间供强引用对象使用，从而避免OOM。\n弱引用：当垃圾回收器回收内存时，如果发现弱引用，则将立即回收它。相对于软引用有更短的生命周期。\n注意：弱引用/软引用对象只有当没有其他强引用对象引用它时，垃圾回收时才回收该引用。 即如果有一个对象(不是弱引用/软引用)引用了弱引用/软引用对象，那么垃圾回收是不会回收该引用对象。\n1.5 回收算法\n使用基于空间和基于容量的缓存会使用一定的策略移除旧数据，常见的如下：\nFIFO(Fisrt In Fisrt Out)：先进先出算法，即先进入缓存的先被移除。\nLRU(Least Recently Used)：最近最少使用算法，使用时间距离现在最久的数据被移除。\nLFU(Least Frequently Used)：最不常用算法，一定时间段内使用次数（频率）最少的数据被移除。\n实际应用中基于LRU的缓存较多，如Guava Cache、EhCache支持LRU。\n2. Java缓存类型\n2.1 堆缓存\n使用Java堆内存来存储对象。可以使用Guava Cache、Ehcache 3.x、MapDB实现。\n优点：使用堆缓存的好处是没有序列化/反序列化，是最快的缓存；\n缺点：很明显，当缓存的数据量很大时， GC暂停时间会变长，存储容量受限于堆空间大小；一般通过软引用/弱引用来存储缓存对象，即当堆内存不足时，可以强制回收这部分内存释放堆内存空间。一般使用堆缓存存储较热的数据。\n2.2 堆外缓存\n即缓存数据存储在堆外内存。可以使用Ehcache 3.x、MapDB实现。\n优点：可以减少GC暂停时间(堆对象转移到堆外，GC扫描和移动的对象变少了)，可以支持更大的缓存空间(只受机器内存大小限制，不受堆空间的影响)。\n缺点：读取数据时需要序列化/反序列化，会比堆缓存慢很多。\n2.3 磁盘缓存\n即缓存数据的存储在磁盘上。当JVM重启时数据还是在的。而堆缓存/堆外缓存重启时数据会丢失，需要重新加载。可以使用Ehcache 3.x、MapDB实现。\n2.4 分布式缓存\n在多JVM实例的情况时，进程内缓存和磁盘缓存会存在两个问题：1.单机容量问题; 2.数据一致性问题（既然数据允许缓存，则表示允许一定时间内的不一致，因此可以设置缓存数据的过期时间来定期更新数据）; 3.缓存不命中时，需要回源到DB/服务查询变多：每个实例在缓存不命中情况下都会回源到DB加载数据，因此，多实例后DB整体的访问量就变多了。解决办法可以使用如一致性哈希分片算法来解决。因此，这些情况可以考虑使用分布式缓存来解决。可以使用ehcache-clustered(配合Terracotta server)实现Java进程间分布式缓存。当然也可以使用如Redis实现分布式缓存。\n两种模式如下：\n单机时：存储最热的数据到堆缓存，相对热的数据到堆外缓存，不热的数据存到磁盘缓存。\n集群时：存储最热的数据到堆缓存，相对热的数据到堆外缓存，全量数据存到分布式缓存。\n3. Java缓存实现\n3.1 堆缓存\n3.1.1 Guava Cache实现\nGuava Cache只提供堆缓存，小巧灵活，性能最好，如果只使用堆缓存，那么使用它就够了。\nCache<String, String> myCache=\n        CacheBuilder.newBuilder()\n        .concurrencyLevel(4)\n        .expireAfterWrite(10, TimeUnit.SECONDS)\n        .maximumSize(10000)\n        .build();\n然后可以通过put、getIfPresent 来读写缓存。CacheBuilder有几类参数：缓存回收策略、并发设置等。\n3.1.1.1 缓存回收策略/基于容量\nmaximumSize：设置缓存的容量，当超出maximumSize时，按照LRU进行缓存回收。\n3.1.1.2 缓存回收策略/基于时间\nexpireAfterWrite：设置TTL，缓存数据在给定的时间内没有写(创建/覆盖)时，则被回收，即定期的会回收缓存数据。\nexpireAfterAccess：设置TTI，缓存数据在给定的时间内没有读/写时，则被回收。每次访问时，都会更新它的TTI，从而如果该缓存是非常热的数据，则将一直不过期，可能会导致脏数据存在很长时间(因此，建议设置expireAfterWrite)。\n3.1.1.3 缓存回收策略/基于Java对象引用\nweakKeys/weakValues：设置弱引用缓存。\nsoftValues：设置软引用缓存。\n3.1.1.4 缓存回收策略/主动失效\ninvalidate(Object key)/invalidateAll(Iterablekeys)/invalidateAll()：主动失效某些缓存数据。\n什么时候触发失效呢? Guava Cache不会在缓存数据失效时立即触发回收操作(如果要这么做，则需要有额外的线程来进行清理)，是在PUT时会主动进行一次清理缓存，当然读者也可以根据实际业务通过自己设计线程来调用cleanUp方法进行清理。\n3.1.1.5 并发级别\nconcurrencyLevel：Guava Cache重写了ConcurrentHashMap，concurrencyLevel用来设置Segment数量，concurrencyLevel越大并发能力越强。\n3.1.1.6 统计命中率\nrecordStats：启动记录统计信息，比如命中率等\n3.1.2 EhCache 3.x实现\nCacheManager cacheManager = CacheManagerBuilder. newCacheManagerBuilder(). build(true);\nCacheConfigurationBuilder<String, String> cacheConfig= CacheConfigurationBuilder.newCacheConfigurationBuilder(\n       String.class,\n       String.class,\n       ResourcePoolsBuilder.newResourcePoolsBuilder()\n               .heap(100, EntryUnit.ENTRIES))\n       .withDispatcherConcurrency(4)\n       .withExpiry(Expirations.timeToLiveExpiration(Duration.of(10,TimeUnit.SECONDS)));\nCache<String, String> myCache = cacheManager.createCache(\"myCache\",cacheConfig);\nCacheManager在JVM关闭时请调用CacheManager.close()方法。 可以通过PUT、GET来读写缓存。CacheConfigurationBuilder也有几类参数：缓存回收策略、并发设置、统计命中率等。\n3.1.2.1 缓存回收策略/基于容量\nheap(100, EntryUnit.ENTRIES)：设置缓存的条目数量，当超出此数量时按照LRU进行缓存回收。\n3.1.2.2 缓存回收策略/基于空间\nheap(100, MemoryUnit.MB)：设置缓存的内存空间，当超出此空间时按照LRU进行缓存回收。另外，应该设置withSizeOfMaxObjectGraph(2)：统计对象大小时对象图遍历深度和withSizeOfMaxObjectSize(1, MemoryUnit.KB)：可缓存的最大对象大小。\n3.1.2.3 缓存回收策略/基于时间\nwithExpiry(Expirations.timeToLiveExpiration(Duration.of(10,TimeUnit.SECONDS)))：设置TTL，没有TTI。\nwithExpiry(Expirations.timeToIdleExpiration(Duration.of(10,TimeUnit.SECONDS)))：同时设置TTL和TTI，且TTL和TTI值一样。\n3.1.2.4 缓存回收策略/主动失效\nremove(K key)/ removeAll(Set keys)/clear()：主动失效某些缓存数据。\n什么时候触发失效呢?EhCache使用了类似于Guava Cache同样的机制。\n3.1.2.5 并发级别\n目前还没有提供API来设置，EhCache内部使用ConcurrentHashMap作为缓存存储，默认并发级别16。withDispatcherConcurrency是用来设置事件分发时的并发级别。\n3.1.3 MapDB 3.x 实现\nHTreeMap myCache =\n       DBMaker.heapDB().concurrencyScale(16).make().hashMap(\"myCache\")\n       .expireMaxSize(10000)\n       .expireAfterCreate(10, TimeUnit.SECONDS)\n       .expireAfterUpdate(10,TimeUnit.SECONDS)\n       .expireAfterGet(10, TimeUnit.SECONDS)\n       .create();\n然后可以通过PUT、GET来读写缓存。其有几类参数：缓存回收策略、并发设置、统计命中率等。\n3.1.3.1 缓存回收策略/基于容量\nexpireMaxSize：设置缓存的容量，当超出expireMaxSize时，按照LRU进行缓存回收。\n3.1.3.2 缓存回收策略/基于时间\nexpireAfterCreate/expireAfterUpdate：设置TTL，缓存数据在给定的时间内没有写(创建/覆盖)时，则被回收。即定期的会回收缓存数据。\nexpireAfterGet：设置TTI， 缓存数据在给定的时间内没有读/写时，则被回收。每次访问时都会更新它的TTI，从而如果该缓存是非常热的数据，则将一直不过期，可能会导致脏数据存在很长的时间(因此，建议要设置expireAfterCreate/expireAfterUpdate)。\n3.1.3.3 缓存回收策略/主动失效\nremove(Object key) /clear()：主动失效某些缓存数据。\n什么时候触发失效呢?\nMapDB默认使用类似于Guava Cache的机制。不过，也支持可以通过如下配置使用线程池定期进行缓存失效。\nexpireExecutor(scheduledExecutorService)\nexpireExecutorPeriod(3000)\n\n3.1.3.4 并发级别\n\nconcurrencyScale：类似于Guava Cache配置。\n\n还可以使用DBMaker.memoryDB()创建堆缓存，它将数据序列化并存储到1MB大小的byte[]数组中，从而减少垃圾回收的影响。\n\n3.2 堆外缓存\n\n3.2.1 EhCache 3.x实现\n\nCacheConfigurationBuilder<String, String> cacheConfig= CacheConfigurationBuilder.newCacheConfigurationBuilder(\n       String.class,\n       String.class,\n       ResourcePoolsBuilder.newResourcePoolsBuilder()\n               .offheap(100, MemoryUnit.MB))\n       .withDispatcherConcurrency(4)\n       .withExpiry(Expirations.timeToLiveExpiration(Duration.of(10,TimeUnit.SECONDS)))\n       .withSizeOfMaxObjectGraph(3)\n       .withSizeOfMaxObjectSize(1, MemoryUnit.KB);\n\n堆外缓存不支持基于容量的缓存过期策略。\n\n3.2.2 MapDB 3.x实现\n\nHTreeMap myCache =\n       DBMaker.memoryDirectDB().concurrencyScale(16).make().hashMap(\"myCache\")\n       .expireStoreSize(64 * 1024 * 1024) //指定堆外缓存大小64MB\n       .expireMaxSize(10000)\n       .expireAfterCreate(10, TimeUnit.SECONDS)\n       .expireAfterUpdate(10, TimeUnit.SECONDS)\n       .expireAfterGet(10, TimeUnit.SECONDS)\n       .create();\n\n在使用堆外缓存时，请记得添加JVM启动参数，如-XX:MaxDirectMemorySize=10G。\n\n3.3 磁盘缓存\n\n3.3.1 EhCache 3.x实现\n\nCacheManager cacheManager = CacheManagerBuilder. newCacheManagerBuilder()\n        //默认线程池\n        .using(PooledExecutionServiceConfigurationBuilder.newPooledExecutionServiceConfigurationBuilder().defaultPool(\"default\",1, 10).build())\n        //磁盘文件存储位置\n        .with(new CacheManagerPersistenceConfiguration(newFile(\"D:\\\\bak\")))\n        .build(true);\n\nCacheConfigurationBuilder<String, String> cacheConfig= CacheConfigurationBuilder. newCacheConfigurationBuilder(\n       String.class,\n       String.class,\n       ResourcePoolsBuilder.newResourcePoolsBuilder()\n       .disk(100, MemoryUnit.MB,true))       //磁盘缓存\n       .withDiskStoreThreadPool(\"default\", 5) //使用\"default\"线程池进行dump文件到磁盘\n       .withExpiry(Expirations.timeToLiveExpiration(Duration.of(50,TimeUnit.SECONDS)))\n       .withSizeOfMaxObjectGraph(3)\n       .withSizeOfMaxObjectSize(1, MemoryUnit.KB);\n\n在JVM停止时，记得调用cacheManager.close()，从而保证内存数据能dump到磁盘。\n3.3.2 MapDB 3.x实现\n\nDB db = DBMaker\n        .fileDB(\"D:\\\\bak\\\\a.data\")//数据存哪里\n        .fileMmapEnable() //启用mmap\n        .fileMmapEnableIfSupported() //在支持的平台上启用mmap\n        .fileMmapPreclearDisable() //让mmap文件更快\n        .cleanerHackEnable() //一些BUG处理\n        .transactionEnable() //启用事务\n        .closeOnJvmShutdown()\n        .concurrencyScale(16)\n        .make();\n\nHTreeMap myCache = db.hashMap(\"myCache\")\n       .expireMaxSize(10000)\n       .expireAfterCreate(10, TimeUnit.SECONDS)\n       .expireAfterUpdate(10, TimeUnit.SECONDS)\n       .expireAfterGet(10, TimeUnit.SECONDS)\n       .createOrOpen();\n\n因为开启了事务，MapDB则开启了WAL。另外，操作完缓存后记得调用db.commit方法提交事务。\n\nmyCache.put(\"key\" + counterWriter,\"value\" + counterWriter);\ndb.commit();\n\n3.4 分布式缓存\n\n3.4.1 Ehcache 3.1 + Terracotta Server\n\n不建议使用。\n\n3.4.2 Redis\n\n性能非常好，有主从模式、集群模式。\n\n3.5 多级缓存\n\n如先查找堆缓存，如果没有查找磁盘缓存，则使用MapDB可以通过如下配置实现。\n\nHTreeMap diskCache = db.hashMap(\"myCache\")\n       .expireStoreSize(8 * 1024 * 1024 * 1024)\n       .expireMaxSize(10000)\n       .expireAfterCreate(10, TimeUnit.SECONDS)\n       .expireAfterUpdate(10, TimeUnit.SECONDS)\n       .expireAfterGet(10, TimeUnit.SECONDS)\n       .createOrOpen();\n\nHTreeMap heapCache = db.hashMap(\"myCache\")\n       .expireMaxSize(100)\n       .expireAfterCreate(10, TimeUnit.SECONDS)\n       .expireAfterUpdate(10, TimeUnit.SECONDS)\n       .expireAfterGet(10, TimeUnit.SECONDS)\n       .expireOverflow(diskCache) //当缓存溢出时存储到disk\n       .createOrOpen();\n\n4. 缓存使用模式\n\n主要分两大类：Cache-Aside和Cache-As-SoR(Read-through、Write-through、Write-behind)\n\nSoR(system-of-record)：记录系统，或者可以叫做数据源，即实际存储原始数据的系统。\nCache：缓存，是SoR的快照数据，Cache的访问速度比SoR要快，放入Cache的目的是提升访问速度，减少回源到SoR的次数。\n回源：即回到数据源头获取数据，Cache没有命中时，需要从SoR读取数据，这叫做回源。\n\n4.1 Cache-Aside\n\nCache-Aside 即业务代码围绕着Cache写，是由业务代码直接维护缓存，示例代码如下所示。\n\n4.1.1 读场景\n\n先从缓存获取数据，如果没有命中，则回源到SoR并将源数据放入缓存供下次读取使用。\n\n//1、先从缓存中获取数据\nvalue = myCache.getIfPresent(key);\nif(value == null) {\n    //2.1、如果缓存没有命中，则回源到SoR获取源数据\n    value = loadFromSoR(key);\n    //2.2、将数据放入缓存，下次即可从缓存中获取数据\n    myCache.put(key, value);\n}\n\n4.1.2 写场景\n\n先将数据写入SoR，写入成功后立即将数据同步写入缓存。\n\n//1、先将数据写入SoR\nwriteToSoR(key,value);\n//2、执行成功后立即同步写入缓存\nmyCache.put(key, value);\n\n或者先将数据写入SoR，写入成功后将缓存数据过期，下次读取时再加载缓存。\n\n//1、先将数据写入SoR\nwriteToSoR(key,value);\n//2、失效缓存，然后下次读时再加载缓存\nmyCache.invalidate(key);\n\nCache-Aside适合使用AOP模式去实现\n\n4.2 Cache-As-SoR\n\nCache-As-SoR即把Cache看作为SoR，所有操作都是对Cache进行，然后Cache再委托给SoR进行真实的读/写。即业务代码中只看到Cache的操作，看不到关于SoR相关的代码。有三种实现：read-through、write-through、write-behind。\n\n4.2.1 Read-Through\n\nRead-Through，业务代码首先调用Cache，如果Cache不命中由Cache回源到SoR，而不是业务代码(即由Cache读SoR)。使用Read-Through模式，需要配置一个CacheLoader组件用来回源到SoR加载源数据。Guava Cache和Ehcache 3.x都支持该模式。\n\n4.2.1.1 Guava Cache实现\n\nLoadingCache<Integer,Result<Category>> getCache =\n       CacheBuilder.newBuilder()\n       .softValues()\n       .maximumSize(5000).expireAfterWrite(2, TimeUnit.MINUTES)\n        .build(new CacheLoader<Integer,Result<Category>>() {\n           @Override\n           public Result<Category> load(final Integer sortId) throwsException {\n                return categoryService.get(sortId);\n           }\n       });\n\n在build Cache时，传入一个CacheLoader用来加载缓存，操作流程如下：\n\n应用业务代码直接调用getCache.get(sortId)。\n首先查询Cache，如果缓存中有，则直接返回缓存数据。\n如果缓存没有命中，则委托给CacheLoader，CacheLoader会回源到SoR查询源数据(返回值必须不为null，可以包装为Null对象)，然后写入缓存。\n\n使用CacheLoader后有几个好处：\n\n应用业务代码更简洁了，不需要像Cache-Aside模式那样缓存查询代码和SoR代码交织在一起。如果缓存使用逻辑散落在多处，则使用这种方式很简单的消除了重复代码。\n解决Dog-pile effect，即当某个缓存失效时，又有大量相同的请求没命中缓存，从而同时请求到后端，导致后端压力太大，此时限制一个请求去拿即可。\n\n4.2.1.2 Ehcache 3.x实现\n\nCacheManager cacheManager = CacheManagerBuilder. newCacheManagerBuilder(). build(true);\norg.ehcache.Cache<String, String> myCache =cacheManager. createCache (\"myCache\",\n       CacheConfigurationBuilder.newCacheConfigurationBuilder(String.class,String.class,\n               ResourcePoolsBuilder.newResourcePoolsBuilder().heap(100,MemoryUnit.MB))\n               .withDispatcherConcurrency(4)\n               .withExpiry(Expirations.timeToLiveExpiration(Duration.of(10,TimeUnit.SECONDS)))\n                .withLoaderWriter(newDefaultCacheLoaderWriter<String, String> () {\n                   @Override\n                   public String load(String key) throws Exception {\n                        return readDB(key);\n                   }\n                    @Override\n                   public Map<String, String> loadAll(Iterable<? extendsString> keys) throws BulkCacheLoadingException, Exception {\n                        return null;\n                   }\n               }));\n\nEhcache 3.1没有自己去解决Dog-pile effect。\n\n4.2.2 Write-Through\n\nWrite-Through，称之为穿透写模式/直写模式，业务代码首先调用Cache写(新增/修改)数据，然后由Cache负责写缓存和写SoR，而不是业务代码。\n\n使用Write-Through模式需要配置一个CacheWriter组件用来回写SoR。Guava Cache没有提供支持。Ehcache 3.x支持该模式。\n\nEhcache需要配置一个CacheLoaderWriter，CacheLoaderWriter知道如何去写SoR。当Cache需要写(新增/修改)数据时，首先调用CacheLoaderWriter来同步(立即)到SoR，成功后会更新缓存。\n\nCacheManager cacheManager = CacheManagerBuilder.newCacheManagerBuilder().build(true);\nCache<String, String> myCache =cacheManager.createCache (\"myCache\",\n       CacheConfigurationBuilder.newCacheConfigurationBuilder(String.class,String.class,\n               ResourcePoolsBuilder.newResourcePoolsBuilder().heap(100,MemoryUnit.MB))\n               .withDispatcherConcurrency(4)\n               .withExpiry(Expirations.timeToLiveExpiration(Duration.of(10,TimeUnit.SECONDS)))\n               .withLoaderWriter(newDefaultCacheLoaderWriter<String, String> () {\n                   @Override\n                   public void write(String key, String value) throws Exception{\n                        //write\n                   }\n                   @Override\n                   public void writeAll(Iterable<? extends Map.Entry<? extendsString, ? extends String>> entries) throws BulkCacheWritingException,Exception {\n                        for(Object entry: entries) {\n                            //batch write\n                        }\n                   }\n                   @Override\n                    public void delete(Stringkey) throws Exception {\n                        //delete\n                   }\n                   @Override\n                   public void deleteAll(Iterable<? extends String>keys) throws BulkCacheWritingException, Exception {\n                        for(Object key :keys) {\n                            //batch delete\n                        }\n                   }\n               }).build());\n\nEhcache 3.x还是使用CacheLoaderWriter来实现，通过write(String key, String value)、writeAll(Iterable> entries)和delete(String key)、deleteAll(Iterable keys)分别来支持单个写、批量写和单个删除、批量删除操作。\n\n操作流程如下：当我们调用myCache.put(“e”,”123”)或者myCache.putAll(map)时，写缓存。首先，Cache会将写操作立即委托给CacheLoaderWriter#write和#writeAll，然后由CacheLoaderWriter负责立即去写SoR。当写SoR成功后，再写入Cache。\n\n4.2.3 Write-Behind\n\nWrite-Behind，也叫Write-Back，称之为回写模式，不同于Write-Through是同步写SoR和Cache，Write-Behind是异步写。异步之后可以实现批量写、合并写、延时和限流。\n\n4.2.3.1 异步写\n\n略，可用EhCache实现\n\n4.2.3.2 批量写\n\n略，可用EhCache实现\n\n4.2.4 Copy Pattern\n\n有两种Copy Pattern， Copy-On-Read和Copy-On-Write。在Guava-Cache和EhCache中堆缓存都是基于引用的，这样如果哟人拿到缓存数据并修改了它，则可能发生不可预测的问题。Guava Cache没有提供支持，EhCache 3.x提供了支持。\n\npublic interface Copier<T> {\n    T copyForRead(T obj);    //Copy-On-Read，比如myCache.get()\n    T copyForWrite(T obj);   //Copy-On-Write，比如myCache.put()\n}\n参考来源：  [1] 亿级流量网站架构核心技术.张开涛著\n出处：http://blog.csdn.net/foreverling/article/details/78012205\n版权申明：内容来源网络，版权归原创者所有。除非无法确认，我们都会标明作者及出处，如有侵权烦请告知，我们会立即删除并表示歉意。谢谢。\n","source":"_posts/25高并发服务设计——缓存.md","raw":"---\ntitle: 高并发服务设计——缓存\ndate: 2017-10-12 16:15:50\ntags: 缓存 架构\ncategories: \"缓存\"\n---\n1. 缓存回收策略\n1.1 基于空间\n即设置缓存的存储空间，如设置为10MB，当达到存储空间时，按照一定的策略移除数据。\n1.2 基于容量\n基于容量指缓存设置了最大大小，当缓存的条目超过最大大小，则按照一定的策略将旧数据移除。\n<!--more-->\n1.3 基于时间\nTTL(Time To Live)：存活期，即缓存数据从缓存中创建时间开始直到它到期的一个时间段(不管在这个时间段内有没有访问都将过期)。\nTTI(Time To Idle)：空闲期，即缓存数据多久没被访问过将从缓存中移除的时间。\n1.4 基于Java对象引用\n软引用：如果一个对象是软引用，那么当JVM堆内存不足时，垃圾回收器可以回收这些对象。软引用适合用来做缓存，从而当JVM堆内存不足时，可以回收这些对象腾出一些空间供强引用对象使用，从而避免OOM。\n弱引用：当垃圾回收器回收内存时，如果发现弱引用，则将立即回收它。相对于软引用有更短的生命周期。\n注意：弱引用/软引用对象只有当没有其他强引用对象引用它时，垃圾回收时才回收该引用。 即如果有一个对象(不是弱引用/软引用)引用了弱引用/软引用对象，那么垃圾回收是不会回收该引用对象。\n1.5 回收算法\n使用基于空间和基于容量的缓存会使用一定的策略移除旧数据，常见的如下：\nFIFO(Fisrt In Fisrt Out)：先进先出算法，即先进入缓存的先被移除。\nLRU(Least Recently Used)：最近最少使用算法，使用时间距离现在最久的数据被移除。\nLFU(Least Frequently Used)：最不常用算法，一定时间段内使用次数（频率）最少的数据被移除。\n实际应用中基于LRU的缓存较多，如Guava Cache、EhCache支持LRU。\n2. Java缓存类型\n2.1 堆缓存\n使用Java堆内存来存储对象。可以使用Guava Cache、Ehcache 3.x、MapDB实现。\n优点：使用堆缓存的好处是没有序列化/反序列化，是最快的缓存；\n缺点：很明显，当缓存的数据量很大时， GC暂停时间会变长，存储容量受限于堆空间大小；一般通过软引用/弱引用来存储缓存对象，即当堆内存不足时，可以强制回收这部分内存释放堆内存空间。一般使用堆缓存存储较热的数据。\n2.2 堆外缓存\n即缓存数据存储在堆外内存。可以使用Ehcache 3.x、MapDB实现。\n优点：可以减少GC暂停时间(堆对象转移到堆外，GC扫描和移动的对象变少了)，可以支持更大的缓存空间(只受机器内存大小限制，不受堆空间的影响)。\n缺点：读取数据时需要序列化/反序列化，会比堆缓存慢很多。\n2.3 磁盘缓存\n即缓存数据的存储在磁盘上。当JVM重启时数据还是在的。而堆缓存/堆外缓存重启时数据会丢失，需要重新加载。可以使用Ehcache 3.x、MapDB实现。\n2.4 分布式缓存\n在多JVM实例的情况时，进程内缓存和磁盘缓存会存在两个问题：1.单机容量问题; 2.数据一致性问题（既然数据允许缓存，则表示允许一定时间内的不一致，因此可以设置缓存数据的过期时间来定期更新数据）; 3.缓存不命中时，需要回源到DB/服务查询变多：每个实例在缓存不命中情况下都会回源到DB加载数据，因此，多实例后DB整体的访问量就变多了。解决办法可以使用如一致性哈希分片算法来解决。因此，这些情况可以考虑使用分布式缓存来解决。可以使用ehcache-clustered(配合Terracotta server)实现Java进程间分布式缓存。当然也可以使用如Redis实现分布式缓存。\n两种模式如下：\n单机时：存储最热的数据到堆缓存，相对热的数据到堆外缓存，不热的数据存到磁盘缓存。\n集群时：存储最热的数据到堆缓存，相对热的数据到堆外缓存，全量数据存到分布式缓存。\n3. Java缓存实现\n3.1 堆缓存\n3.1.1 Guava Cache实现\nGuava Cache只提供堆缓存，小巧灵活，性能最好，如果只使用堆缓存，那么使用它就够了。\nCache<String, String> myCache=\n        CacheBuilder.newBuilder()\n        .concurrencyLevel(4)\n        .expireAfterWrite(10, TimeUnit.SECONDS)\n        .maximumSize(10000)\n        .build();\n然后可以通过put、getIfPresent 来读写缓存。CacheBuilder有几类参数：缓存回收策略、并发设置等。\n3.1.1.1 缓存回收策略/基于容量\nmaximumSize：设置缓存的容量，当超出maximumSize时，按照LRU进行缓存回收。\n3.1.1.2 缓存回收策略/基于时间\nexpireAfterWrite：设置TTL，缓存数据在给定的时间内没有写(创建/覆盖)时，则被回收，即定期的会回收缓存数据。\nexpireAfterAccess：设置TTI，缓存数据在给定的时间内没有读/写时，则被回收。每次访问时，都会更新它的TTI，从而如果该缓存是非常热的数据，则将一直不过期，可能会导致脏数据存在很长时间(因此，建议设置expireAfterWrite)。\n3.1.1.3 缓存回收策略/基于Java对象引用\nweakKeys/weakValues：设置弱引用缓存。\nsoftValues：设置软引用缓存。\n3.1.1.4 缓存回收策略/主动失效\ninvalidate(Object key)/invalidateAll(Iterablekeys)/invalidateAll()：主动失效某些缓存数据。\n什么时候触发失效呢? Guava Cache不会在缓存数据失效时立即触发回收操作(如果要这么做，则需要有额外的线程来进行清理)，是在PUT时会主动进行一次清理缓存，当然读者也可以根据实际业务通过自己设计线程来调用cleanUp方法进行清理。\n3.1.1.5 并发级别\nconcurrencyLevel：Guava Cache重写了ConcurrentHashMap，concurrencyLevel用来设置Segment数量，concurrencyLevel越大并发能力越强。\n3.1.1.6 统计命中率\nrecordStats：启动记录统计信息，比如命中率等\n3.1.2 EhCache 3.x实现\nCacheManager cacheManager = CacheManagerBuilder. newCacheManagerBuilder(). build(true);\nCacheConfigurationBuilder<String, String> cacheConfig= CacheConfigurationBuilder.newCacheConfigurationBuilder(\n       String.class,\n       String.class,\n       ResourcePoolsBuilder.newResourcePoolsBuilder()\n               .heap(100, EntryUnit.ENTRIES))\n       .withDispatcherConcurrency(4)\n       .withExpiry(Expirations.timeToLiveExpiration(Duration.of(10,TimeUnit.SECONDS)));\nCache<String, String> myCache = cacheManager.createCache(\"myCache\",cacheConfig);\nCacheManager在JVM关闭时请调用CacheManager.close()方法。 可以通过PUT、GET来读写缓存。CacheConfigurationBuilder也有几类参数：缓存回收策略、并发设置、统计命中率等。\n3.1.2.1 缓存回收策略/基于容量\nheap(100, EntryUnit.ENTRIES)：设置缓存的条目数量，当超出此数量时按照LRU进行缓存回收。\n3.1.2.2 缓存回收策略/基于空间\nheap(100, MemoryUnit.MB)：设置缓存的内存空间，当超出此空间时按照LRU进行缓存回收。另外，应该设置withSizeOfMaxObjectGraph(2)：统计对象大小时对象图遍历深度和withSizeOfMaxObjectSize(1, MemoryUnit.KB)：可缓存的最大对象大小。\n3.1.2.3 缓存回收策略/基于时间\nwithExpiry(Expirations.timeToLiveExpiration(Duration.of(10,TimeUnit.SECONDS)))：设置TTL，没有TTI。\nwithExpiry(Expirations.timeToIdleExpiration(Duration.of(10,TimeUnit.SECONDS)))：同时设置TTL和TTI，且TTL和TTI值一样。\n3.1.2.4 缓存回收策略/主动失效\nremove(K key)/ removeAll(Set keys)/clear()：主动失效某些缓存数据。\n什么时候触发失效呢?EhCache使用了类似于Guava Cache同样的机制。\n3.1.2.5 并发级别\n目前还没有提供API来设置，EhCache内部使用ConcurrentHashMap作为缓存存储，默认并发级别16。withDispatcherConcurrency是用来设置事件分发时的并发级别。\n3.1.3 MapDB 3.x 实现\nHTreeMap myCache =\n       DBMaker.heapDB().concurrencyScale(16).make().hashMap(\"myCache\")\n       .expireMaxSize(10000)\n       .expireAfterCreate(10, TimeUnit.SECONDS)\n       .expireAfterUpdate(10,TimeUnit.SECONDS)\n       .expireAfterGet(10, TimeUnit.SECONDS)\n       .create();\n然后可以通过PUT、GET来读写缓存。其有几类参数：缓存回收策略、并发设置、统计命中率等。\n3.1.3.1 缓存回收策略/基于容量\nexpireMaxSize：设置缓存的容量，当超出expireMaxSize时，按照LRU进行缓存回收。\n3.1.3.2 缓存回收策略/基于时间\nexpireAfterCreate/expireAfterUpdate：设置TTL，缓存数据在给定的时间内没有写(创建/覆盖)时，则被回收。即定期的会回收缓存数据。\nexpireAfterGet：设置TTI， 缓存数据在给定的时间内没有读/写时，则被回收。每次访问时都会更新它的TTI，从而如果该缓存是非常热的数据，则将一直不过期，可能会导致脏数据存在很长的时间(因此，建议要设置expireAfterCreate/expireAfterUpdate)。\n3.1.3.3 缓存回收策略/主动失效\nremove(Object key) /clear()：主动失效某些缓存数据。\n什么时候触发失效呢?\nMapDB默认使用类似于Guava Cache的机制。不过，也支持可以通过如下配置使用线程池定期进行缓存失效。\nexpireExecutor(scheduledExecutorService)\nexpireExecutorPeriod(3000)\n\n3.1.3.4 并发级别\n\nconcurrencyScale：类似于Guava Cache配置。\n\n还可以使用DBMaker.memoryDB()创建堆缓存，它将数据序列化并存储到1MB大小的byte[]数组中，从而减少垃圾回收的影响。\n\n3.2 堆外缓存\n\n3.2.1 EhCache 3.x实现\n\nCacheConfigurationBuilder<String, String> cacheConfig= CacheConfigurationBuilder.newCacheConfigurationBuilder(\n       String.class,\n       String.class,\n       ResourcePoolsBuilder.newResourcePoolsBuilder()\n               .offheap(100, MemoryUnit.MB))\n       .withDispatcherConcurrency(4)\n       .withExpiry(Expirations.timeToLiveExpiration(Duration.of(10,TimeUnit.SECONDS)))\n       .withSizeOfMaxObjectGraph(3)\n       .withSizeOfMaxObjectSize(1, MemoryUnit.KB);\n\n堆外缓存不支持基于容量的缓存过期策略。\n\n3.2.2 MapDB 3.x实现\n\nHTreeMap myCache =\n       DBMaker.memoryDirectDB().concurrencyScale(16).make().hashMap(\"myCache\")\n       .expireStoreSize(64 * 1024 * 1024) //指定堆外缓存大小64MB\n       .expireMaxSize(10000)\n       .expireAfterCreate(10, TimeUnit.SECONDS)\n       .expireAfterUpdate(10, TimeUnit.SECONDS)\n       .expireAfterGet(10, TimeUnit.SECONDS)\n       .create();\n\n在使用堆外缓存时，请记得添加JVM启动参数，如-XX:MaxDirectMemorySize=10G。\n\n3.3 磁盘缓存\n\n3.3.1 EhCache 3.x实现\n\nCacheManager cacheManager = CacheManagerBuilder. newCacheManagerBuilder()\n        //默认线程池\n        .using(PooledExecutionServiceConfigurationBuilder.newPooledExecutionServiceConfigurationBuilder().defaultPool(\"default\",1, 10).build())\n        //磁盘文件存储位置\n        .with(new CacheManagerPersistenceConfiguration(newFile(\"D:\\\\bak\")))\n        .build(true);\n\nCacheConfigurationBuilder<String, String> cacheConfig= CacheConfigurationBuilder. newCacheConfigurationBuilder(\n       String.class,\n       String.class,\n       ResourcePoolsBuilder.newResourcePoolsBuilder()\n       .disk(100, MemoryUnit.MB,true))       //磁盘缓存\n       .withDiskStoreThreadPool(\"default\", 5) //使用\"default\"线程池进行dump文件到磁盘\n       .withExpiry(Expirations.timeToLiveExpiration(Duration.of(50,TimeUnit.SECONDS)))\n       .withSizeOfMaxObjectGraph(3)\n       .withSizeOfMaxObjectSize(1, MemoryUnit.KB);\n\n在JVM停止时，记得调用cacheManager.close()，从而保证内存数据能dump到磁盘。\n3.3.2 MapDB 3.x实现\n\nDB db = DBMaker\n        .fileDB(\"D:\\\\bak\\\\a.data\")//数据存哪里\n        .fileMmapEnable() //启用mmap\n        .fileMmapEnableIfSupported() //在支持的平台上启用mmap\n        .fileMmapPreclearDisable() //让mmap文件更快\n        .cleanerHackEnable() //一些BUG处理\n        .transactionEnable() //启用事务\n        .closeOnJvmShutdown()\n        .concurrencyScale(16)\n        .make();\n\nHTreeMap myCache = db.hashMap(\"myCache\")\n       .expireMaxSize(10000)\n       .expireAfterCreate(10, TimeUnit.SECONDS)\n       .expireAfterUpdate(10, TimeUnit.SECONDS)\n       .expireAfterGet(10, TimeUnit.SECONDS)\n       .createOrOpen();\n\n因为开启了事务，MapDB则开启了WAL。另外，操作完缓存后记得调用db.commit方法提交事务。\n\nmyCache.put(\"key\" + counterWriter,\"value\" + counterWriter);\ndb.commit();\n\n3.4 分布式缓存\n\n3.4.1 Ehcache 3.1 + Terracotta Server\n\n不建议使用。\n\n3.4.2 Redis\n\n性能非常好，有主从模式、集群模式。\n\n3.5 多级缓存\n\n如先查找堆缓存，如果没有查找磁盘缓存，则使用MapDB可以通过如下配置实现。\n\nHTreeMap diskCache = db.hashMap(\"myCache\")\n       .expireStoreSize(8 * 1024 * 1024 * 1024)\n       .expireMaxSize(10000)\n       .expireAfterCreate(10, TimeUnit.SECONDS)\n       .expireAfterUpdate(10, TimeUnit.SECONDS)\n       .expireAfterGet(10, TimeUnit.SECONDS)\n       .createOrOpen();\n\nHTreeMap heapCache = db.hashMap(\"myCache\")\n       .expireMaxSize(100)\n       .expireAfterCreate(10, TimeUnit.SECONDS)\n       .expireAfterUpdate(10, TimeUnit.SECONDS)\n       .expireAfterGet(10, TimeUnit.SECONDS)\n       .expireOverflow(diskCache) //当缓存溢出时存储到disk\n       .createOrOpen();\n\n4. 缓存使用模式\n\n主要分两大类：Cache-Aside和Cache-As-SoR(Read-through、Write-through、Write-behind)\n\nSoR(system-of-record)：记录系统，或者可以叫做数据源，即实际存储原始数据的系统。\nCache：缓存，是SoR的快照数据，Cache的访问速度比SoR要快，放入Cache的目的是提升访问速度，减少回源到SoR的次数。\n回源：即回到数据源头获取数据，Cache没有命中时，需要从SoR读取数据，这叫做回源。\n\n4.1 Cache-Aside\n\nCache-Aside 即业务代码围绕着Cache写，是由业务代码直接维护缓存，示例代码如下所示。\n\n4.1.1 读场景\n\n先从缓存获取数据，如果没有命中，则回源到SoR并将源数据放入缓存供下次读取使用。\n\n//1、先从缓存中获取数据\nvalue = myCache.getIfPresent(key);\nif(value == null) {\n    //2.1、如果缓存没有命中，则回源到SoR获取源数据\n    value = loadFromSoR(key);\n    //2.2、将数据放入缓存，下次即可从缓存中获取数据\n    myCache.put(key, value);\n}\n\n4.1.2 写场景\n\n先将数据写入SoR，写入成功后立即将数据同步写入缓存。\n\n//1、先将数据写入SoR\nwriteToSoR(key,value);\n//2、执行成功后立即同步写入缓存\nmyCache.put(key, value);\n\n或者先将数据写入SoR，写入成功后将缓存数据过期，下次读取时再加载缓存。\n\n//1、先将数据写入SoR\nwriteToSoR(key,value);\n//2、失效缓存，然后下次读时再加载缓存\nmyCache.invalidate(key);\n\nCache-Aside适合使用AOP模式去实现\n\n4.2 Cache-As-SoR\n\nCache-As-SoR即把Cache看作为SoR，所有操作都是对Cache进行，然后Cache再委托给SoR进行真实的读/写。即业务代码中只看到Cache的操作，看不到关于SoR相关的代码。有三种实现：read-through、write-through、write-behind。\n\n4.2.1 Read-Through\n\nRead-Through，业务代码首先调用Cache，如果Cache不命中由Cache回源到SoR，而不是业务代码(即由Cache读SoR)。使用Read-Through模式，需要配置一个CacheLoader组件用来回源到SoR加载源数据。Guava Cache和Ehcache 3.x都支持该模式。\n\n4.2.1.1 Guava Cache实现\n\nLoadingCache<Integer,Result<Category>> getCache =\n       CacheBuilder.newBuilder()\n       .softValues()\n       .maximumSize(5000).expireAfterWrite(2, TimeUnit.MINUTES)\n        .build(new CacheLoader<Integer,Result<Category>>() {\n           @Override\n           public Result<Category> load(final Integer sortId) throwsException {\n                return categoryService.get(sortId);\n           }\n       });\n\n在build Cache时，传入一个CacheLoader用来加载缓存，操作流程如下：\n\n应用业务代码直接调用getCache.get(sortId)。\n首先查询Cache，如果缓存中有，则直接返回缓存数据。\n如果缓存没有命中，则委托给CacheLoader，CacheLoader会回源到SoR查询源数据(返回值必须不为null，可以包装为Null对象)，然后写入缓存。\n\n使用CacheLoader后有几个好处：\n\n应用业务代码更简洁了，不需要像Cache-Aside模式那样缓存查询代码和SoR代码交织在一起。如果缓存使用逻辑散落在多处，则使用这种方式很简单的消除了重复代码。\n解决Dog-pile effect，即当某个缓存失效时，又有大量相同的请求没命中缓存，从而同时请求到后端，导致后端压力太大，此时限制一个请求去拿即可。\n\n4.2.1.2 Ehcache 3.x实现\n\nCacheManager cacheManager = CacheManagerBuilder. newCacheManagerBuilder(). build(true);\norg.ehcache.Cache<String, String> myCache =cacheManager. createCache (\"myCache\",\n       CacheConfigurationBuilder.newCacheConfigurationBuilder(String.class,String.class,\n               ResourcePoolsBuilder.newResourcePoolsBuilder().heap(100,MemoryUnit.MB))\n               .withDispatcherConcurrency(4)\n               .withExpiry(Expirations.timeToLiveExpiration(Duration.of(10,TimeUnit.SECONDS)))\n                .withLoaderWriter(newDefaultCacheLoaderWriter<String, String> () {\n                   @Override\n                   public String load(String key) throws Exception {\n                        return readDB(key);\n                   }\n                    @Override\n                   public Map<String, String> loadAll(Iterable<? extendsString> keys) throws BulkCacheLoadingException, Exception {\n                        return null;\n                   }\n               }));\n\nEhcache 3.1没有自己去解决Dog-pile effect。\n\n4.2.2 Write-Through\n\nWrite-Through，称之为穿透写模式/直写模式，业务代码首先调用Cache写(新增/修改)数据，然后由Cache负责写缓存和写SoR，而不是业务代码。\n\n使用Write-Through模式需要配置一个CacheWriter组件用来回写SoR。Guava Cache没有提供支持。Ehcache 3.x支持该模式。\n\nEhcache需要配置一个CacheLoaderWriter，CacheLoaderWriter知道如何去写SoR。当Cache需要写(新增/修改)数据时，首先调用CacheLoaderWriter来同步(立即)到SoR，成功后会更新缓存。\n\nCacheManager cacheManager = CacheManagerBuilder.newCacheManagerBuilder().build(true);\nCache<String, String> myCache =cacheManager.createCache (\"myCache\",\n       CacheConfigurationBuilder.newCacheConfigurationBuilder(String.class,String.class,\n               ResourcePoolsBuilder.newResourcePoolsBuilder().heap(100,MemoryUnit.MB))\n               .withDispatcherConcurrency(4)\n               .withExpiry(Expirations.timeToLiveExpiration(Duration.of(10,TimeUnit.SECONDS)))\n               .withLoaderWriter(newDefaultCacheLoaderWriter<String, String> () {\n                   @Override\n                   public void write(String key, String value) throws Exception{\n                        //write\n                   }\n                   @Override\n                   public void writeAll(Iterable<? extends Map.Entry<? extendsString, ? extends String>> entries) throws BulkCacheWritingException,Exception {\n                        for(Object entry: entries) {\n                            //batch write\n                        }\n                   }\n                   @Override\n                    public void delete(Stringkey) throws Exception {\n                        //delete\n                   }\n                   @Override\n                   public void deleteAll(Iterable<? extends String>keys) throws BulkCacheWritingException, Exception {\n                        for(Object key :keys) {\n                            //batch delete\n                        }\n                   }\n               }).build());\n\nEhcache 3.x还是使用CacheLoaderWriter来实现，通过write(String key, String value)、writeAll(Iterable> entries)和delete(String key)、deleteAll(Iterable keys)分别来支持单个写、批量写和单个删除、批量删除操作。\n\n操作流程如下：当我们调用myCache.put(“e”,”123”)或者myCache.putAll(map)时，写缓存。首先，Cache会将写操作立即委托给CacheLoaderWriter#write和#writeAll，然后由CacheLoaderWriter负责立即去写SoR。当写SoR成功后，再写入Cache。\n\n4.2.3 Write-Behind\n\nWrite-Behind，也叫Write-Back，称之为回写模式，不同于Write-Through是同步写SoR和Cache，Write-Behind是异步写。异步之后可以实现批量写、合并写、延时和限流。\n\n4.2.3.1 异步写\n\n略，可用EhCache实现\n\n4.2.3.2 批量写\n\n略，可用EhCache实现\n\n4.2.4 Copy Pattern\n\n有两种Copy Pattern， Copy-On-Read和Copy-On-Write。在Guava-Cache和EhCache中堆缓存都是基于引用的，这样如果哟人拿到缓存数据并修改了它，则可能发生不可预测的问题。Guava Cache没有提供支持，EhCache 3.x提供了支持。\n\npublic interface Copier<T> {\n    T copyForRead(T obj);    //Copy-On-Read，比如myCache.get()\n    T copyForWrite(T obj);   //Copy-On-Write，比如myCache.put()\n}\n参考来源：  [1] 亿级流量网站架构核心技术.张开涛著\n出处：http://blog.csdn.net/foreverling/article/details/78012205\n版权申明：内容来源网络，版权归原创者所有。除非无法确认，我们都会标明作者及出处，如有侵权烦请告知，我们会立即删除并表示歉意。谢谢。\n","slug":"25高并发服务设计——缓存","published":1,"updated":"2018-01-16T03:35:05.957Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tcac001ca7xw2c2xa729","content":"<ol>\n<li>缓存回收策略<br>1.1 基于空间<br>即设置缓存的存储空间，如设置为10MB，当达到存储空间时，按照一定的策略移除数据。<br>1.2 基于容量<br>基于容量指缓存设置了最大大小，当缓存的条目超过最大大小，则按照一定的策略将旧数据移除。<a id=\"more\"></a>\n1.3 基于时间<br>TTL(Time To Live)：存活期，即缓存数据从缓存中创建时间开始直到它到期的一个时间段(不管在这个时间段内有没有访问都将过期)。<br>TTI(Time To Idle)：空闲期，即缓存数据多久没被访问过将从缓存中移除的时间。<br>1.4 基于Java对象引用<br>软引用：如果一个对象是软引用，那么当JVM堆内存不足时，垃圾回收器可以回收这些对象。软引用适合用来做缓存，从而当JVM堆内存不足时，可以回收这些对象腾出一些空间供强引用对象使用，从而避免OOM。<br>弱引用：当垃圾回收器回收内存时，如果发现弱引用，则将立即回收它。相对于软引用有更短的生命周期。<br>注意：弱引用/软引用对象只有当没有其他强引用对象引用它时，垃圾回收时才回收该引用。 即如果有一个对象(不是弱引用/软引用)引用了弱引用/软引用对象，那么垃圾回收是不会回收该引用对象。<br>1.5 回收算法<br>使用基于空间和基于容量的缓存会使用一定的策略移除旧数据，常见的如下：<br>FIFO(Fisrt In Fisrt Out)：先进先出算法，即先进入缓存的先被移除。<br>LRU(Least Recently Used)：最近最少使用算法，使用时间距离现在最久的数据被移除。<br>LFU(Least Frequently Used)：最不常用算法，一定时间段内使用次数（频率）最少的数据被移除。<br>实际应用中基于LRU的缓存较多，如Guava Cache、EhCache支持LRU。</li>\n<li>Java缓存类型<br>2.1 堆缓存<br>使用Java堆内存来存储对象。可以使用Guava Cache、Ehcache 3.x、MapDB实现。<br>优点：使用堆缓存的好处是没有序列化/反序列化，是最快的缓存；<br>缺点：很明显，当缓存的数据量很大时， GC暂停时间会变长，存储容量受限于堆空间大小；一般通过软引用/弱引用来存储缓存对象，即当堆内存不足时，可以强制回收这部分内存释放堆内存空间。一般使用堆缓存存储较热的数据。<br>2.2 堆外缓存<br>即缓存数据存储在堆外内存。可以使用Ehcache 3.x、MapDB实现。<br>优点：可以减少GC暂停时间(堆对象转移到堆外，GC扫描和移动的对象变少了)，可以支持更大的缓存空间(只受机器内存大小限制，不受堆空间的影响)。<br>缺点：读取数据时需要序列化/反序列化，会比堆缓存慢很多。<br>2.3 磁盘缓存<br>即缓存数据的存储在磁盘上。当JVM重启时数据还是在的。而堆缓存/堆外缓存重启时数据会丢失，需要重新加载。可以使用Ehcache 3.x、MapDB实现。<br>2.4 分布式缓存<br>在多JVM实例的情况时，进程内缓存和磁盘缓存会存在两个问题：1.单机容量问题; 2.数据一致性问题（既然数据允许缓存，则表示允许一定时间内的不一致，因此可以设置缓存数据的过期时间来定期更新数据）; 3.缓存不命中时，需要回源到DB/服务查询变多：每个实例在缓存不命中情况下都会回源到DB加载数据，因此，多实例后DB整体的访问量就变多了。解决办法可以使用如一致性哈希分片算法来解决。因此，这些情况可以考虑使用分布式缓存来解决。可以使用ehcache-clustered(配合Terracotta server)实现Java进程间分布式缓存。当然也可以使用如Redis实现分布式缓存。<br>两种模式如下：<br>单机时：存储最热的数据到堆缓存，相对热的数据到堆外缓存，不热的数据存到磁盘缓存。<br>集群时：存储最热的数据到堆缓存，相对热的数据到堆外缓存，全量数据存到分布式缓存。</li>\n<li>Java缓存实现<br>3.1 堆缓存<br>3.1.1 Guava Cache实现<br>Guava Cache只提供堆缓存，小巧灵活，性能最好，如果只使用堆缓存，那么使用它就够了。<br>Cache<string, string=\"\"> myCache=<pre><code>CacheBuilder.newBuilder()\n.concurrencyLevel(4)\n.expireAfterWrite(10, TimeUnit.SECONDS)\n.maximumSize(10000)\n.build();\n</code></pre>然后可以通过put、getIfPresent 来读写缓存。CacheBuilder有几类参数：缓存回收策略、并发设置等。<br>3.1.1.1 缓存回收策略/基于容量<br>maximumSize：设置缓存的容量，当超出maximumSize时，按照LRU进行缓存回收。<br>3.1.1.2 缓存回收策略/基于时间<br>expireAfterWrite：设置TTL，缓存数据在给定的时间内没有写(创建/覆盖)时，则被回收，即定期的会回收缓存数据。<br>expireAfterAccess：设置TTI，缓存数据在给定的时间内没有读/写时，则被回收。每次访问时，都会更新它的TTI，从而如果该缓存是非常热的数据，则将一直不过期，可能会导致脏数据存在很长时间(因此，建议设置expireAfterWrite)。<br>3.1.1.3 缓存回收策略/基于Java对象引用<br>weakKeys/weakValues：设置弱引用缓存。<br>softValues：设置软引用缓存。<br>3.1.1.4 缓存回收策略/主动失效<br>invalidate(Object key)/invalidateAll(Iterablekeys)/invalidateAll()：主动失效某些缓存数据。<br>什么时候触发失效呢? Guava Cache不会在缓存数据失效时立即触发回收操作(如果要这么做，则需要有额外的线程来进行清理)，是在PUT时会主动进行一次清理缓存，当然读者也可以根据实际业务通过自己设计线程来调用cleanUp方法进行清理。<br>3.1.1.5 并发级别<br>concurrencyLevel：Guava Cache重写了ConcurrentHashMap，concurrencyLevel用来设置Segment数量，concurrencyLevel越大并发能力越强。<br>3.1.1.6 统计命中率<br>recordStats：启动记录统计信息，比如命中率等<br>3.1.2 EhCache 3.x实现<br>CacheManager cacheManager = CacheManagerBuilder. newCacheManagerBuilder(). build(true);<br>CacheConfigurationBuilder<string, string=\"\"> cacheConfig= CacheConfigurationBuilder.newCacheConfigurationBuilder(<pre><code>String.class,\nString.class,\nResourcePoolsBuilder.newResourcePoolsBuilder()\n        .heap(100, EntryUnit.ENTRIES))\n.withDispatcherConcurrency(4)\n.withExpiry(Expirations.timeToLiveExpiration(Duration.of(10,TimeUnit.SECONDS)));\n</code></pre>Cache<string, string=\"\"> myCache = cacheManager.createCache(“myCache”,cacheConfig);<br>CacheManager在JVM关闭时请调用CacheManager.close()方法。 可以通过PUT、GET来读写缓存。CacheConfigurationBuilder也有几类参数：缓存回收策略、并发设置、统计命中率等。<br>3.1.2.1 缓存回收策略/基于容量<br>heap(100, EntryUnit.ENTRIES)：设置缓存的条目数量，当超出此数量时按照LRU进行缓存回收。<br>3.1.2.2 缓存回收策略/基于空间<br>heap(100, MemoryUnit.MB)：设置缓存的内存空间，当超出此空间时按照LRU进行缓存回收。另外，应该设置withSizeOfMaxObjectGraph(2)：统计对象大小时对象图遍历深度和withSizeOfMaxObjectSize(1, MemoryUnit.KB)：可缓存的最大对象大小。<br>3.1.2.3 缓存回收策略/基于时间<br>withExpiry(Expirations.timeToLiveExpiration(Duration.of(10,TimeUnit.SECONDS)))：设置TTL，没有TTI。<br>withExpiry(Expirations.timeToIdleExpiration(Duration.of(10,TimeUnit.SECONDS)))：同时设置TTL和TTI，且TTL和TTI值一样。<br>3.1.2.4 缓存回收策略/主动失效<br>remove(K key)/ removeAll(Set keys)/clear()：主动失效某些缓存数据。<br>什么时候触发失效呢?EhCache使用了类似于Guava Cache同样的机制。<br>3.1.2.5 并发级别<br>目前还没有提供API来设置，EhCache内部使用ConcurrentHashMap作为缓存存储，默认并发级别16。withDispatcherConcurrency是用来设置事件分发时的并发级别。<br>3.1.3 MapDB 3.x 实现<br>HTreeMap myCache =<pre><code>DBMaker.heapDB().concurrencyScale(16).make().hashMap(&quot;myCache&quot;)\n.expireMaxSize(10000)\n.expireAfterCreate(10, TimeUnit.SECONDS)\n.expireAfterUpdate(10,TimeUnit.SECONDS)\n.expireAfterGet(10, TimeUnit.SECONDS)\n.create();\n</code></pre>然后可以通过PUT、GET来读写缓存。其有几类参数：缓存回收策略、并发设置、统计命中率等。<br>3.1.3.1 缓存回收策略/基于容量<br>expireMaxSize：设置缓存的容量，当超出expireMaxSize时，按照LRU进行缓存回收。<br>3.1.3.2 缓存回收策略/基于时间<br>expireAfterCreate/expireAfterUpdate：设置TTL，缓存数据在给定的时间内没有写(创建/覆盖)时，则被回收。即定期的会回收缓存数据。<br>expireAfterGet：设置TTI， 缓存数据在给定的时间内没有读/写时，则被回收。每次访问时都会更新它的TTI，从而如果该缓存是非常热的数据，则将一直不过期，可能会导致脏数据存在很长的时间(因此，建议要设置expireAfterCreate/expireAfterUpdate)。<br>3.1.3.3 缓存回收策略/主动失效<br>remove(Object key) /clear()：主动失效某些缓存数据。<br>什么时候触发失效呢?<br>MapDB默认使用类似于Guava Cache的机制。不过，也支持可以通过如下配置使用线程池定期进行缓存失效。<br>expireExecutor(scheduledExecutorService)<br>expireExecutorPeriod(3000)</string,></string,></string,></li>\n</ol>\n<p>3.1.3.4 并发级别</p>\n<p>concurrencyScale：类似于Guava Cache配置。</p>\n<p>还可以使用DBMaker.memoryDB()创建堆缓存，它将数据序列化并存储到1MB大小的byte[]数组中，从而减少垃圾回收的影响。</p>\n<p>3.2 堆外缓存</p>\n<p>3.2.1 EhCache 3.x实现</p>\n<p>CacheConfigurationBuilder<string, string=\"\"> cacheConfig= CacheConfigurationBuilder.newCacheConfigurationBuilder(<br>       String.class,<br>       String.class,<br>       ResourcePoolsBuilder.newResourcePoolsBuilder()<br>               .offheap(100, MemoryUnit.MB))<br>       .withDispatcherConcurrency(4)<br>       .withExpiry(Expirations.timeToLiveExpiration(Duration.of(10,TimeUnit.SECONDS)))<br>       .withSizeOfMaxObjectGraph(3)<br>       .withSizeOfMaxObjectSize(1, MemoryUnit.KB);</string,></p>\n<p>堆外缓存不支持基于容量的缓存过期策略。</p>\n<p>3.2.2 MapDB 3.x实现</p>\n<p>HTreeMap myCache =<br>       DBMaker.memoryDirectDB().concurrencyScale(16).make().hashMap(“myCache”)<br>       .expireStoreSize(64 <em> 1024 </em> 1024) //指定堆外缓存大小64MB<br>       .expireMaxSize(10000)<br>       .expireAfterCreate(10, TimeUnit.SECONDS)<br>       .expireAfterUpdate(10, TimeUnit.SECONDS)<br>       .expireAfterGet(10, TimeUnit.SECONDS)<br>       .create();</p>\n<p>在使用堆外缓存时，请记得添加JVM启动参数，如-XX:MaxDirectMemorySize=10G。</p>\n<p>3.3 磁盘缓存</p>\n<p>3.3.1 EhCache 3.x实现</p>\n<p>CacheManager cacheManager = CacheManagerBuilder. newCacheManagerBuilder()<br>        //默认线程池<br>        .using(PooledExecutionServiceConfigurationBuilder.newPooledExecutionServiceConfigurationBuilder().defaultPool(“default”,1, 10).build())<br>        //磁盘文件存储位置<br>        .with(new CacheManagerPersistenceConfiguration(newFile(“D:\\bak”)))<br>        .build(true);</p>\n<p>CacheConfigurationBuilder<string, string=\"\"> cacheConfig= CacheConfigurationBuilder. newCacheConfigurationBuilder(<br>       String.class,<br>       String.class,<br>       ResourcePoolsBuilder.newResourcePoolsBuilder()<br>       .disk(100, MemoryUnit.MB,true))       //磁盘缓存<br>       .withDiskStoreThreadPool(“default”, 5) //使用”default”线程池进行dump文件到磁盘<br>       .withExpiry(Expirations.timeToLiveExpiration(Duration.of(50,TimeUnit.SECONDS)))<br>       .withSizeOfMaxObjectGraph(3)<br>       .withSizeOfMaxObjectSize(1, MemoryUnit.KB);</string,></p>\n<p>在JVM停止时，记得调用cacheManager.close()，从而保证内存数据能dump到磁盘。<br>3.3.2 MapDB 3.x实现</p>\n<p>DB db = DBMaker<br>        .fileDB(“D:\\bak\\a.data”)//数据存哪里<br>        .fileMmapEnable() //启用mmap<br>        .fileMmapEnableIfSupported() //在支持的平台上启用mmap<br>        .fileMmapPreclearDisable() //让mmap文件更快<br>        .cleanerHackEnable() //一些BUG处理<br>        .transactionEnable() //启用事务<br>        .closeOnJvmShutdown()<br>        .concurrencyScale(16)<br>        .make();</p>\n<p>HTreeMap myCache = db.hashMap(“myCache”)<br>       .expireMaxSize(10000)<br>       .expireAfterCreate(10, TimeUnit.SECONDS)<br>       .expireAfterUpdate(10, TimeUnit.SECONDS)<br>       .expireAfterGet(10, TimeUnit.SECONDS)<br>       .createOrOpen();</p>\n<p>因为开启了事务，MapDB则开启了WAL。另外，操作完缓存后记得调用db.commit方法提交事务。</p>\n<p>myCache.put(“key” + counterWriter,”value” + counterWriter);<br>db.commit();</p>\n<p>3.4 分布式缓存</p>\n<p>3.4.1 Ehcache 3.1 + Terracotta Server</p>\n<p>不建议使用。</p>\n<p>3.4.2 Redis</p>\n<p>性能非常好，有主从模式、集群模式。</p>\n<p>3.5 多级缓存</p>\n<p>如先查找堆缓存，如果没有查找磁盘缓存，则使用MapDB可以通过如下配置实现。</p>\n<p>HTreeMap diskCache = db.hashMap(“myCache”)<br>       .expireStoreSize(8 <em> 1024 </em> 1024 * 1024)<br>       .expireMaxSize(10000)<br>       .expireAfterCreate(10, TimeUnit.SECONDS)<br>       .expireAfterUpdate(10, TimeUnit.SECONDS)<br>       .expireAfterGet(10, TimeUnit.SECONDS)<br>       .createOrOpen();</p>\n<p>HTreeMap heapCache = db.hashMap(“myCache”)<br>       .expireMaxSize(100)<br>       .expireAfterCreate(10, TimeUnit.SECONDS)<br>       .expireAfterUpdate(10, TimeUnit.SECONDS)<br>       .expireAfterGet(10, TimeUnit.SECONDS)<br>       .expireOverflow(diskCache) //当缓存溢出时存储到disk<br>       .createOrOpen();</p>\n<ol>\n<li>缓存使用模式</li>\n</ol>\n<p>主要分两大类：Cache-Aside和Cache-As-SoR(Read-through、Write-through、Write-behind)</p>\n<p>SoR(system-of-record)：记录系统，或者可以叫做数据源，即实际存储原始数据的系统。<br>Cache：缓存，是SoR的快照数据，Cache的访问速度比SoR要快，放入Cache的目的是提升访问速度，减少回源到SoR的次数。<br>回源：即回到数据源头获取数据，Cache没有命中时，需要从SoR读取数据，这叫做回源。</p>\n<p>4.1 Cache-Aside</p>\n<p>Cache-Aside 即业务代码围绕着Cache写，是由业务代码直接维护缓存，示例代码如下所示。</p>\n<p>4.1.1 读场景</p>\n<p>先从缓存获取数据，如果没有命中，则回源到SoR并将源数据放入缓存供下次读取使用。</p>\n<p>//1、先从缓存中获取数据<br>value = myCache.getIfPresent(key);<br>if(value == null) {<br>    //2.1、如果缓存没有命中，则回源到SoR获取源数据<br>    value = loadFromSoR(key);<br>    //2.2、将数据放入缓存，下次即可从缓存中获取数据<br>    myCache.put(key, value);<br>}</p>\n<p>4.1.2 写场景</p>\n<p>先将数据写入SoR，写入成功后立即将数据同步写入缓存。</p>\n<p>//1、先将数据写入SoR<br>writeToSoR(key,value);<br>//2、执行成功后立即同步写入缓存<br>myCache.put(key, value);</p>\n<p>或者先将数据写入SoR，写入成功后将缓存数据过期，下次读取时再加载缓存。</p>\n<p>//1、先将数据写入SoR<br>writeToSoR(key,value);<br>//2、失效缓存，然后下次读时再加载缓存<br>myCache.invalidate(key);</p>\n<p>Cache-Aside适合使用AOP模式去实现</p>\n<p>4.2 Cache-As-SoR</p>\n<p>Cache-As-SoR即把Cache看作为SoR，所有操作都是对Cache进行，然后Cache再委托给SoR进行真实的读/写。即业务代码中只看到Cache的操作，看不到关于SoR相关的代码。有三种实现：read-through、write-through、write-behind。</p>\n<p>4.2.1 Read-Through</p>\n<p>Read-Through，业务代码首先调用Cache，如果Cache不命中由Cache回源到SoR，而不是业务代码(即由Cache读SoR)。使用Read-Through模式，需要配置一个CacheLoader组件用来回源到SoR加载源数据。Guava Cache和Ehcache 3.x都支持该模式。</p>\n<p>4.2.1.1 Guava Cache实现</p>\n<p>LoadingCache<integer,result<category>&gt; getCache =<br>       CacheBuilder.newBuilder()<br>       .softValues()<br>       .maximumSize(5000).expireAfterWrite(2, TimeUnit.MINUTES)<br>        .build(new CacheLoader<integer,result<category>&gt;() {<br>           @Override<br>           public Result<category> load(final Integer sortId) throwsException {<br>                return categoryService.get(sortId);<br>           }<br>       });</category></integer,result<category></integer,result<category></p>\n<p>在build Cache时，传入一个CacheLoader用来加载缓存，操作流程如下：</p>\n<p>应用业务代码直接调用getCache.get(sortId)。<br>首先查询Cache，如果缓存中有，则直接返回缓存数据。<br>如果缓存没有命中，则委托给CacheLoader，CacheLoader会回源到SoR查询源数据(返回值必须不为null，可以包装为Null对象)，然后写入缓存。</p>\n<p>使用CacheLoader后有几个好处：</p>\n<p>应用业务代码更简洁了，不需要像Cache-Aside模式那样缓存查询代码和SoR代码交织在一起。如果缓存使用逻辑散落在多处，则使用这种方式很简单的消除了重复代码。<br>解决Dog-pile effect，即当某个缓存失效时，又有大量相同的请求没命中缓存，从而同时请求到后端，导致后端压力太大，此时限制一个请求去拿即可。</p>\n<p>4.2.1.2 Ehcache 3.x实现</p>\n<p>CacheManager cacheManager = CacheManagerBuilder. newCacheManagerBuilder(). build(true);<br>org.ehcache.Cache<string, string=\"\"> myCache =cacheManager. createCache (“myCache”,<br>       CacheConfigurationBuilder.newCacheConfigurationBuilder(String.class,String.class,<br>               ResourcePoolsBuilder.newResourcePoolsBuilder().heap(100,MemoryUnit.MB))<br>               .withDispatcherConcurrency(4)<br>               .withExpiry(Expirations.timeToLiveExpiration(Duration.of(10,TimeUnit.SECONDS)))<br>                .withLoaderWriter(newDefaultCacheLoaderWriter<string, string=\"\"> () {<br>                   @Override<br>                   public String load(String key) throws Exception {<br>                        return readDB(key);<br>                   }<br>                    @Override<br>                   public Map<string, string=\"\"> loadAll(Iterable&lt;? extendsString&gt; keys) throws BulkCacheLoadingException, Exception {<br>                        return null;<br>                   }<br>               }));</string,></string,></string,></p>\n<p>Ehcache 3.1没有自己去解决Dog-pile effect。</p>\n<p>4.2.2 Write-Through</p>\n<p>Write-Through，称之为穿透写模式/直写模式，业务代码首先调用Cache写(新增/修改)数据，然后由Cache负责写缓存和写SoR，而不是业务代码。</p>\n<p>使用Write-Through模式需要配置一个CacheWriter组件用来回写SoR。Guava Cache没有提供支持。Ehcache 3.x支持该模式。</p>\n<p>Ehcache需要配置一个CacheLoaderWriter，CacheLoaderWriter知道如何去写SoR。当Cache需要写(新增/修改)数据时，首先调用CacheLoaderWriter来同步(立即)到SoR，成功后会更新缓存。</p>\n<p>CacheManager cacheManager = CacheManagerBuilder.newCacheManagerBuilder().build(true);<br>Cache<string, string=\"\"> myCache =cacheManager.createCache (“myCache”,<br>       CacheConfigurationBuilder.newCacheConfigurationBuilder(String.class,String.class,<br>               ResourcePoolsBuilder.newResourcePoolsBuilder().heap(100,MemoryUnit.MB))<br>               .withDispatcherConcurrency(4)<br>               .withExpiry(Expirations.timeToLiveExpiration(Duration.of(10,TimeUnit.SECONDS)))<br>               .withLoaderWriter(newDefaultCacheLoaderWriter<string, string=\"\"> () {<br>                   @Override<br>                   public void write(String key, String value) throws Exception{<br>                        //write<br>                   }<br>                   @Override<br>                   public void writeAll(Iterable&lt;? extends Map.Entry&lt;? extendsString, ? extends String&gt;&gt; entries) throws BulkCacheWritingException,Exception {<br>                        for(Object entry: entries) {<br>                            //batch write<br>                        }<br>                   }<br>                   @Override<br>                    public void delete(Stringkey) throws Exception {<br>                        //delete<br>                   }<br>                   @Override<br>                   public void deleteAll(Iterable&lt;? extends String&gt;keys) throws BulkCacheWritingException, Exception {<br>                        for(Object key :keys) {<br>                            //batch delete<br>                        }<br>                   }<br>               }).build());</string,></string,></p>\n<p>Ehcache 3.x还是使用CacheLoaderWriter来实现，通过write(String key, String value)、writeAll(Iterable&gt; entries)和delete(String key)、deleteAll(Iterable keys)分别来支持单个写、批量写和单个删除、批量删除操作。</p>\n<p>操作流程如下：当我们调用myCache.put(“e”,”123”)或者myCache.putAll(map)时，写缓存。首先，Cache会将写操作立即委托给CacheLoaderWriter#write和#writeAll，然后由CacheLoaderWriter负责立即去写SoR。当写SoR成功后，再写入Cache。</p>\n<p>4.2.3 Write-Behind</p>\n<p>Write-Behind，也叫Write-Back，称之为回写模式，不同于Write-Through是同步写SoR和Cache，Write-Behind是异步写。异步之后可以实现批量写、合并写、延时和限流。</p>\n<p>4.2.3.1 异步写</p>\n<p>略，可用EhCache实现</p>\n<p>4.2.3.2 批量写</p>\n<p>略，可用EhCache实现</p>\n<p>4.2.4 Copy Pattern</p>\n<p>有两种Copy Pattern， Copy-On-Read和Copy-On-Write。在Guava-Cache和EhCache中堆缓存都是基于引用的，这样如果哟人拿到缓存数据并修改了它，则可能发生不可预测的问题。Guava Cache没有提供支持，EhCache 3.x提供了支持。</p>\n<p>public interface Copier<t> {<br>    T copyForRead(T obj);    //Copy-On-Read，比如myCache.get()<br>    T copyForWrite(T obj);   //Copy-On-Write，比如myCache.put()<br>}<br>参考来源：  [1] 亿级流量网站架构核心技术.张开涛著<br>出处：<a href=\"http://blog.csdn.net/foreverling/article/details/78012205\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/foreverling/article/details/78012205</a><br>版权申明：内容来源网络，版权归原创者所有。除非无法确认，我们都会标明作者及出处，如有侵权烦请告知，我们会立即删除并表示歉意。谢谢。</t></p>\n","excerpt":"<ol>\n<li>缓存回收策略<br>1.1 基于空间<br>即设置缓存的存储空间，如设置为10MB，当达到存储空间时，按照一定的策略移除数据。<br>1.2 基于容量<br>基于容量指缓存设置了最大大小，当缓存的条目超过最大大小，则按照一定的策略将旧数据移除。</li></ol>","more":"1.3 基于时间<br>TTL(Time To Live)：存活期，即缓存数据从缓存中创建时间开始直到它到期的一个时间段(不管在这个时间段内有没有访问都将过期)。<br>TTI(Time To Idle)：空闲期，即缓存数据多久没被访问过将从缓存中移除的时间。<br>1.4 基于Java对象引用<br>软引用：如果一个对象是软引用，那么当JVM堆内存不足时，垃圾回收器可以回收这些对象。软引用适合用来做缓存，从而当JVM堆内存不足时，可以回收这些对象腾出一些空间供强引用对象使用，从而避免OOM。<br>弱引用：当垃圾回收器回收内存时，如果发现弱引用，则将立即回收它。相对于软引用有更短的生命周期。<br>注意：弱引用/软引用对象只有当没有其他强引用对象引用它时，垃圾回收时才回收该引用。 即如果有一个对象(不是弱引用/软引用)引用了弱引用/软引用对象，那么垃圾回收是不会回收该引用对象。<br>1.5 回收算法<br>使用基于空间和基于容量的缓存会使用一定的策略移除旧数据，常见的如下：<br>FIFO(Fisrt In Fisrt Out)：先进先出算法，即先进入缓存的先被移除。<br>LRU(Least Recently Used)：最近最少使用算法，使用时间距离现在最久的数据被移除。<br>LFU(Least Frequently Used)：最不常用算法，一定时间段内使用次数（频率）最少的数据被移除。<br>实际应用中基于LRU的缓存较多，如Guava Cache、EhCache支持LRU。\n<li>Java缓存类型<br>2.1 堆缓存<br>使用Java堆内存来存储对象。可以使用Guava Cache、Ehcache 3.x、MapDB实现。<br>优点：使用堆缓存的好处是没有序列化/反序列化，是最快的缓存；<br>缺点：很明显，当缓存的数据量很大时， GC暂停时间会变长，存储容量受限于堆空间大小；一般通过软引用/弱引用来存储缓存对象，即当堆内存不足时，可以强制回收这部分内存释放堆内存空间。一般使用堆缓存存储较热的数据。<br>2.2 堆外缓存<br>即缓存数据存储在堆外内存。可以使用Ehcache 3.x、MapDB实现。<br>优点：可以减少GC暂停时间(堆对象转移到堆外，GC扫描和移动的对象变少了)，可以支持更大的缓存空间(只受机器内存大小限制，不受堆空间的影响)。<br>缺点：读取数据时需要序列化/反序列化，会比堆缓存慢很多。<br>2.3 磁盘缓存<br>即缓存数据的存储在磁盘上。当JVM重启时数据还是在的。而堆缓存/堆外缓存重启时数据会丢失，需要重新加载。可以使用Ehcache 3.x、MapDB实现。<br>2.4 分布式缓存<br>在多JVM实例的情况时，进程内缓存和磁盘缓存会存在两个问题：1.单机容量问题; 2.数据一致性问题（既然数据允许缓存，则表示允许一定时间内的不一致，因此可以设置缓存数据的过期时间来定期更新数据）; 3.缓存不命中时，需要回源到DB/服务查询变多：每个实例在缓存不命中情况下都会回源到DB加载数据，因此，多实例后DB整体的访问量就变多了。解决办法可以使用如一致性哈希分片算法来解决。因此，这些情况可以考虑使用分布式缓存来解决。可以使用ehcache-clustered(配合Terracotta server)实现Java进程间分布式缓存。当然也可以使用如Redis实现分布式缓存。<br>两种模式如下：<br>单机时：存储最热的数据到堆缓存，相对热的数据到堆外缓存，不热的数据存到磁盘缓存。<br>集群时：存储最热的数据到堆缓存，相对热的数据到堆外缓存，全量数据存到分布式缓存。</li>\n<li>Java缓存实现<br>3.1 堆缓存<br>3.1.1 Guava Cache实现<br>Guava Cache只提供堆缓存，小巧灵活，性能最好，如果只使用堆缓存，那么使用它就够了。<br>Cache<String, string=\"\"> myCache=<pre><code>CacheBuilder.newBuilder()\n.concurrencyLevel(4)\n.expireAfterWrite(10, TimeUnit.SECONDS)\n.maximumSize(10000)\n.build();\n</code></pre>然后可以通过put、getIfPresent 来读写缓存。CacheBuilder有几类参数：缓存回收策略、并发设置等。<br>3.1.1.1 缓存回收策略/基于容量<br>maximumSize：设置缓存的容量，当超出maximumSize时，按照LRU进行缓存回收。<br>3.1.1.2 缓存回收策略/基于时间<br>expireAfterWrite：设置TTL，缓存数据在给定的时间内没有写(创建/覆盖)时，则被回收，即定期的会回收缓存数据。<br>expireAfterAccess：设置TTI，缓存数据在给定的时间内没有读/写时，则被回收。每次访问时，都会更新它的TTI，从而如果该缓存是非常热的数据，则将一直不过期，可能会导致脏数据存在很长时间(因此，建议设置expireAfterWrite)。<br>3.1.1.3 缓存回收策略/基于Java对象引用<br>weakKeys/weakValues：设置弱引用缓存。<br>softValues：设置软引用缓存。<br>3.1.1.4 缓存回收策略/主动失效<br>invalidate(Object key)/invalidateAll(Iterablekeys)/invalidateAll()：主动失效某些缓存数据。<br>什么时候触发失效呢? Guava Cache不会在缓存数据失效时立即触发回收操作(如果要这么做，则需要有额外的线程来进行清理)，是在PUT时会主动进行一次清理缓存，当然读者也可以根据实际业务通过自己设计线程来调用cleanUp方法进行清理。<br>3.1.1.5 并发级别<br>concurrencyLevel：Guava Cache重写了ConcurrentHashMap，concurrencyLevel用来设置Segment数量，concurrencyLevel越大并发能力越强。<br>3.1.1.6 统计命中率<br>recordStats：启动记录统计信息，比如命中率等<br>3.1.2 EhCache 3.x实现<br>CacheManager cacheManager = CacheManagerBuilder. newCacheManagerBuilder(). build(true);<br>CacheConfigurationBuilder<String, string=\"\"> cacheConfig= CacheConfigurationBuilder.newCacheConfigurationBuilder(<pre><code>String.class,\nString.class,\nResourcePoolsBuilder.newResourcePoolsBuilder()\n        .heap(100, EntryUnit.ENTRIES))\n.withDispatcherConcurrency(4)\n.withExpiry(Expirations.timeToLiveExpiration(Duration.of(10,TimeUnit.SECONDS)));\n</code></pre>Cache<String, string=\"\"> myCache = cacheManager.createCache(“myCache”,cacheConfig);<br>CacheManager在JVM关闭时请调用CacheManager.close()方法。 可以通过PUT、GET来读写缓存。CacheConfigurationBuilder也有几类参数：缓存回收策略、并发设置、统计命中率等。<br>3.1.2.1 缓存回收策略/基于容量<br>heap(100, EntryUnit.ENTRIES)：设置缓存的条目数量，当超出此数量时按照LRU进行缓存回收。<br>3.1.2.2 缓存回收策略/基于空间<br>heap(100, MemoryUnit.MB)：设置缓存的内存空间，当超出此空间时按照LRU进行缓存回收。另外，应该设置withSizeOfMaxObjectGraph(2)：统计对象大小时对象图遍历深度和withSizeOfMaxObjectSize(1, MemoryUnit.KB)：可缓存的最大对象大小。<br>3.1.2.3 缓存回收策略/基于时间<br>withExpiry(Expirations.timeToLiveExpiration(Duration.of(10,TimeUnit.SECONDS)))：设置TTL，没有TTI。<br>withExpiry(Expirations.timeToIdleExpiration(Duration.of(10,TimeUnit.SECONDS)))：同时设置TTL和TTI，且TTL和TTI值一样。<br>3.1.2.4 缓存回收策略/主动失效<br>remove(K key)/ removeAll(Set keys)/clear()：主动失效某些缓存数据。<br>什么时候触发失效呢?EhCache使用了类似于Guava Cache同样的机制。<br>3.1.2.5 并发级别<br>目前还没有提供API来设置，EhCache内部使用ConcurrentHashMap作为缓存存储，默认并发级别16。withDispatcherConcurrency是用来设置事件分发时的并发级别。<br>3.1.3 MapDB 3.x 实现<br>HTreeMap myCache =<pre><code>DBMaker.heapDB().concurrencyScale(16).make().hashMap(&quot;myCache&quot;)\n.expireMaxSize(10000)\n.expireAfterCreate(10, TimeUnit.SECONDS)\n.expireAfterUpdate(10,TimeUnit.SECONDS)\n.expireAfterGet(10, TimeUnit.SECONDS)\n.create();\n</code></pre>然后可以通过PUT、GET来读写缓存。其有几类参数：缓存回收策略、并发设置、统计命中率等。<br>3.1.3.1 缓存回收策略/基于容量<br>expireMaxSize：设置缓存的容量，当超出expireMaxSize时，按照LRU进行缓存回收。<br>3.1.3.2 缓存回收策略/基于时间<br>expireAfterCreate/expireAfterUpdate：设置TTL，缓存数据在给定的时间内没有写(创建/覆盖)时，则被回收。即定期的会回收缓存数据。<br>expireAfterGet：设置TTI， 缓存数据在给定的时间内没有读/写时，则被回收。每次访问时都会更新它的TTI，从而如果该缓存是非常热的数据，则将一直不过期，可能会导致脏数据存在很长的时间(因此，建议要设置expireAfterCreate/expireAfterUpdate)。<br>3.1.3.3 缓存回收策略/主动失效<br>remove(Object key) /clear()：主动失效某些缓存数据。<br>什么时候触发失效呢?<br>MapDB默认使用类似于Guava Cache的机制。不过，也支持可以通过如下配置使用线程池定期进行缓存失效。<br>expireExecutor(scheduledExecutorService)<br>expireExecutorPeriod(3000)</String,></String,></String,></li>\n\n<p>3.1.3.4 并发级别</p>\n<p>concurrencyScale：类似于Guava Cache配置。</p>\n<p>还可以使用DBMaker.memoryDB()创建堆缓存，它将数据序列化并存储到1MB大小的byte[]数组中，从而减少垃圾回收的影响。</p>\n<p>3.2 堆外缓存</p>\n<p>3.2.1 EhCache 3.x实现</p>\n<p>CacheConfigurationBuilder<String, string=\"\"> cacheConfig= CacheConfigurationBuilder.newCacheConfigurationBuilder(<br>       String.class,<br>       String.class,<br>       ResourcePoolsBuilder.newResourcePoolsBuilder()<br>               .offheap(100, MemoryUnit.MB))<br>       .withDispatcherConcurrency(4)<br>       .withExpiry(Expirations.timeToLiveExpiration(Duration.of(10,TimeUnit.SECONDS)))<br>       .withSizeOfMaxObjectGraph(3)<br>       .withSizeOfMaxObjectSize(1, MemoryUnit.KB);</String,></p>\n<p>堆外缓存不支持基于容量的缓存过期策略。</p>\n<p>3.2.2 MapDB 3.x实现</p>\n<p>HTreeMap myCache =<br>       DBMaker.memoryDirectDB().concurrencyScale(16).make().hashMap(“myCache”)<br>       .expireStoreSize(64 <em> 1024 </em> 1024) //指定堆外缓存大小64MB<br>       .expireMaxSize(10000)<br>       .expireAfterCreate(10, TimeUnit.SECONDS)<br>       .expireAfterUpdate(10, TimeUnit.SECONDS)<br>       .expireAfterGet(10, TimeUnit.SECONDS)<br>       .create();</p>\n<p>在使用堆外缓存时，请记得添加JVM启动参数，如-XX:MaxDirectMemorySize=10G。</p>\n<p>3.3 磁盘缓存</p>\n<p>3.3.1 EhCache 3.x实现</p>\n<p>CacheManager cacheManager = CacheManagerBuilder. newCacheManagerBuilder()<br>        //默认线程池<br>        .using(PooledExecutionServiceConfigurationBuilder.newPooledExecutionServiceConfigurationBuilder().defaultPool(“default”,1, 10).build())<br>        //磁盘文件存储位置<br>        .with(new CacheManagerPersistenceConfiguration(newFile(“D:\\bak”)))<br>        .build(true);</p>\n<p>CacheConfigurationBuilder<String, string=\"\"> cacheConfig= CacheConfigurationBuilder. newCacheConfigurationBuilder(<br>       String.class,<br>       String.class,<br>       ResourcePoolsBuilder.newResourcePoolsBuilder()<br>       .disk(100, MemoryUnit.MB,true))       //磁盘缓存<br>       .withDiskStoreThreadPool(“default”, 5) //使用”default”线程池进行dump文件到磁盘<br>       .withExpiry(Expirations.timeToLiveExpiration(Duration.of(50,TimeUnit.SECONDS)))<br>       .withSizeOfMaxObjectGraph(3)<br>       .withSizeOfMaxObjectSize(1, MemoryUnit.KB);</String,></p>\n<p>在JVM停止时，记得调用cacheManager.close()，从而保证内存数据能dump到磁盘。<br>3.3.2 MapDB 3.x实现</p>\n<p>DB db = DBMaker<br>        .fileDB(“D:\\bak\\a.data”)//数据存哪里<br>        .fileMmapEnable() //启用mmap<br>        .fileMmapEnableIfSupported() //在支持的平台上启用mmap<br>        .fileMmapPreclearDisable() //让mmap文件更快<br>        .cleanerHackEnable() //一些BUG处理<br>        .transactionEnable() //启用事务<br>        .closeOnJvmShutdown()<br>        .concurrencyScale(16)<br>        .make();</p>\n<p>HTreeMap myCache = db.hashMap(“myCache”)<br>       .expireMaxSize(10000)<br>       .expireAfterCreate(10, TimeUnit.SECONDS)<br>       .expireAfterUpdate(10, TimeUnit.SECONDS)<br>       .expireAfterGet(10, TimeUnit.SECONDS)<br>       .createOrOpen();</p>\n<p>因为开启了事务，MapDB则开启了WAL。另外，操作完缓存后记得调用db.commit方法提交事务。</p>\n<p>myCache.put(“key” + counterWriter,”value” + counterWriter);<br>db.commit();</p>\n<p>3.4 分布式缓存</p>\n<p>3.4.1 Ehcache 3.1 + Terracotta Server</p>\n<p>不建议使用。</p>\n<p>3.4.2 Redis</p>\n<p>性能非常好，有主从模式、集群模式。</p>\n<p>3.5 多级缓存</p>\n<p>如先查找堆缓存，如果没有查找磁盘缓存，则使用MapDB可以通过如下配置实现。</p>\n<p>HTreeMap diskCache = db.hashMap(“myCache”)<br>       .expireStoreSize(8 <em> 1024 </em> 1024 * 1024)<br>       .expireMaxSize(10000)<br>       .expireAfterCreate(10, TimeUnit.SECONDS)<br>       .expireAfterUpdate(10, TimeUnit.SECONDS)<br>       .expireAfterGet(10, TimeUnit.SECONDS)<br>       .createOrOpen();</p>\n<p>HTreeMap heapCache = db.hashMap(“myCache”)<br>       .expireMaxSize(100)<br>       .expireAfterCreate(10, TimeUnit.SECONDS)<br>       .expireAfterUpdate(10, TimeUnit.SECONDS)<br>       .expireAfterGet(10, TimeUnit.SECONDS)<br>       .expireOverflow(diskCache) //当缓存溢出时存储到disk<br>       .createOrOpen();</p>\n<ol>\n<li>缓存使用模式</li>\n</ol>\n<p>主要分两大类：Cache-Aside和Cache-As-SoR(Read-through、Write-through、Write-behind)</p>\n<p>SoR(system-of-record)：记录系统，或者可以叫做数据源，即实际存储原始数据的系统。<br>Cache：缓存，是SoR的快照数据，Cache的访问速度比SoR要快，放入Cache的目的是提升访问速度，减少回源到SoR的次数。<br>回源：即回到数据源头获取数据，Cache没有命中时，需要从SoR读取数据，这叫做回源。</p>\n<p>4.1 Cache-Aside</p>\n<p>Cache-Aside 即业务代码围绕着Cache写，是由业务代码直接维护缓存，示例代码如下所示。</p>\n<p>4.1.1 读场景</p>\n<p>先从缓存获取数据，如果没有命中，则回源到SoR并将源数据放入缓存供下次读取使用。</p>\n<p>//1、先从缓存中获取数据<br>value = myCache.getIfPresent(key);<br>if(value == null) {<br>    //2.1、如果缓存没有命中，则回源到SoR获取源数据<br>    value = loadFromSoR(key);<br>    //2.2、将数据放入缓存，下次即可从缓存中获取数据<br>    myCache.put(key, value);<br>}</p>\n<p>4.1.2 写场景</p>\n<p>先将数据写入SoR，写入成功后立即将数据同步写入缓存。</p>\n<p>//1、先将数据写入SoR<br>writeToSoR(key,value);<br>//2、执行成功后立即同步写入缓存<br>myCache.put(key, value);</p>\n<p>或者先将数据写入SoR，写入成功后将缓存数据过期，下次读取时再加载缓存。</p>\n<p>//1、先将数据写入SoR<br>writeToSoR(key,value);<br>//2、失效缓存，然后下次读时再加载缓存<br>myCache.invalidate(key);</p>\n<p>Cache-Aside适合使用AOP模式去实现</p>\n<p>4.2 Cache-As-SoR</p>\n<p>Cache-As-SoR即把Cache看作为SoR，所有操作都是对Cache进行，然后Cache再委托给SoR进行真实的读/写。即业务代码中只看到Cache的操作，看不到关于SoR相关的代码。有三种实现：read-through、write-through、write-behind。</p>\n<p>4.2.1 Read-Through</p>\n<p>Read-Through，业务代码首先调用Cache，如果Cache不命中由Cache回源到SoR，而不是业务代码(即由Cache读SoR)。使用Read-Through模式，需要配置一个CacheLoader组件用来回源到SoR加载源数据。Guava Cache和Ehcache 3.x都支持该模式。</p>\n<p>4.2.1.1 Guava Cache实现</p>\n<p>LoadingCache<Integer,Result<Category>&gt; getCache =<br>       CacheBuilder.newBuilder()<br>       .softValues()<br>       .maximumSize(5000).expireAfterWrite(2, TimeUnit.MINUTES)<br>        .build(new CacheLoader<Integer,Result<Category>&gt;() {<br>           @Override<br>           public Result<Category> load(final Integer sortId) throwsException {<br>                return categoryService.get(sortId);<br>           }<br>       });</Category></Integer,Result<Category></Integer,Result<Category></p>\n<p>在build Cache时，传入一个CacheLoader用来加载缓存，操作流程如下：</p>\n<p>应用业务代码直接调用getCache.get(sortId)。<br>首先查询Cache，如果缓存中有，则直接返回缓存数据。<br>如果缓存没有命中，则委托给CacheLoader，CacheLoader会回源到SoR查询源数据(返回值必须不为null，可以包装为Null对象)，然后写入缓存。</p>\n<p>使用CacheLoader后有几个好处：</p>\n<p>应用业务代码更简洁了，不需要像Cache-Aside模式那样缓存查询代码和SoR代码交织在一起。如果缓存使用逻辑散落在多处，则使用这种方式很简单的消除了重复代码。<br>解决Dog-pile effect，即当某个缓存失效时，又有大量相同的请求没命中缓存，从而同时请求到后端，导致后端压力太大，此时限制一个请求去拿即可。</p>\n<p>4.2.1.2 Ehcache 3.x实现</p>\n<p>CacheManager cacheManager = CacheManagerBuilder. newCacheManagerBuilder(). build(true);<br>org.ehcache.Cache<String, string=\"\"> myCache =cacheManager. createCache (“myCache”,<br>       CacheConfigurationBuilder.newCacheConfigurationBuilder(String.class,String.class,<br>               ResourcePoolsBuilder.newResourcePoolsBuilder().heap(100,MemoryUnit.MB))<br>               .withDispatcherConcurrency(4)<br>               .withExpiry(Expirations.timeToLiveExpiration(Duration.of(10,TimeUnit.SECONDS)))<br>                .withLoaderWriter(newDefaultCacheLoaderWriter<String, string=\"\"> () {<br>                   @Override<br>                   public String load(String key) throws Exception {<br>                        return readDB(key);<br>                   }<br>                    @Override<br>                   public Map<String, string=\"\"> loadAll(Iterable&lt;? extendsString&gt; keys) throws BulkCacheLoadingException, Exception {<br>                        return null;<br>                   }<br>               }));</String,></String,></String,></p>\n<p>Ehcache 3.1没有自己去解决Dog-pile effect。</p>\n<p>4.2.2 Write-Through</p>\n<p>Write-Through，称之为穿透写模式/直写模式，业务代码首先调用Cache写(新增/修改)数据，然后由Cache负责写缓存和写SoR，而不是业务代码。</p>\n<p>使用Write-Through模式需要配置一个CacheWriter组件用来回写SoR。Guava Cache没有提供支持。Ehcache 3.x支持该模式。</p>\n<p>Ehcache需要配置一个CacheLoaderWriter，CacheLoaderWriter知道如何去写SoR。当Cache需要写(新增/修改)数据时，首先调用CacheLoaderWriter来同步(立即)到SoR，成功后会更新缓存。</p>\n<p>CacheManager cacheManager = CacheManagerBuilder.newCacheManagerBuilder().build(true);<br>Cache<String, string=\"\"> myCache =cacheManager.createCache (“myCache”,<br>       CacheConfigurationBuilder.newCacheConfigurationBuilder(String.class,String.class,<br>               ResourcePoolsBuilder.newResourcePoolsBuilder().heap(100,MemoryUnit.MB))<br>               .withDispatcherConcurrency(4)<br>               .withExpiry(Expirations.timeToLiveExpiration(Duration.of(10,TimeUnit.SECONDS)))<br>               .withLoaderWriter(newDefaultCacheLoaderWriter<String, string=\"\"> () {<br>                   @Override<br>                   public void write(String key, String value) throws Exception{<br>                        //write<br>                   }<br>                   @Override<br>                   public void writeAll(Iterable&lt;? extends Map.Entry&lt;? extendsString, ? extends String&gt;&gt; entries) throws BulkCacheWritingException,Exception {<br>                        for(Object entry: entries) {<br>                            //batch write<br>                        }<br>                   }<br>                   @Override<br>                    public void delete(Stringkey) throws Exception {<br>                        //delete<br>                   }<br>                   @Override<br>                   public void deleteAll(Iterable&lt;? extends String&gt;keys) throws BulkCacheWritingException, Exception {<br>                        for(Object key :keys) {<br>                            //batch delete<br>                        }<br>                   }<br>               }).build());</String,></String,></p>\n<p>Ehcache 3.x还是使用CacheLoaderWriter来实现，通过write(String key, String value)、writeAll(Iterable&gt; entries)和delete(String key)、deleteAll(Iterable keys)分别来支持单个写、批量写和单个删除、批量删除操作。</p>\n<p>操作流程如下：当我们调用myCache.put(“e”,”123”)或者myCache.putAll(map)时，写缓存。首先，Cache会将写操作立即委托给CacheLoaderWriter#write和#writeAll，然后由CacheLoaderWriter负责立即去写SoR。当写SoR成功后，再写入Cache。</p>\n<p>4.2.3 Write-Behind</p>\n<p>Write-Behind，也叫Write-Back，称之为回写模式，不同于Write-Through是同步写SoR和Cache，Write-Behind是异步写。异步之后可以实现批量写、合并写、延时和限流。</p>\n<p>4.2.3.1 异步写</p>\n<p>略，可用EhCache实现</p>\n<p>4.2.3.2 批量写</p>\n<p>略，可用EhCache实现</p>\n<p>4.2.4 Copy Pattern</p>\n<p>有两种Copy Pattern， Copy-On-Read和Copy-On-Write。在Guava-Cache和EhCache中堆缓存都是基于引用的，这样如果哟人拿到缓存数据并修改了它，则可能发生不可预测的问题。Guava Cache没有提供支持，EhCache 3.x提供了支持。</p>\n<p>public interface Copier<T> {<br>    T copyForRead(T obj);    //Copy-On-Read，比如myCache.get()<br>    T copyForWrite(T obj);   //Copy-On-Write，比如myCache.put()<br>}<br>参考来源：  [1] 亿级流量网站架构核心技术.张开涛著<br>出处：<a href=\"http://blog.csdn.net/foreverling/article/details/78012205\">http://blog.csdn.net/foreverling/article/details/78012205</a><br>版权申明：内容来源网络，版权归原创者所有。除非无法确认，我们都会标明作者及出处，如有侵权烦请告知，我们会立即删除并表示歉意。谢谢。</T></p>"},{"title":"web.xml详解","date":"2017-12-27T08:12:43.000Z","_content":"一  web.xml常用配置文件元素及其意义概览\n<!--more-->\n```\n <web-app>\n       <!--定义了WEB应用的名字-->\n       <display-name></display-name>\n       <!--声明WEB应用的描述信息-->\n       <description></description>\n\n      <!--context-param元素声明应用范围内的初始化参数-->\n      <context-param></context-param>\n\n      <!--过滤器元素将一个名字与一个实现javax.servlet.Filter接口的类相关联-->\n      <filter></filter>\n\n      <!--一旦命名了一个过滤器，就要利用filter-mapping元素把它与一个或多个servlet或JSP页面相关联-->\n      <filter-mapping></filter-mapping>\n\n      <!--servlet API的版本2.3增加了对事件监听程序的支持，事件监听程序在建立、修改和删除会话或servlet环境时得到通知。\n          Listener元素指出事件监听程序类-->\n      <listener></listener>\n\n      <!--在向servlet或JSP页面制定初始化参数或定制URL时，必须首先命名servlet或JSP页面。\n          Servlet元素就是用来完成此项任务的-->\n      <servlet></servlet>\n\n      <!--服务器一般为servlet提供一个缺省的URL：http://host/webAppPrefix/servlet/ServletName。\n          但是，常常会更改这个URL，以便servlet可以访问初始化参数或更容易地处理相对URL。\n          在更改缺省URL时，使用servlet-mapping元素-->\n      <servlet-mapping></servlet-mapping>\n\n      <!--如果某个会话在一定时间内未被访问，服务器可以抛弃它以节省内存。可通过使用HttpSession的\n          setMaxInactiveInterval方法明确设置单个会话对象的超时值，或者可利用session-config元素制定缺省超时值-->\n      <session-config></session-config>\n\n      <!--如果Web应用具有想到特殊的文件，希望能保证给他们分配特定的MIME类型，则mime-mapping元素提供这种保证-->\n      <mime-mapping></mime-mapping>\n\n      <!--指示服务器在收到引用一个目录名而不是文件名的URL时，使用哪个文件-->\n      <welcome-file-list></welcome-file-list>\n\n      <!--在返回特定HTTP状态代码时，或者特定类型的异常被抛出时，能够制定将要显示的页面-->\n      <error-page></error-page>\n\n      <!--对标记库描述符文件（Tag Libraryu Descriptor file）指定别名。此功能使你能够更改TLD文件的位置，\n          而不用编辑使用这些文件的JSP页面-->\n      <taglib></taglib>\n\n      <!--声明与资源相关的一个管理对象-->\n      <resource-env-ref></resource-env-ref>\n\n      <!--声明一个资源工厂使用的外部资源-->\n      <resource-ref></resource-ref>\n\n      <!--制定应该保护的URL。它与login-config元素联合使用-->\n      <security-constraint></security-constraint>\n\n      <!--指定服务器应该怎样给试图访问受保护页面的用户授权。它与sercurity-constraint元素联合使用-->\n      <login-config></login-config>\n\n      <!--给出安全角色的一个列表，这些角色将出现在servlet元素内的security-role-ref元素的role-name子元素中。\n          分别地声明角色可使高级IDE处理安全信息更为容易-->\n      <security-role></security-role>\n\n      <!--声明Web应用的环境项-->\n      <env-entry></env-entry>\n\n      <!--声明一个EJB的主目录的引用-->\n      <ejb-ref></ejb-ref>\n\n      <!--声明一个EJB的本地主目录的应用-->\n      <ejb-local-ref></ejb-local-ref>\n\n  </web-app>\n  ```\n二、各个配置文件详解\n 2.1 Web应用名称：提供GUI工具可能会用来标记这个特定应用的一个名称\n<display-name>Tomcat Example</display-name>\n\n\n 2.2 Web应用描述：给出与此应用相关的说明性文本\n<disciption>Tomcat Example servlets and JSP pages.</disciption>\n\n\n2.3上下文参数：生命应用范围内的初始化参数\n<context-param>\n    <param-name>参数名</para-name>\n    <param-value>参数值</param-value>\n    <description>参数描述</description>\n</context-param>\n可以通过sce.getServletContex.getInitParameter(\"参数名\")获得参数的取值，其中sce是一个ServletContexEvent实例，可以在容器开启时执行连接数据库等操作。\n\n2.4过滤器配置：在请求和相应对象在Servlet处理之前或之后，可以通过此此过滤器对两个对象进行处理。\n\n        filter-class 中指定的过滤器类须继承 javax.servlet.Filter 具有须有以下三种方法\n\n                init(FilterConfig filterConfig)：初始化;一般情况下时读取配置文件中的init-param参数值 如 filterConfig.getInitParameter(\"encoding\")\n\n                doFilter(...)：用于对request,response进行处理，并能过chain.doFilter(...) 交过下一个控制器\n\n               destroy()：资源销毁\n\n       例如编码过滤器：\n```\n<filter>\n\t<filter-name>encodingfilter</filter-name>\n\t<filter-class>com.my.app.EncodingFilter</filter-class>\n\t<init-param>\n\t\t<param-name>encoding</param-name>\n\t\t<param-value>UTF-8</param-value>\n\t</init-param>\n</filter>\n<filter-mapping>\n\t<filter-name>encodingfilter</filter-name>\n\t<url-pattern>/*</url-pattern>\n</filter-mapping>\n```\njava代码：\n```\n/**\n*\n*/\npackage com.myapp;\n\nimport java.io.IOException;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n* @author louisliao\n*\n*/\npublic class EncodingFilter implements Filter {\n\n\t/**\n\t* 配置中默认的字符编码\n\t*/\n\tprotected String encoding = null;\n\tprotected FilterConfig filterConfig;\n\t/**\n\t* 当没有指定默认编码时是否允许跳过过滤\n\t*/\n\tprotected boolean ignore = true;\n\t/**\n\t*\n\t*/\n\tpublic EncodingFilter() {\n\t\t// TODO Auto-generated constructor stub\n\t}\n\n\t/* (non-Javadoc)\n\t* @see javax.servlet.Filter#destroy()\n\t*/\n\tpublic void destroy() {\n\t\t// TODO Auto-generated method stub\n\t\tthis.encoding=null;\n\t\tthis.filterConfig=null;\n\t}\n\n\t/* (non-Javadoc)\n\t* @see javax.servlet.Filter#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain)\n\t*/\n\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n\t\t// TODO Auto-generated method stub\n\t\tHttpServletRequest hRequest=(HttpServletRequest)request;\n\t\tHttpServletResponse hResponse=(HttpServletResponse)response;\n\t\t//Conditionally select and set the character encoding to be used\n\t\tif(ignore || hRequest.getCharacterEncoding()==null){\n\t\t\tString coding=selectEncoding(hRequest);\n\t\t\tif(coding!=null){\n\t\t\t\thRequest.setCharacterEncoding(coding);\n\t\t\t\thResponse.setCharacterEncoding(coding);\n\t\t\t}\n\t\t}\n\t\t//将控制器传向下一个filter\n\t\tchain.doFilter(hRequest, hResponse);\n\n\t}\n\n\t/* (non-Javadoc)\n\t* @see javax.servlet.Filter#init(javax.servlet.FilterConfig)\n\t*/\n\tpublic void init(FilterConfig filterConfig) throws ServletException {\n\t\t// TODO Auto-generated method stub\n\t\tthis.filterConfig=filterConfig;\n\t\tthis.encoding=filterConfig.getInitParameter(\"encoding\");\n\t\tSystem.out.println(this.encoding);\n\t\tString value = filterConfig.getInitParameter(\"ignore\");\n\t\tif (value == null) {\n\t\t\tthis.ignore = true;\n\t\t} else if (value.equalsIgnoreCase(\"true\")) {\n\t\t\tthis.ignore = true;\n\t\t} else if (value.equalsIgnoreCase(\"yes\")) {\n\t\t\tthis.ignore = true;\n\t\t} else {\n\t\t\tthis.ignore = false;\n\t\t}\n\t}\n\tprotected String selectEncoding(ServletRequest request) {\n\treturn (this.encoding);\n\t}\n}\n```\ninit方法是在WEB应用启动就会调用,doFilter则是在访问filter-mapping映射到的url时会调用。\n2.5 监听器配置：\nServlet监听器是Servlet规范中定义的一种特殊类，用于监听ServletContext、HttpSession和ServletRequest等域对象的创建与销毁事件，以及监听这些域对象中属性发生修改的事件。\n\n监听对象：\n\n1、ServletContext：application，整个应用只存在一个\n\n2、HttpSession：session，针对每一个对话\n\n3、ServletRequest：request，针对每一个客户请求\n\n监听内容：创建、销毁、属性改变事件\n\n监听作用：可以在事件发生前、发生后进行一些处理，一般可以用来统计在线人数和在线用户、统计网站访问量、系统启动时初始化信息等。\n\n<listener>\n    <listerner-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n</listener>\n监听器的分类：\n\n用于监听应用程序环境对象(ServletContext)的事件监听器，实现ServletContextListener、ServletContextAttributeListener接口\n用于监听用户会话对象(HttpSeesion)的事件监听器，实现HttpSessionListener、HttpSessionAttributeListener接口\n用于监听请求消息对象(ServletRequest)的事件监听器，实现ServletRequestListener、ServletRequestAttributeListener接口\n2.6 Servlet配置：\n<servlet>\n     <servlet-name>servlet名称</servlet-name>\n     <servlet-class>servlet类全路径</servlet-class>\n     <init-param>\n         <param-name>参数名</param-name>\n         <param-value>参数值</param-value>\n     </init-param>\n     <run-as>\n         <description>Security role for anonymous access</description>\n         <role-name>tomcat</role-name>\n     </run-as>\n  　 <load-on-startup>指定当Web应用启动时，装载Servlet的次序</load-on-startup>\n</servlet>\n<servlet-mapping>\n    <servlet-name>servlet名称</servlet-name>\n    <url-pattern>映射路径</url-pattern>\n</servlet-mapping>\n2.7 会话超时配置（单位为分钟）：\n设置session的有效期，单位分钟\n\n<session-config>\n     <session-timeout>120</session-timeout>\n</session-config>\n2.8 Web应用图标：指出IDE和GUI工具用来表示Web应用的大图标和小图标\n <icon>\n      <small-icon>/images/app_small.gif</small-icon>\n      <large-icon>/images/app_large.gif</large-icon>\n</icon>\n\n\n2.9 MIME类型配置：\n<mime-mapping>\n     <extension>htm</extension>\n     <mime-type>text/html</mime-type>\n</mime-mapping>\n\n\n2.10指定欢迎页面配置\n<welcome-file-list>\n     <welcome-file>index.jsp</welcome-file>\n     <welcome-file>index.html</welcome-file>\n     <welcome-file>index.htm</welcome-file>\n</welcome-file-list>\n\n\n2.11配置错误页面\n通过错误码来配置error-page\n\n<!--配置了当系统发生404错误时，跳转到错误处理页面NotFound.jsp-->\n<error-page>\n      <error-code>404</error-code>\n      <location>/NotFound.jsp</location>\n</error-page>\n通过异常类型来配置error-page\n\n<!--配置了当系统发生java.lang.NullException（即空指针异常）时，跳转到错误处理页面error.jsp-->\n<error-page>\n      <exception-type>java.lang.NullException</exception-type>\n      <location>/error.jsp</location>\n</error-page>\n2.12TLD配置：\n<taglib>\n\t<taglib-uri>http://jakarta.apache.org/tomcat/debug-taglib</taglib-uri>\n    <taglib-location>/WEB-INF/jsp/debug-taglib.tld</taglib-location>\n</taglib>\n\n\n2.13资源管理对象配置\n <resource-env-ref>\n      <resource-env-ref-name>jms/StockQueue</resource-env-ref-name>\n </resource-env-ref>\n\n\n2.14资源工厂配置\n <resource-ref>\n      <res-ref-name>mail/Session</res-ref-name>\n      <res-type>javax.mail.Session</res-type>\n      <res-auth>Container</res-auth>\n </resource-ref>\n\n\n2.15安全限制配置\n <security-constraint>\n       <display-name>Example Security Constraint</display-name>\n       <web-resource-collection>\n           <web-resource-name>Protected Area</web-resource-name>\n           <url-pattern>/jsp/security/protected/*</url-pattern>\n           <http-method>DELETE</http-method>\n           <http-method>GET</http-method>\n           <http-method>POST</http-method>\n           <http-method>PUT</http-method>\n       </web-resource-collection>\n       <auth-constraint>\n           <role-name>tomcat</role-name>\n           <role-name>role1</role-name>\n       </auth-constraint>\n </security-constraint>\n\n\n2.16登录验证配置\n<login-config>\n     <auth-method>FORM</auth-method>\n     <realm-name>Example-Based Authentiation Area</realm-name>\n   <form-login-config>\n          <form-login-page>/jsp/security/protected/login.jsp</form-login-page>\n          <form-error-page>/jsp/security/protected/error.jsp</form-error-page>\n     </form-login-config>\n</login-config>\n\n\n2.17安全角色：security-role元素给出安全角色的一个列表，这些角色将出现在servlet元素内的security-role-ref元素的role-name子元素中。\n分别地声明角色可使高级IDE处理安全信息更为容易。\n<security-role>\n     <role-name>tomcat</role-name>\n</security-role>\n\n\n2.18Web环境参数：env-entry元素生命Web应用的环境项\n<env-entry>\n     <env-entry-name>minExemptions</env-entry-name>\n     <env-entry-value>1</env-entry-value>\n     <env-entry-type>java.lang.Integer</env-entry-type>\n</env-entry>\n\n\n2.19EJB声明\n<ejb-ref>\n     <description>Example EJB reference</decription>\n     <ejb-ref-name>ejb/Account</ejb-ref-name>\n     <ejb-ref-type>Entity</ejb-ref-type>\n     <home>com.mycompany.mypackage.AccountHome</home>\n     <remote>com.mycompany.mypackage.Account</remote>\n</ejb-ref>\n\n\n2.20本地EJB声明\n<ejb-local-ref>\n     <description>Example Loacal EJB reference</decription>\n     <ejb-ref-name>ejb/ProcessOrder</ejb-ref-name>\n     <ejb-ref-type>Session</ejb-ref-type>\n     <local-home>com.mycompany.mypackage.ProcessOrderHome</local-home>\n     <local>com.mycompany.mypackage.ProcessOrder</local>\n</ejb-local-ref>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/27web-xml详解.md","raw":"---\ntitle: web.xml详解\ndate: 2017-12-27 16:12:43\ntags:\n---\n一  web.xml常用配置文件元素及其意义概览\n<!--more-->\n```\n <web-app>\n       <!--定义了WEB应用的名字-->\n       <display-name></display-name>\n       <!--声明WEB应用的描述信息-->\n       <description></description>\n\n      <!--context-param元素声明应用范围内的初始化参数-->\n      <context-param></context-param>\n\n      <!--过滤器元素将一个名字与一个实现javax.servlet.Filter接口的类相关联-->\n      <filter></filter>\n\n      <!--一旦命名了一个过滤器，就要利用filter-mapping元素把它与一个或多个servlet或JSP页面相关联-->\n      <filter-mapping></filter-mapping>\n\n      <!--servlet API的版本2.3增加了对事件监听程序的支持，事件监听程序在建立、修改和删除会话或servlet环境时得到通知。\n          Listener元素指出事件监听程序类-->\n      <listener></listener>\n\n      <!--在向servlet或JSP页面制定初始化参数或定制URL时，必须首先命名servlet或JSP页面。\n          Servlet元素就是用来完成此项任务的-->\n      <servlet></servlet>\n\n      <!--服务器一般为servlet提供一个缺省的URL：http://host/webAppPrefix/servlet/ServletName。\n          但是，常常会更改这个URL，以便servlet可以访问初始化参数或更容易地处理相对URL。\n          在更改缺省URL时，使用servlet-mapping元素-->\n      <servlet-mapping></servlet-mapping>\n\n      <!--如果某个会话在一定时间内未被访问，服务器可以抛弃它以节省内存。可通过使用HttpSession的\n          setMaxInactiveInterval方法明确设置单个会话对象的超时值，或者可利用session-config元素制定缺省超时值-->\n      <session-config></session-config>\n\n      <!--如果Web应用具有想到特殊的文件，希望能保证给他们分配特定的MIME类型，则mime-mapping元素提供这种保证-->\n      <mime-mapping></mime-mapping>\n\n      <!--指示服务器在收到引用一个目录名而不是文件名的URL时，使用哪个文件-->\n      <welcome-file-list></welcome-file-list>\n\n      <!--在返回特定HTTP状态代码时，或者特定类型的异常被抛出时，能够制定将要显示的页面-->\n      <error-page></error-page>\n\n      <!--对标记库描述符文件（Tag Libraryu Descriptor file）指定别名。此功能使你能够更改TLD文件的位置，\n          而不用编辑使用这些文件的JSP页面-->\n      <taglib></taglib>\n\n      <!--声明与资源相关的一个管理对象-->\n      <resource-env-ref></resource-env-ref>\n\n      <!--声明一个资源工厂使用的外部资源-->\n      <resource-ref></resource-ref>\n\n      <!--制定应该保护的URL。它与login-config元素联合使用-->\n      <security-constraint></security-constraint>\n\n      <!--指定服务器应该怎样给试图访问受保护页面的用户授权。它与sercurity-constraint元素联合使用-->\n      <login-config></login-config>\n\n      <!--给出安全角色的一个列表，这些角色将出现在servlet元素内的security-role-ref元素的role-name子元素中。\n          分别地声明角色可使高级IDE处理安全信息更为容易-->\n      <security-role></security-role>\n\n      <!--声明Web应用的环境项-->\n      <env-entry></env-entry>\n\n      <!--声明一个EJB的主目录的引用-->\n      <ejb-ref></ejb-ref>\n\n      <!--声明一个EJB的本地主目录的应用-->\n      <ejb-local-ref></ejb-local-ref>\n\n  </web-app>\n  ```\n二、各个配置文件详解\n 2.1 Web应用名称：提供GUI工具可能会用来标记这个特定应用的一个名称\n<display-name>Tomcat Example</display-name>\n\n\n 2.2 Web应用描述：给出与此应用相关的说明性文本\n<disciption>Tomcat Example servlets and JSP pages.</disciption>\n\n\n2.3上下文参数：生命应用范围内的初始化参数\n<context-param>\n    <param-name>参数名</para-name>\n    <param-value>参数值</param-value>\n    <description>参数描述</description>\n</context-param>\n可以通过sce.getServletContex.getInitParameter(\"参数名\")获得参数的取值，其中sce是一个ServletContexEvent实例，可以在容器开启时执行连接数据库等操作。\n\n2.4过滤器配置：在请求和相应对象在Servlet处理之前或之后，可以通过此此过滤器对两个对象进行处理。\n\n        filter-class 中指定的过滤器类须继承 javax.servlet.Filter 具有须有以下三种方法\n\n                init(FilterConfig filterConfig)：初始化;一般情况下时读取配置文件中的init-param参数值 如 filterConfig.getInitParameter(\"encoding\")\n\n                doFilter(...)：用于对request,response进行处理，并能过chain.doFilter(...) 交过下一个控制器\n\n               destroy()：资源销毁\n\n       例如编码过滤器：\n```\n<filter>\n\t<filter-name>encodingfilter</filter-name>\n\t<filter-class>com.my.app.EncodingFilter</filter-class>\n\t<init-param>\n\t\t<param-name>encoding</param-name>\n\t\t<param-value>UTF-8</param-value>\n\t</init-param>\n</filter>\n<filter-mapping>\n\t<filter-name>encodingfilter</filter-name>\n\t<url-pattern>/*</url-pattern>\n</filter-mapping>\n```\njava代码：\n```\n/**\n*\n*/\npackage com.myapp;\n\nimport java.io.IOException;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n* @author louisliao\n*\n*/\npublic class EncodingFilter implements Filter {\n\n\t/**\n\t* 配置中默认的字符编码\n\t*/\n\tprotected String encoding = null;\n\tprotected FilterConfig filterConfig;\n\t/**\n\t* 当没有指定默认编码时是否允许跳过过滤\n\t*/\n\tprotected boolean ignore = true;\n\t/**\n\t*\n\t*/\n\tpublic EncodingFilter() {\n\t\t// TODO Auto-generated constructor stub\n\t}\n\n\t/* (non-Javadoc)\n\t* @see javax.servlet.Filter#destroy()\n\t*/\n\tpublic void destroy() {\n\t\t// TODO Auto-generated method stub\n\t\tthis.encoding=null;\n\t\tthis.filterConfig=null;\n\t}\n\n\t/* (non-Javadoc)\n\t* @see javax.servlet.Filter#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain)\n\t*/\n\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n\t\t// TODO Auto-generated method stub\n\t\tHttpServletRequest hRequest=(HttpServletRequest)request;\n\t\tHttpServletResponse hResponse=(HttpServletResponse)response;\n\t\t//Conditionally select and set the character encoding to be used\n\t\tif(ignore || hRequest.getCharacterEncoding()==null){\n\t\t\tString coding=selectEncoding(hRequest);\n\t\t\tif(coding!=null){\n\t\t\t\thRequest.setCharacterEncoding(coding);\n\t\t\t\thResponse.setCharacterEncoding(coding);\n\t\t\t}\n\t\t}\n\t\t//将控制器传向下一个filter\n\t\tchain.doFilter(hRequest, hResponse);\n\n\t}\n\n\t/* (non-Javadoc)\n\t* @see javax.servlet.Filter#init(javax.servlet.FilterConfig)\n\t*/\n\tpublic void init(FilterConfig filterConfig) throws ServletException {\n\t\t// TODO Auto-generated method stub\n\t\tthis.filterConfig=filterConfig;\n\t\tthis.encoding=filterConfig.getInitParameter(\"encoding\");\n\t\tSystem.out.println(this.encoding);\n\t\tString value = filterConfig.getInitParameter(\"ignore\");\n\t\tif (value == null) {\n\t\t\tthis.ignore = true;\n\t\t} else if (value.equalsIgnoreCase(\"true\")) {\n\t\t\tthis.ignore = true;\n\t\t} else if (value.equalsIgnoreCase(\"yes\")) {\n\t\t\tthis.ignore = true;\n\t\t} else {\n\t\t\tthis.ignore = false;\n\t\t}\n\t}\n\tprotected String selectEncoding(ServletRequest request) {\n\treturn (this.encoding);\n\t}\n}\n```\ninit方法是在WEB应用启动就会调用,doFilter则是在访问filter-mapping映射到的url时会调用。\n2.5 监听器配置：\nServlet监听器是Servlet规范中定义的一种特殊类，用于监听ServletContext、HttpSession和ServletRequest等域对象的创建与销毁事件，以及监听这些域对象中属性发生修改的事件。\n\n监听对象：\n\n1、ServletContext：application，整个应用只存在一个\n\n2、HttpSession：session，针对每一个对话\n\n3、ServletRequest：request，针对每一个客户请求\n\n监听内容：创建、销毁、属性改变事件\n\n监听作用：可以在事件发生前、发生后进行一些处理，一般可以用来统计在线人数和在线用户、统计网站访问量、系统启动时初始化信息等。\n\n<listener>\n    <listerner-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n</listener>\n监听器的分类：\n\n用于监听应用程序环境对象(ServletContext)的事件监听器，实现ServletContextListener、ServletContextAttributeListener接口\n用于监听用户会话对象(HttpSeesion)的事件监听器，实现HttpSessionListener、HttpSessionAttributeListener接口\n用于监听请求消息对象(ServletRequest)的事件监听器，实现ServletRequestListener、ServletRequestAttributeListener接口\n2.6 Servlet配置：\n<servlet>\n     <servlet-name>servlet名称</servlet-name>\n     <servlet-class>servlet类全路径</servlet-class>\n     <init-param>\n         <param-name>参数名</param-name>\n         <param-value>参数值</param-value>\n     </init-param>\n     <run-as>\n         <description>Security role for anonymous access</description>\n         <role-name>tomcat</role-name>\n     </run-as>\n  　 <load-on-startup>指定当Web应用启动时，装载Servlet的次序</load-on-startup>\n</servlet>\n<servlet-mapping>\n    <servlet-name>servlet名称</servlet-name>\n    <url-pattern>映射路径</url-pattern>\n</servlet-mapping>\n2.7 会话超时配置（单位为分钟）：\n设置session的有效期，单位分钟\n\n<session-config>\n     <session-timeout>120</session-timeout>\n</session-config>\n2.8 Web应用图标：指出IDE和GUI工具用来表示Web应用的大图标和小图标\n <icon>\n      <small-icon>/images/app_small.gif</small-icon>\n      <large-icon>/images/app_large.gif</large-icon>\n</icon>\n\n\n2.9 MIME类型配置：\n<mime-mapping>\n     <extension>htm</extension>\n     <mime-type>text/html</mime-type>\n</mime-mapping>\n\n\n2.10指定欢迎页面配置\n<welcome-file-list>\n     <welcome-file>index.jsp</welcome-file>\n     <welcome-file>index.html</welcome-file>\n     <welcome-file>index.htm</welcome-file>\n</welcome-file-list>\n\n\n2.11配置错误页面\n通过错误码来配置error-page\n\n<!--配置了当系统发生404错误时，跳转到错误处理页面NotFound.jsp-->\n<error-page>\n      <error-code>404</error-code>\n      <location>/NotFound.jsp</location>\n</error-page>\n通过异常类型来配置error-page\n\n<!--配置了当系统发生java.lang.NullException（即空指针异常）时，跳转到错误处理页面error.jsp-->\n<error-page>\n      <exception-type>java.lang.NullException</exception-type>\n      <location>/error.jsp</location>\n</error-page>\n2.12TLD配置：\n<taglib>\n\t<taglib-uri>http://jakarta.apache.org/tomcat/debug-taglib</taglib-uri>\n    <taglib-location>/WEB-INF/jsp/debug-taglib.tld</taglib-location>\n</taglib>\n\n\n2.13资源管理对象配置\n <resource-env-ref>\n      <resource-env-ref-name>jms/StockQueue</resource-env-ref-name>\n </resource-env-ref>\n\n\n2.14资源工厂配置\n <resource-ref>\n      <res-ref-name>mail/Session</res-ref-name>\n      <res-type>javax.mail.Session</res-type>\n      <res-auth>Container</res-auth>\n </resource-ref>\n\n\n2.15安全限制配置\n <security-constraint>\n       <display-name>Example Security Constraint</display-name>\n       <web-resource-collection>\n           <web-resource-name>Protected Area</web-resource-name>\n           <url-pattern>/jsp/security/protected/*</url-pattern>\n           <http-method>DELETE</http-method>\n           <http-method>GET</http-method>\n           <http-method>POST</http-method>\n           <http-method>PUT</http-method>\n       </web-resource-collection>\n       <auth-constraint>\n           <role-name>tomcat</role-name>\n           <role-name>role1</role-name>\n       </auth-constraint>\n </security-constraint>\n\n\n2.16登录验证配置\n<login-config>\n     <auth-method>FORM</auth-method>\n     <realm-name>Example-Based Authentiation Area</realm-name>\n   <form-login-config>\n          <form-login-page>/jsp/security/protected/login.jsp</form-login-page>\n          <form-error-page>/jsp/security/protected/error.jsp</form-error-page>\n     </form-login-config>\n</login-config>\n\n\n2.17安全角色：security-role元素给出安全角色的一个列表，这些角色将出现在servlet元素内的security-role-ref元素的role-name子元素中。\n分别地声明角色可使高级IDE处理安全信息更为容易。\n<security-role>\n     <role-name>tomcat</role-name>\n</security-role>\n\n\n2.18Web环境参数：env-entry元素生命Web应用的环境项\n<env-entry>\n     <env-entry-name>minExemptions</env-entry-name>\n     <env-entry-value>1</env-entry-value>\n     <env-entry-type>java.lang.Integer</env-entry-type>\n</env-entry>\n\n\n2.19EJB声明\n<ejb-ref>\n     <description>Example EJB reference</decription>\n     <ejb-ref-name>ejb/Account</ejb-ref-name>\n     <ejb-ref-type>Entity</ejb-ref-type>\n     <home>com.mycompany.mypackage.AccountHome</home>\n     <remote>com.mycompany.mypackage.Account</remote>\n</ejb-ref>\n\n\n2.20本地EJB声明\n<ejb-local-ref>\n     <description>Example Loacal EJB reference</decription>\n     <ejb-ref-name>ejb/ProcessOrder</ejb-ref-name>\n     <ejb-ref-type>Session</ejb-ref-type>\n     <local-home>com.mycompany.mypackage.ProcessOrderHome</local-home>\n     <local>com.mycompany.mypackage.ProcessOrder</local>\n</ejb-local-ref>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"27web-xml详解","published":1,"updated":"2018-01-16T03:35:05.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tcae001fa7xwo1gujz2s","content":"<p>一  web.xml常用配置文件元素及其意义概览<br><a id=\"more\"></a><br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!--定义了WEB应用的名字--&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">display-name</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">display-name</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!--声明WEB应用的描述信息--&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--context-param元素声明应用范围内的初始化参数--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--过滤器元素将一个名字与一个实现javax.servlet.Filter接口的类相关联--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--一旦命名了一个过滤器，就要利用filter-mapping元素把它与一个或多个servlet或JSP页面相关联--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--servlet API的版本2.3增加了对事件监听程序的支持，事件监听程序在建立、修改和删除会话或servlet环境时得到通知。</span></div><div class=\"line\">         Listener元素指出事件监听程序类--&gt;</div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--在向servlet或JSP页面制定初始化参数或定制URL时，必须首先命名servlet或JSP页面。</span></div><div class=\"line\">         Servlet元素就是用来完成此项任务的--&gt;</div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--服务器一般为servlet提供一个缺省的URL：http://host/webAppPrefix/servlet/ServletName。</span></div><div class=\"line\">         但是，常常会更改这个URL，以便servlet可以访问初始化参数或更容易地处理相对URL。</div><div class=\"line\">         在更改缺省URL时，使用servlet-mapping元素--&gt;</div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--如果某个会话在一定时间内未被访问，服务器可以抛弃它以节省内存。可通过使用HttpSession的</span></div><div class=\"line\">         setMaxInactiveInterval方法明确设置单个会话对象的超时值，或者可利用session-config元素制定缺省超时值--&gt;</div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">session-config</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">session-config</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--如果Web应用具有想到特殊的文件，希望能保证给他们分配特定的MIME类型，则mime-mapping元素提供这种保证--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">mime-mapping</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">mime-mapping</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--指示服务器在收到引用一个目录名而不是文件名的URL时，使用哪个文件--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">welcome-file-list</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">welcome-file-list</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--在返回特定HTTP状态代码时，或者特定类型的异常被抛出时，能够制定将要显示的页面--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">error-page</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">error-page</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--对标记库描述符文件（Tag Libraryu Descriptor file）指定别名。此功能使你能够更改TLD文件的位置，</span></div><div class=\"line\">         而不用编辑使用这些文件的JSP页面--&gt;</div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">taglib</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">taglib</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--声明与资源相关的一个管理对象--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">resource-env-ref</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">resource-env-ref</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--声明一个资源工厂使用的外部资源--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">resource-ref</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">resource-ref</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--制定应该保护的URL。它与login-config元素联合使用--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">security-constraint</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">security-constraint</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--指定服务器应该怎样给试图访问受保护页面的用户授权。它与sercurity-constraint元素联合使用--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">login-config</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">login-config</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--给出安全角色的一个列表，这些角色将出现在servlet元素内的security-role-ref元素的role-name子元素中。</span></div><div class=\"line\">         分别地声明角色可使高级IDE处理安全信息更为容易--&gt;</div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">security-role</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">security-role</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--声明Web应用的环境项--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">env-entry</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">env-entry</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--声明一个EJB的主目录的引用--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">ejb-ref</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ejb-ref</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--声明一个EJB的本地主目录的应用--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">ejb-local-ref</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ejb-local-ref</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>二、各个配置文件详解<br> 2.1 Web应用名称：提供GUI工具可能会用来标记这个特定应用的一个名称</p>\n<p><display-name>Tomcat Example</display-name></p>\n<p> 2.2 Web应用描述：给出与此应用相关的说明性文本</p>\n<disciption>Tomcat Example servlets and JSP pages.</disciption>\n\n\n<p>2.3上下文参数：生命应用范围内的初始化参数</p>\n<p><context-param><br>    <param-name>参数名<br>    <param-value>参数值</param-value><br>    <description>参数描述</description><br></param-name></context-param><br>可以通过sce.getServletContex.getInitParameter(“参数名”)获得参数的取值，其中sce是一个ServletContexEvent实例，可以在容器开启时执行连接数据库等操作。</p>\n<p>2.4过滤器配置：在请求和相应对象在Servlet处理之前或之后，可以通过此此过滤器对两个对象进行处理。</p>\n<pre><code> filter-class 中指定的过滤器类须继承 javax.servlet.Filter 具有须有以下三种方法\n\n         init(FilterConfig filterConfig)：初始化;一般情况下时读取配置文件中的init-param参数值 如 filterConfig.getInitParameter(&quot;encoding&quot;)\n\n         doFilter(...)：用于对request,response进行处理，并能过chain.doFilter(...) 交过下一个控制器\n\n        destroy()：资源销毁\n\n例如编码过滤器：\n</code></pre><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>encodingfilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>com.my.app.EncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>encoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>encodingfilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>java代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">*</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"keyword\">package</span> com.myapp;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> javax.servlet.Filter;</div><div class=\"line\"><span class=\"keyword\">import</span> javax.servlet.FilterChain;</div><div class=\"line\"><span class=\"keyword\">import</span> javax.servlet.FilterConfig;</div><div class=\"line\"><span class=\"keyword\">import</span> javax.servlet.ServletException;</div><div class=\"line\"><span class=\"keyword\">import</span> javax.servlet.ServletRequest;</div><div class=\"line\"><span class=\"keyword\">import</span> javax.servlet.ServletResponse;</div><div class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</div><div class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* <span class=\"doctag\">@author</span> louisliao</div><div class=\"line\">*</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EncodingFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Filter</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/**</span></div><div class=\"line\">\t* 配置中默认的字符编码</div><div class=\"line\">\t*/</div><div class=\"line\">\t<span class=\"keyword\">protected</span> String encoding = <span class=\"keyword\">null</span>;</div><div class=\"line\">\t<span class=\"keyword\">protected</span> FilterConfig filterConfig;</div><div class=\"line\">\t<span class=\"comment\">/**</span></div><div class=\"line\">\t* 当没有指定默认编码时是否允许跳过过滤</div><div class=\"line\">\t*/</div><div class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> ignore = <span class=\"keyword\">true</span>;</div><div class=\"line\">\t<span class=\"comment\">/**</span></div><div class=\"line\">\t*</div><div class=\"line\">\t*/</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EncodingFilter</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated constructor stub</span></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/* (non-Javadoc)</span></div><div class=\"line\">\t* @see javax.servlet.Filter#destroy()</div><div class=\"line\">\t*/</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.encoding=<span class=\"keyword\">null</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.filterConfig=<span class=\"keyword\">null</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/* (non-Javadoc)</span></div><div class=\"line\">\t* @see javax.servlet.Filter#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain)</div><div class=\"line\">\t*/</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilter</span><span class=\"params\">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">\t\tHttpServletRequest hRequest=(HttpServletRequest)request;</div><div class=\"line\">\t\tHttpServletResponse hResponse=(HttpServletResponse)response;</div><div class=\"line\">\t\t<span class=\"comment\">//Conditionally select and set the character encoding to be used</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(ignore || hRequest.getCharacterEncoding()==<span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">\t\t\tString coding=selectEncoding(hRequest);</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(coding!=<span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">\t\t\t\thRequest.setCharacterEncoding(coding);</div><div class=\"line\">\t\t\t\thResponse.setCharacterEncoding(coding);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"comment\">//将控制器传向下一个filter</span></div><div class=\"line\">\t\tchain.doFilter(hRequest, hResponse);</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/* (non-Javadoc)</span></div><div class=\"line\">\t* @see javax.servlet.Filter#init(javax.servlet.FilterConfig)</div><div class=\"line\">\t*/</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(FilterConfig filterConfig)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.filterConfig=filterConfig;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.encoding=filterConfig.getInitParameter(<span class=\"string\">\"encoding\"</span>);</div><div class=\"line\">\t\tSystem.out.println(<span class=\"keyword\">this</span>.encoding);</div><div class=\"line\">\t\tString value = filterConfig.getInitParameter(<span class=\"string\">\"ignore\"</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.ignore = <span class=\"keyword\">true</span>;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.equalsIgnoreCase(<span class=\"string\">\"true\"</span>)) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.ignore = <span class=\"keyword\">true</span>;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.equalsIgnoreCase(<span class=\"string\">\"yes\"</span>)) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.ignore = <span class=\"keyword\">true</span>;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.ignore = <span class=\"keyword\">false</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> String <span class=\"title\">selectEncoding</span><span class=\"params\">(ServletRequest request)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"keyword\">this</span>.encoding);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>init方法是在WEB应用启动就会调用,doFilter则是在访问filter-mapping映射到的url时会调用。<br>2.5 监听器配置：<br>Servlet监听器是Servlet规范中定义的一种特殊类，用于监听ServletContext、HttpSession和ServletRequest等域对象的创建与销毁事件，以及监听这些域对象中属性发生修改的事件。</p>\n<p>监听对象：</p>\n<p>1、ServletContext：application，整个应用只存在一个</p>\n<p>2、HttpSession：session，针对每一个对话</p>\n<p>3、ServletRequest：request，针对每一个客户请求</p>\n<p>监听内容：创建、销毁、属性改变事件</p>\n<p>监听作用：可以在事件发生前、发生后进行一些处理，一般可以用来统计在线人数和在线用户、统计网站访问量、系统启动时初始化信息等。</p>\n<p><listener><br>    <listerner-class>org.springframework.web.context.ContextLoaderListener<br></listerner-class></listener><br>监听器的分类：</p>\n<p>用于监听应用程序环境对象(ServletContext)的事件监听器，实现ServletContextListener、ServletContextAttributeListener接口<br>用于监听用户会话对象(HttpSeesion)的事件监听器，实现HttpSessionListener、HttpSessionAttributeListener接口<br>用于监听请求消息对象(ServletRequest)的事件监听器，实现ServletRequestListener、ServletRequestAttributeListener接口<br>2.6 Servlet配置：</p>\n<p><servlet><br>     <servlet-name>servlet名称</servlet-name><br>     <servlet-class>servlet类全路径</servlet-class><br>     <init-param><br>         <param-name>参数名</param-name><br>         <param-value>参数值</param-value><br>     </init-param><br>     <run-as><br>         <description>Security role for anonymous access</description><br>         <role-name>tomcat</role-name><br>     </run-as><br>  　 <load-on-startup>指定当Web应用启动时，装载Servlet的次序</load-on-startup><br></servlet></p>\n<p><servlet-mapping><br>    <servlet-name>servlet名称</servlet-name><br>    <url-pattern>映射路径</url-pattern><br></servlet-mapping><br>2.7 会话超时配置（单位为分钟）：<br>设置session的有效期，单位分钟</p>\n<p><session-config><br>     <session-timeout>120</session-timeout><br></session-config><br>2.8 Web应用图标：指出IDE和GUI工具用来表示Web应用的大图标和小图标<br> <icon><br>      <small-icon>/images/app_small.gif</small-icon><br>      <large-icon>/images/app_large.gif</large-icon><br></icon></p>\n<p>2.9 MIME类型配置：</p>\n<p><mime-mapping><br>     <extension>htm</extension><br>     <mime-type>text/html</mime-type><br></mime-mapping></p>\n<p>2.10指定欢迎页面配置</p>\n<p><welcome-file-list><br>     <welcome-file>index.jsp</welcome-file><br>     <welcome-file>index.html</welcome-file><br>     <welcome-file>index.htm</welcome-file><br></welcome-file-list></p>\n<p>2.11配置错误页面<br>通过错误码来配置error-page</p>\n<!--配置了当系统发生404错误时，跳转到错误处理页面NotFound.jsp-->\n<p><error-page><br>      <error-code>404</error-code><br>      <location>/NotFound.jsp</location><br></error-page><br>通过异常类型来配置error-page</p>\n<!--配置了当系统发生java.lang.NullException（即空指针异常）时，跳转到错误处理页面error.jsp-->\n<p><error-page><br>      <exception-type>java.lang.NullException</exception-type><br>      <location>/error.jsp</location><br></error-page><br>2.12TLD配置：</p>\n<taglib><br>    <taglib-uri><a href=\"http://jakarta.apache.org/tomcat/debug-taglib\" target=\"_blank\" rel=\"external\">http://jakarta.apache.org/tomcat/debug-taglib</a></taglib-uri><br>    <taglib-location>/WEB-INF/jsp/debug-taglib.tld</taglib-location><br></taglib>\n\n\n<p>2.13资源管理对象配置<br> <resource-env-ref><br>      <resource-env-ref-name>jms/StockQueue</resource-env-ref-name><br> </resource-env-ref></p>\n<p>2.14资源工厂配置<br> <resource-ref><br>      <res-ref-name>mail/Session</res-ref-name><br>      <res-type>javax.mail.Session</res-type><br>      <res-auth>Container</res-auth><br> </resource-ref></p>\n<p>2.15安全限制配置<br> <security-constraint><br>       <display-name>Example Security Constraint</display-name><br>       <web-resource-collection><br>           <web-resource-name>Protected Area</web-resource-name><br>           <url-pattern>/jsp/security/protected/*</url-pattern><br>           <http-method>DELETE</http-method><br>           <http-method>GET</http-method><br>           <http-method>POST</http-method><br>           <http-method>PUT</http-method><br>       </web-resource-collection><br>       <auth-constraint><br>           <role-name>tomcat</role-name><br>           <role-name>role1</role-name><br>       </auth-constraint><br> </security-constraint></p>\n<p>2.16登录验证配置</p>\n<p><login-config><br>     <auth-method>FORM</auth-method><br>     <realm-name>Example-Based Authentiation Area</realm-name><br>   <form-login-config><br>          <form-login-page>/jsp/security/protected/login.jsp</form-login-page><br>          <form-error-page>/jsp/security/protected/error.jsp</form-error-page><br>     </form-login-config><br></login-config></p>\n<p>2.17安全角色：security-role元素给出安全角色的一个列表，这些角色将出现在servlet元素内的security-role-ref元素的role-name子元素中。<br>分别地声明角色可使高级IDE处理安全信息更为容易。</p>\n<p><security-role><br>     <role-name>tomcat</role-name><br></security-role></p>\n<p>2.18Web环境参数：env-entry元素生命Web应用的环境项</p>\n<p><env-entry><br>     <env-entry-name>minExemptions</env-entry-name><br>     <env-entry-value>1</env-entry-value><br>     <env-entry-type>java.lang.Integer</env-entry-type><br></env-entry></p>\n<p>2.19EJB声明</p>\n<p><ejb-ref><br>     <description>Example EJB reference<br>     <ejb-ref-name>ejb/Account</ejb-ref-name><br>     <ejb-ref-type>Entity</ejb-ref-type><br>     <home>com.mycompany.mypackage.AccountHome</home><br>     <remote>com.mycompany.mypackage.Account</remote><br></description></ejb-ref></p>\n<p>2.20本地EJB声明</p>\n<p><ejb-local-ref><br>     <description>Example Loacal EJB reference<br>     <ejb-ref-name>ejb/ProcessOrder</ejb-ref-name><br>     <ejb-ref-type>Session</ejb-ref-type><br>     <local-home>com.mycompany.mypackage.ProcessOrderHome</local-home><br>     <local>com.mycompany.mypackage.ProcessOrder</local><br></description></ejb-local-ref></p>\n","excerpt":"<p>一  web.xml常用配置文件元素及其意义概览<br></p>","more":"<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!--定义了WEB应用的名字--&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">display-name</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">display-name</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!--声明WEB应用的描述信息--&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--context-param元素声明应用范围内的初始化参数--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--过滤器元素将一个名字与一个实现javax.servlet.Filter接口的类相关联--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--一旦命名了一个过滤器，就要利用filter-mapping元素把它与一个或多个servlet或JSP页面相关联--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--servlet API的版本2.3增加了对事件监听程序的支持，事件监听程序在建立、修改和删除会话或servlet环境时得到通知。</span></div><div class=\"line\">         Listener元素指出事件监听程序类--&gt;</div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--在向servlet或JSP页面制定初始化参数或定制URL时，必须首先命名servlet或JSP页面。</span></div><div class=\"line\">         Servlet元素就是用来完成此项任务的--&gt;</div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--服务器一般为servlet提供一个缺省的URL：http://host/webAppPrefix/servlet/ServletName。</span></div><div class=\"line\">         但是，常常会更改这个URL，以便servlet可以访问初始化参数或更容易地处理相对URL。</div><div class=\"line\">         在更改缺省URL时，使用servlet-mapping元素--&gt;</div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--如果某个会话在一定时间内未被访问，服务器可以抛弃它以节省内存。可通过使用HttpSession的</span></div><div class=\"line\">         setMaxInactiveInterval方法明确设置单个会话对象的超时值，或者可利用session-config元素制定缺省超时值--&gt;</div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">session-config</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">session-config</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--如果Web应用具有想到特殊的文件，希望能保证给他们分配特定的MIME类型，则mime-mapping元素提供这种保证--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">mime-mapping</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">mime-mapping</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--指示服务器在收到引用一个目录名而不是文件名的URL时，使用哪个文件--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">welcome-file-list</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">welcome-file-list</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--在返回特定HTTP状态代码时，或者特定类型的异常被抛出时，能够制定将要显示的页面--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">error-page</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">error-page</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--对标记库描述符文件（Tag Libraryu Descriptor file）指定别名。此功能使你能够更改TLD文件的位置，</span></div><div class=\"line\">         而不用编辑使用这些文件的JSP页面--&gt;</div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">taglib</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">taglib</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--声明与资源相关的一个管理对象--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">resource-env-ref</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">resource-env-ref</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--声明一个资源工厂使用的外部资源--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">resource-ref</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">resource-ref</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--制定应该保护的URL。它与login-config元素联合使用--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">security-constraint</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">security-constraint</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--指定服务器应该怎样给试图访问受保护页面的用户授权。它与sercurity-constraint元素联合使用--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">login-config</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">login-config</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--给出安全角色的一个列表，这些角色将出现在servlet元素内的security-role-ref元素的role-name子元素中。</span></div><div class=\"line\">         分别地声明角色可使高级IDE处理安全信息更为容易--&gt;</div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">security-role</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">security-role</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--声明Web应用的环境项--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">env-entry</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">env-entry</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--声明一个EJB的主目录的引用--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">ejb-ref</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ejb-ref</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">&lt;!--声明一个EJB的本地主目录的应用--&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">ejb-local-ref</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ejb-local-ref</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></div></pre></td></tr></table></figure><p></p>\n<p>二、各个配置文件详解<br> 2.1 Web应用名称：提供GUI工具可能会用来标记这个特定应用的一个名称</p>\n<p><display-name>Tomcat Example</display-name></p>\n<p> 2.2 Web应用描述：给出与此应用相关的说明性文本</p>\n<disciption>Tomcat Example servlets and JSP pages.</disciption>\n\n\n<p>2.3上下文参数：生命应用范围内的初始化参数</p>\n<p><context-param><br>    <param-name>参数名<br>    <param-value>参数值</param-value><br>    <description>参数描述</description><br></param-name></context-param><br>可以通过sce.getServletContex.getInitParameter(“参数名”)获得参数的取值，其中sce是一个ServletContexEvent实例，可以在容器开启时执行连接数据库等操作。</p>\n<p>2.4过滤器配置：在请求和相应对象在Servlet处理之前或之后，可以通过此此过滤器对两个对象进行处理。</p>\n<pre><code> filter-class 中指定的过滤器类须继承 javax.servlet.Filter 具有须有以下三种方法\n\n         init(FilterConfig filterConfig)：初始化;一般情况下时读取配置文件中的init-param参数值 如 filterConfig.getInitParameter(&quot;encoding&quot;)\n\n         doFilter(...)：用于对request,response进行处理，并能过chain.doFilter(...) 交过下一个控制器\n\n        destroy()：资源销毁\n\n例如编码过滤器：\n</code></pre><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>encodingfilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>com.my.app.EncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>encoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>encodingfilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>java代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">*</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"keyword\">package</span> com.myapp;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> javax.servlet.Filter;</div><div class=\"line\"><span class=\"keyword\">import</span> javax.servlet.FilterChain;</div><div class=\"line\"><span class=\"keyword\">import</span> javax.servlet.FilterConfig;</div><div class=\"line\"><span class=\"keyword\">import</span> javax.servlet.ServletException;</div><div class=\"line\"><span class=\"keyword\">import</span> javax.servlet.ServletRequest;</div><div class=\"line\"><span class=\"keyword\">import</span> javax.servlet.ServletResponse;</div><div class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</div><div class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* <span class=\"doctag\">@author</span> louisliao</div><div class=\"line\">*</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EncodingFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Filter</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/**</span></div><div class=\"line\">\t* 配置中默认的字符编码</div><div class=\"line\">\t*/</div><div class=\"line\">\t<span class=\"keyword\">protected</span> String encoding = <span class=\"keyword\">null</span>;</div><div class=\"line\">\t<span class=\"keyword\">protected</span> FilterConfig filterConfig;</div><div class=\"line\">\t<span class=\"comment\">/**</span></div><div class=\"line\">\t* 当没有指定默认编码时是否允许跳过过滤</div><div class=\"line\">\t*/</div><div class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> ignore = <span class=\"keyword\">true</span>;</div><div class=\"line\">\t<span class=\"comment\">/**</span></div><div class=\"line\">\t*</div><div class=\"line\">\t*/</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EncodingFilter</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated constructor stub</span></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/* (non-Javadoc)</span></div><div class=\"line\">\t* @see javax.servlet.Filter#destroy()</div><div class=\"line\">\t*/</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.encoding=<span class=\"keyword\">null</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.filterConfig=<span class=\"keyword\">null</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/* (non-Javadoc)</span></div><div class=\"line\">\t* @see javax.servlet.Filter#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain)</div><div class=\"line\">\t*/</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilter</span><span class=\"params\">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">\t\tHttpServletRequest hRequest=(HttpServletRequest)request;</div><div class=\"line\">\t\tHttpServletResponse hResponse=(HttpServletResponse)response;</div><div class=\"line\">\t\t<span class=\"comment\">//Conditionally select and set the character encoding to be used</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(ignore || hRequest.getCharacterEncoding()==<span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">\t\t\tString coding=selectEncoding(hRequest);</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(coding!=<span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">\t\t\t\thRequest.setCharacterEncoding(coding);</div><div class=\"line\">\t\t\t\thResponse.setCharacterEncoding(coding);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"comment\">//将控制器传向下一个filter</span></div><div class=\"line\">\t\tchain.doFilter(hRequest, hResponse);</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/* (non-Javadoc)</span></div><div class=\"line\">\t* @see javax.servlet.Filter#init(javax.servlet.FilterConfig)</div><div class=\"line\">\t*/</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(FilterConfig filterConfig)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.filterConfig=filterConfig;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.encoding=filterConfig.getInitParameter(<span class=\"string\">\"encoding\"</span>);</div><div class=\"line\">\t\tSystem.out.println(<span class=\"keyword\">this</span>.encoding);</div><div class=\"line\">\t\tString value = filterConfig.getInitParameter(<span class=\"string\">\"ignore\"</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.ignore = <span class=\"keyword\">true</span>;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.equalsIgnoreCase(<span class=\"string\">\"true\"</span>)) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.ignore = <span class=\"keyword\">true</span>;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.equalsIgnoreCase(<span class=\"string\">\"yes\"</span>)) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.ignore = <span class=\"keyword\">true</span>;</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.ignore = <span class=\"keyword\">false</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> String <span class=\"title\">selectEncoding</span><span class=\"params\">(ServletRequest request)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"keyword\">this</span>.encoding);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>init方法是在WEB应用启动就会调用,doFilter则是在访问filter-mapping映射到的url时会调用。<br>2.5 监听器配置：<br>Servlet监听器是Servlet规范中定义的一种特殊类，用于监听ServletContext、HttpSession和ServletRequest等域对象的创建与销毁事件，以及监听这些域对象中属性发生修改的事件。</p>\n<p>监听对象：</p>\n<p>1、ServletContext：application，整个应用只存在一个</p>\n<p>2、HttpSession：session，针对每一个对话</p>\n<p>3、ServletRequest：request，针对每一个客户请求</p>\n<p>监听内容：创建、销毁、属性改变事件</p>\n<p>监听作用：可以在事件发生前、发生后进行一些处理，一般可以用来统计在线人数和在线用户、统计网站访问量、系统启动时初始化信息等。</p>\n<p><listener><br>    <listerner-class>org.springframework.web.context.ContextLoaderListener<br></listerner-class></listener><br>监听器的分类：</p>\n<p>用于监听应用程序环境对象(ServletContext)的事件监听器，实现ServletContextListener、ServletContextAttributeListener接口<br>用于监听用户会话对象(HttpSeesion)的事件监听器，实现HttpSessionListener、HttpSessionAttributeListener接口<br>用于监听请求消息对象(ServletRequest)的事件监听器，实现ServletRequestListener、ServletRequestAttributeListener接口<br>2.6 Servlet配置：</p>\n<p><servlet><br>     <servlet-name>servlet名称</servlet-name><br>     <servlet-class>servlet类全路径</servlet-class><br>     <init-param><br>         <param-name>参数名</param-name><br>         <param-value>参数值</param-value><br>     </init-param><br>     <run-as><br>         <description>Security role for anonymous access</description><br>         <role-name>tomcat</role-name><br>     </run-as><br>  　 <load-on-startup>指定当Web应用启动时，装载Servlet的次序</load-on-startup><br></servlet></p>\n<p><servlet-mapping><br>    <servlet-name>servlet名称</servlet-name><br>    <url-pattern>映射路径</url-pattern><br></servlet-mapping><br>2.7 会话超时配置（单位为分钟）：<br>设置session的有效期，单位分钟</p>\n<p><session-config><br>     <session-timeout>120</session-timeout><br></session-config><br>2.8 Web应用图标：指出IDE和GUI工具用来表示Web应用的大图标和小图标<br> <icon><br>      <small-icon>/images/app_small.gif</small-icon><br>      <large-icon>/images/app_large.gif</large-icon><br></icon></p>\n<p>2.9 MIME类型配置：</p>\n<p><mime-mapping><br>     <extension>htm</extension><br>     <mime-type>text/html</mime-type><br></mime-mapping></p>\n<p>2.10指定欢迎页面配置</p>\n<p><welcome-file-list><br>     <welcome-file>index.jsp</welcome-file><br>     <welcome-file>index.html</welcome-file><br>     <welcome-file>index.htm</welcome-file><br></welcome-file-list></p>\n<p>2.11配置错误页面<br>通过错误码来配置error-page</p>\n<!--配置了当系统发生404错误时，跳转到错误处理页面NotFound.jsp-->\n<p><error-page><br>      <error-code>404</error-code><br>      <location>/NotFound.jsp</location><br></error-page><br>通过异常类型来配置error-page</p>\n<!--配置了当系统发生java.lang.NullException（即空指针异常）时，跳转到错误处理页面error.jsp-->\n<p><error-page><br>      <exception-type>java.lang.NullException</exception-type><br>      <location>/error.jsp</location><br></error-page><br>2.12TLD配置：</p>\n<taglib><br>    <taglib-uri><a href=\"http://jakarta.apache.org/tomcat/debug-taglib\">http://jakarta.apache.org/tomcat/debug-taglib</a></taglib-uri><br>    <taglib-location>/WEB-INF/jsp/debug-taglib.tld</taglib-location><br></taglib>\n\n\n<p>2.13资源管理对象配置<br> <resource-env-ref><br>      <resource-env-ref-name>jms/StockQueue</resource-env-ref-name><br> </resource-env-ref></p>\n<p>2.14资源工厂配置<br> <resource-ref><br>      <res-ref-name>mail/Session</res-ref-name><br>      <res-type>javax.mail.Session</res-type><br>      <res-auth>Container</res-auth><br> </resource-ref></p>\n<p>2.15安全限制配置<br> <security-constraint><br>       <display-name>Example Security Constraint</display-name><br>       <web-resource-collection><br>           <web-resource-name>Protected Area</web-resource-name><br>           <url-pattern>/jsp/security/protected/*</url-pattern><br>           <http-method>DELETE</http-method><br>           <http-method>GET</http-method><br>           <http-method>POST</http-method><br>           <http-method>PUT</http-method><br>       </web-resource-collection><br>       <auth-constraint><br>           <role-name>tomcat</role-name><br>           <role-name>role1</role-name><br>       </auth-constraint><br> </security-constraint></p>\n<p>2.16登录验证配置</p>\n<p><login-config><br>     <auth-method>FORM</auth-method><br>     <realm-name>Example-Based Authentiation Area</realm-name><br>   <form-login-config><br>          <form-login-page>/jsp/security/protected/login.jsp</form-login-page><br>          <form-error-page>/jsp/security/protected/error.jsp</form-error-page><br>     </form-login-config><br></login-config></p>\n<p>2.17安全角色：security-role元素给出安全角色的一个列表，这些角色将出现在servlet元素内的security-role-ref元素的role-name子元素中。<br>分别地声明角色可使高级IDE处理安全信息更为容易。</p>\n<p><security-role><br>     <role-name>tomcat</role-name><br></security-role></p>\n<p>2.18Web环境参数：env-entry元素生命Web应用的环境项</p>\n<p><env-entry><br>     <env-entry-name>minExemptions</env-entry-name><br>     <env-entry-value>1</env-entry-value><br>     <env-entry-type>java.lang.Integer</env-entry-type><br></env-entry></p>\n<p>2.19EJB声明</p>\n<p><ejb-ref><br>     <description>Example EJB reference<br>     <ejb-ref-name>ejb/Account</ejb-ref-name><br>     <ejb-ref-type>Entity</ejb-ref-type><br>     <home>com.mycompany.mypackage.AccountHome</home><br>     <remote>com.mycompany.mypackage.Account</remote><br></description></ejb-ref></p>\n<p>2.20本地EJB声明</p>\n<p><ejb-local-ref><br>     <description>Example Loacal EJB reference<br>     <ejb-ref-name>ejb/ProcessOrder</ejb-ref-name><br>     <ejb-ref-type>Session</ejb-ref-type><br>     <local-home>com.mycompany.mypackage.ProcessOrderHome</local-home><br>     <local>com.mycompany.mypackage.ProcessOrder</local><br></description></ejb-local-ref></p>"},{"title":"Hello, Markdown!","date":"2017-01-19T06:57:17.000Z","toc":true,"_content":"Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。\n<!--more-->\n### 一、标题\n代码:\n```\n### 三级标题\n#### 四级标题\n##### 五级标题\n```\n\n效果:\n### 三级标题\n#### 四级标题\n##### 五级标题\n\n### 二、列表\n\n代码:\n```\n* 一级标题\n* 二级标题\n* 三级标题\n* 四级标题\n* 五级标题\n```\n效果:\n* 一级标题\n* 二级标题\n* 三级标题\n* 四级标题\n* 五级标题\n\n代码:\n```\n1. 一级标题\n2. 二级标题\n3. 三级标题\n4. 四级标题\n5. 五级标题\n```\n效果:\n1. 一级标题\n2. 二级标题\n3. 三级标题\n4. 四级标题\n5. 五级标题\n\n### 三、代码区块(Evernote也可以用奥)(```)\n```\ntest\n```\n### 四、总结\n\n其实用熟练了就特别方便了\n现在新版的IDEA已经支持了\n有道云笔记也支持了\nEvernote支持的不是很好，可以使用马克飞翔\n\n### 五、参考文献\n\n1. http://wowubuntu.com/markdown/index.html\n\n","source":"_posts/2HelloMarkdown.md","raw":"---\ntitle: Hello, Markdown!\ndate: 2017-01-19 14:57:17\ntags: Tech\ncategories: \"博客技术\"\ntoc: true\n---\nMarkdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。\n<!--more-->\n### 一、标题\n代码:\n```\n### 三级标题\n#### 四级标题\n##### 五级标题\n```\n\n效果:\n### 三级标题\n#### 四级标题\n##### 五级标题\n\n### 二、列表\n\n代码:\n```\n* 一级标题\n* 二级标题\n* 三级标题\n* 四级标题\n* 五级标题\n```\n效果:\n* 一级标题\n* 二级标题\n* 三级标题\n* 四级标题\n* 五级标题\n\n代码:\n```\n1. 一级标题\n2. 二级标题\n3. 三级标题\n4. 四级标题\n5. 五级标题\n```\n效果:\n1. 一级标题\n2. 二级标题\n3. 三级标题\n4. 四级标题\n5. 五级标题\n\n### 三、代码区块(Evernote也可以用奥)(```)\n```\ntest\n```\n### 四、总结\n\n其实用熟练了就特别方便了\n现在新版的IDEA已经支持了\n有道云笔记也支持了\nEvernote支持的不是很好，可以使用马克飞翔\n\n### 五、参考文献\n\n1. http://wowubuntu.com/markdown/index.html\n\n","slug":"2HelloMarkdown","published":1,"updated":"2018-11-28T08:15:17.563Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tcag001ja7xwm04wgz2j","content":"<p>Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。<br><a id=\"more\"></a></p>\n<h3 id=\"一、标题\"><a href=\"#一、标题\" class=\"headerlink\" title=\"一、标题\"></a>一、标题</h3><p>代码:<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">### 三级标题</div><div class=\"line\">#### 四级标题</div><div class=\"line\">##### 五级标题</div></pre></td></tr></table></figure></p>\n<p>效果:</p>\n<h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><h3 id=\"二、列表\"><a href=\"#二、列表\" class=\"headerlink\" title=\"二、列表\"></a>二、列表</h3><p>代码:<br><figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"bullet\">* </span>一级标题</div><div class=\"line\"><span class=\"bullet\">* </span>二级标题</div><div class=\"line\"><span class=\"bullet\">* </span>三级标题</div><div class=\"line\"><span class=\"bullet\">* </span>四级标题</div><div class=\"line\"><span class=\"bullet\">* </span>五级标题</div></pre></td></tr></table></figure></p>\n<p>效果:</p>\n<ul>\n<li>一级标题</li>\n<li>二级标题</li>\n<li>三级标题</li>\n<li>四级标题</li>\n<li>五级标题</li>\n</ul>\n<p>代码:<br><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"bullet\">1. </span>一级标题</div><div class=\"line\"><span class=\"bullet\">2. </span>二级标题</div><div class=\"line\"><span class=\"bullet\">3. </span>三级标题</div><div class=\"line\"><span class=\"bullet\">4. </span>四级标题</div><div class=\"line\"><span class=\"bullet\">5. </span>五级标题</div></pre></td></tr></table></figure></p>\n<p>效果:</p>\n<ol>\n<li>一级标题</li>\n<li>二级标题</li>\n<li>三级标题</li>\n<li>四级标题</li>\n<li>五级标题</li>\n</ol>\n<h3 id=\"三、代码区块-Evernote也可以用奥\"><a href=\"#三、代码区块-Evernote也可以用奥\" class=\"headerlink\" title=\"三、代码区块(Evernote也可以用奥)(\"></a>三、代码区块(Evernote也可以用奥)(<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">```</div><div class=\"line\">test</div></pre></td></tr></table></figure></h3><h3 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h3><p>其实用熟练了就特别方便了<br>现在新版的IDEA已经支持了<br>有道云笔记也支持了<br>Evernote支持的不是很好，可以使用马克飞翔</p>\n<h3 id=\"五、参考文献\"><a href=\"#五、参考文献\" class=\"headerlink\" title=\"五、参考文献\"></a>五、参考文献</h3><ol>\n<li><a href=\"http://wowubuntu.com/markdown/index.html\" target=\"_blank\" rel=\"external\">http://wowubuntu.com/markdown/index.html</a></li>\n</ol>\n","excerpt":"<p>Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。<br></p>","more":"<p></p>\n<h3 id=\"一、标题\"><a href=\"#一、标题\" class=\"headerlink\" title=\"一、标题\"></a>一、标题</h3><p>代码:<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">### 三级标题</div><div class=\"line\">#### 四级标题</div><div class=\"line\">##### 五级标题</div></pre></td></tr></table></figure></p>\n<p>效果:</p>\n<h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><h3 id=\"二、列表\"><a href=\"#二、列表\" class=\"headerlink\" title=\"二、列表\"></a>二、列表</h3><p>代码:<br><figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"bullet\">* </span>一级标题</div><div class=\"line\"><span class=\"bullet\">* </span>二级标题</div><div class=\"line\"><span class=\"bullet\">* </span>三级标题</div><div class=\"line\"><span class=\"bullet\">* </span>四级标题</div><div class=\"line\"><span class=\"bullet\">* </span>五级标题</div></pre></td></tr></table></figure></p>\n<p>效果:</p>\n<ul>\n<li>一级标题</li>\n<li>二级标题</li>\n<li>三级标题</li>\n<li>四级标题</li>\n<li>五级标题</li>\n</ul>\n<p>代码:<br><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"bullet\">1. </span>一级标题</div><div class=\"line\"><span class=\"bullet\">2. </span>二级标题</div><div class=\"line\"><span class=\"bullet\">3. </span>三级标题</div><div class=\"line\"><span class=\"bullet\">4. </span>四级标题</div><div class=\"line\"><span class=\"bullet\">5. </span>五级标题</div></pre></td></tr></table></figure></p>\n<p>效果:</p>\n<ol>\n<li>一级标题</li>\n<li>二级标题</li>\n<li>三级标题</li>\n<li>四级标题</li>\n<li>五级标题</li>\n</ol>\n<h3 id=\"三、代码区块-Evernote也可以用奥\"><a href=\"#三、代码区块-Evernote也可以用奥\" class=\"headerlink\" title=\"三、代码区块(Evernote也可以用奥)(\"></a>三、代码区块(Evernote也可以用奥)(<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">```</div><div class=\"line\">test</div></pre></td></tr></table></figure></h3><h3 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h3><p>其实用熟练了就特别方便了<br>现在新版的IDEA已经支持了<br>有道云笔记也支持了<br>Evernote支持的不是很好，可以使用马克飞翔</p>\n<h3 id=\"五、参考文献\"><a href=\"#五、参考文献\" class=\"headerlink\" title=\"五、参考文献\"></a>五、参考文献</h3><ol>\n<li><a href=\"http://wowubuntu.com/markdown/index.html\">http://wowubuntu.com/markdown/index.html</a></li>\n</ol>"},{"title":"ni真的了解TCP三次握手么？","date":"2018-07-13T02:27:40.000Z","_content":"先来回顾下三次握手里面涉及到的问题:\n\n1. 当 client 通过 connect 向 server 发出 SYN 包时，client 会维护一个 socket 等待队列，而 server 会维护一个 SYN 队列。\n\n2. 此时进入半链接的状态，如果 socket 等待队列满了，server 则会丢弃，而 client 也会由此返回 connection time out；只要是 client 没有收到 SYN+ACK，3s 之后，client 会再次发送，如果依然没有收到，9s 之后会继续发送。\n\n3. 半连接 syn 队列的长度为 max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog)  决定。\n\n4. 当 server 收到 client 的 SYN 包后，会返回 SYN, ACK 的包加以确认，client 的 TCP 协议栈会唤醒 socket 等待队列，发出 connect 调用。\n\n5. client 返回 ACK 的包后，server 会进入一个新的叫 accept 的队列，该队列的长度为 min(backlog, somaxconn)，默认情况下，somaxconn 的值为 128，表示最多有 129 的 ESTAB 的连接等待 accept()，而 backlog 的值则由 int listen(int sockfd, int backlog) 中的第二个参数指定，listen 里面的 backlog 的含义请看这里。需要注意的是，一些 Linux 的发型版本可能存在对 somaxcon 错误 truncating 方式。\n\n6. 当 accept 队列满了之后，即使 client 继续向 server 发送 ACK 的包，也会不被相应，此时，server 通过 /proc/sys/net/ipv4/tcp_abort_on_overflow 来决定如何返回，0 表示直接丢弃该 ACK，1 表示发送 RST 通知 client；相应的，client 则会分别返回 read timeout 或者 connection reset by peer。上面说的只是些理论，如果服务器不及时的调用 accept()，当 queue 满了之后，服务器并不会按照理论所述，不再对 SYN 进行应答，返回 ETIMEDOUT。根据这篇文档的描述，实际情况并非如此，服务器会随机的忽略收到的 SYN，建立起来的连接数可以无限的增加，只不过客户端会遇到延时以及超时的情况。\n\n可以看到，整个 TCP stack 有如下的两个 queue:\n\n1. 一个是 half open(syn queue) queue(max(tcp_max_syn_backlog, 64))，用来保存 SYN_SENT 以及 SYN_RECV 的信息。\n\n2. 另外一个是 accept queue(min(somaxconn, backlog))，保存 ESTAB 的状态，但是调用 accept()。\n\n注意，之前我对 Recv-Q/Send-Q 的理解有些误差，使用 ss 获取到的 Recv-Q/Send-Q 在 LISTEN 状态以及非 LISTEN 状态所表达的含义是不同的。从 tcp_diag.c 源码中可以看到二者的区别:\n\nLISTEN 状态: Recv-Q 表示的当前等待服务端调用 accept 完成三次握手的 listen backlog 数值，也就是说，当客户端通过 connect() 去连接正在 listen() 的服务端时，这些连接会一直处于这个 queue 里面直到被服务端 accept()；Send-Q 表示的则是最大的 listen backlog 数值，这就就是上面提到的 min(backlog, somaxconn) 的值。其余状态: 非 LISTEN 状态之前理解的没有问题。Recv-Q 表示 receive queue 中的 bytes 数量；Send-Q 表示 send queue 中的 bytes 数值。\n\n要理解上面总结的这些，可以参见下这两个案例(1, 2)。 \n\n通过 \"SYNs to LISTEN sockets dropped\" 以及 \"times the listen queue of a socket overflowed\" 这两个 netstat -s 获取到的 TCP 状态，可以很快的发现系统存在的一些问题。任何一个包含 \"dropped\" 或者 \"overflowed\" 并且数值一直居高不下的 metric 从字面含义理解来看，都不是一个好现象。\n\n对于 Nginx 来说，backlog 的默认值为 511，这个可以通过 ss/netstat 的 Send-Q 确认:State      Recv-Q Send-Q        Local Address:Port          Peer Address:PortLISTEN     0      511                       *:80                       *:*     \n\n可以通过适当的增大 nginx 的 backlog 以及 somaxconn 来增大队列:listen 80 backlog=1638\n\n上面说了这么多，其实就是为了引入下面这个问题。我们线上一个基于 Netty 的代码，3.5.12 的版本，监控显示 \"times the listen queue of a socket overflowed\" 常年居高不下，动辄几十 K，通过 ss，我们发现其 backlog 的值只有 50:Recv-Q Send-Q           Local Address:Port               Peer Address:Port   0      50                           *:6928                          *:*        users:((\"java\",454409,196))\n\ng 了一下，发现这个版本复用了 Java 默认的 50 这个值。将其增加到 1024 测试，监控曲线一下子降低到了 0。\n\n除了上面这些，还有一个比较基础的 net.core.netdev_max_backlog，如果内核接受包的速度大于被 userspace 处理的速度，该值定义了可以在接口输入最大的的包数量。\n\nchartbeat 分享了两篇很精彩的文档，其中涉及到了 queue 的一些问题。Lessons learned tuning TCP and Nginx in EC2 1 Lessons learned tuning TCP and Nginx in EC2 2\n\nref:http://madalanarayana.wordpress.com/2014/04/13/learnings-on-tcp-syn/\n\nRELATED POSTS:\n\nHow Many Non-Persistent Connections Can Nginx/Tengine…\n\ntcp_keepalive_time and rst Flag in NAT Environment\n\nRouter Matters\n\n通过 tcpcopy(pf_ring) 对 BCM 5719 小包做的多组…\n\n通过 noVNC 实现数千台自助机的实时可视化\n\n参考文档：\n\nhttp://jaseywang.me/2014/07/20/tcp-queue-%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/\n\nhttps://mp.weixin.qq.com/s/yH3PzGEFopbpA-jw4MythQ\n\nhttps://www.douban.com/note/178129553/","source":"_posts/29ni真的了解TCP三次握手么？.md","raw":"---\ntitle: ni真的了解TCP三次握手么？\ndate: 2018-07-13 10:27:40\ntags:\n---\n先来回顾下三次握手里面涉及到的问题:\n\n1. 当 client 通过 connect 向 server 发出 SYN 包时，client 会维护一个 socket 等待队列，而 server 会维护一个 SYN 队列。\n\n2. 此时进入半链接的状态，如果 socket 等待队列满了，server 则会丢弃，而 client 也会由此返回 connection time out；只要是 client 没有收到 SYN+ACK，3s 之后，client 会再次发送，如果依然没有收到，9s 之后会继续发送。\n\n3. 半连接 syn 队列的长度为 max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog)  决定。\n\n4. 当 server 收到 client 的 SYN 包后，会返回 SYN, ACK 的包加以确认，client 的 TCP 协议栈会唤醒 socket 等待队列，发出 connect 调用。\n\n5. client 返回 ACK 的包后，server 会进入一个新的叫 accept 的队列，该队列的长度为 min(backlog, somaxconn)，默认情况下，somaxconn 的值为 128，表示最多有 129 的 ESTAB 的连接等待 accept()，而 backlog 的值则由 int listen(int sockfd, int backlog) 中的第二个参数指定，listen 里面的 backlog 的含义请看这里。需要注意的是，一些 Linux 的发型版本可能存在对 somaxcon 错误 truncating 方式。\n\n6. 当 accept 队列满了之后，即使 client 继续向 server 发送 ACK 的包，也会不被相应，此时，server 通过 /proc/sys/net/ipv4/tcp_abort_on_overflow 来决定如何返回，0 表示直接丢弃该 ACK，1 表示发送 RST 通知 client；相应的，client 则会分别返回 read timeout 或者 connection reset by peer。上面说的只是些理论，如果服务器不及时的调用 accept()，当 queue 满了之后，服务器并不会按照理论所述，不再对 SYN 进行应答，返回 ETIMEDOUT。根据这篇文档的描述，实际情况并非如此，服务器会随机的忽略收到的 SYN，建立起来的连接数可以无限的增加，只不过客户端会遇到延时以及超时的情况。\n\n可以看到，整个 TCP stack 有如下的两个 queue:\n\n1. 一个是 half open(syn queue) queue(max(tcp_max_syn_backlog, 64))，用来保存 SYN_SENT 以及 SYN_RECV 的信息。\n\n2. 另外一个是 accept queue(min(somaxconn, backlog))，保存 ESTAB 的状态，但是调用 accept()。\n\n注意，之前我对 Recv-Q/Send-Q 的理解有些误差，使用 ss 获取到的 Recv-Q/Send-Q 在 LISTEN 状态以及非 LISTEN 状态所表达的含义是不同的。从 tcp_diag.c 源码中可以看到二者的区别:\n\nLISTEN 状态: Recv-Q 表示的当前等待服务端调用 accept 完成三次握手的 listen backlog 数值，也就是说，当客户端通过 connect() 去连接正在 listen() 的服务端时，这些连接会一直处于这个 queue 里面直到被服务端 accept()；Send-Q 表示的则是最大的 listen backlog 数值，这就就是上面提到的 min(backlog, somaxconn) 的值。其余状态: 非 LISTEN 状态之前理解的没有问题。Recv-Q 表示 receive queue 中的 bytes 数量；Send-Q 表示 send queue 中的 bytes 数值。\n\n要理解上面总结的这些，可以参见下这两个案例(1, 2)。 \n\n通过 \"SYNs to LISTEN sockets dropped\" 以及 \"times the listen queue of a socket overflowed\" 这两个 netstat -s 获取到的 TCP 状态，可以很快的发现系统存在的一些问题。任何一个包含 \"dropped\" 或者 \"overflowed\" 并且数值一直居高不下的 metric 从字面含义理解来看，都不是一个好现象。\n\n对于 Nginx 来说，backlog 的默认值为 511，这个可以通过 ss/netstat 的 Send-Q 确认:State      Recv-Q Send-Q        Local Address:Port          Peer Address:PortLISTEN     0      511                       *:80                       *:*     \n\n可以通过适当的增大 nginx 的 backlog 以及 somaxconn 来增大队列:listen 80 backlog=1638\n\n上面说了这么多，其实就是为了引入下面这个问题。我们线上一个基于 Netty 的代码，3.5.12 的版本，监控显示 \"times the listen queue of a socket overflowed\" 常年居高不下，动辄几十 K，通过 ss，我们发现其 backlog 的值只有 50:Recv-Q Send-Q           Local Address:Port               Peer Address:Port   0      50                           *:6928                          *:*        users:((\"java\",454409,196))\n\ng 了一下，发现这个版本复用了 Java 默认的 50 这个值。将其增加到 1024 测试，监控曲线一下子降低到了 0。\n\n除了上面这些，还有一个比较基础的 net.core.netdev_max_backlog，如果内核接受包的速度大于被 userspace 处理的速度，该值定义了可以在接口输入最大的的包数量。\n\nchartbeat 分享了两篇很精彩的文档，其中涉及到了 queue 的一些问题。Lessons learned tuning TCP and Nginx in EC2 1 Lessons learned tuning TCP and Nginx in EC2 2\n\nref:http://madalanarayana.wordpress.com/2014/04/13/learnings-on-tcp-syn/\n\nRELATED POSTS:\n\nHow Many Non-Persistent Connections Can Nginx/Tengine…\n\ntcp_keepalive_time and rst Flag in NAT Environment\n\nRouter Matters\n\n通过 tcpcopy(pf_ring) 对 BCM 5719 小包做的多组…\n\n通过 noVNC 实现数千台自助机的实时可视化\n\n参考文档：\n\nhttp://jaseywang.me/2014/07/20/tcp-queue-%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/\n\nhttps://mp.weixin.qq.com/s/yH3PzGEFopbpA-jw4MythQ\n\nhttps://www.douban.com/note/178129553/","slug":"29ni真的了解TCP三次握手么？","published":1,"updated":"2018-11-29T03:53:15.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tcah001ma7xws5onz8ws","content":"<p>先来回顾下三次握手里面涉及到的问题:</p>\n<ol>\n<li><p>当 client 通过 connect 向 server 发出 SYN 包时，client 会维护一个 socket 等待队列，而 server 会维护一个 SYN 队列。</p>\n</li>\n<li><p>此时进入半链接的状态，如果 socket 等待队列满了，server 则会丢弃，而 client 也会由此返回 connection time out；只要是 client 没有收到 SYN+ACK，3s 之后，client 会再次发送，如果依然没有收到，9s 之后会继续发送。</p>\n</li>\n<li><p>半连接 syn 队列的长度为 max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog)  决定。</p>\n</li>\n<li><p>当 server 收到 client 的 SYN 包后，会返回 SYN, ACK 的包加以确认，client 的 TCP 协议栈会唤醒 socket 等待队列，发出 connect 调用。</p>\n</li>\n<li><p>client 返回 ACK 的包后，server 会进入一个新的叫 accept 的队列，该队列的长度为 min(backlog, somaxconn)，默认情况下，somaxconn 的值为 128，表示最多有 129 的 ESTAB 的连接等待 accept()，而 backlog 的值则由 int listen(int sockfd, int backlog) 中的第二个参数指定，listen 里面的 backlog 的含义请看这里。需要注意的是，一些 Linux 的发型版本可能存在对 somaxcon 错误 truncating 方式。</p>\n</li>\n<li><p>当 accept 队列满了之后，即使 client 继续向 server 发送 ACK 的包，也会不被相应，此时，server 通过 /proc/sys/net/ipv4/tcp_abort_on_overflow 来决定如何返回，0 表示直接丢弃该 ACK，1 表示发送 RST 通知 client；相应的，client 则会分别返回 read timeout 或者 connection reset by peer。上面说的只是些理论，如果服务器不及时的调用 accept()，当 queue 满了之后，服务器并不会按照理论所述，不再对 SYN 进行应答，返回 ETIMEDOUT。根据这篇文档的描述，实际情况并非如此，服务器会随机的忽略收到的 SYN，建立起来的连接数可以无限的增加，只不过客户端会遇到延时以及超时的情况。</p>\n</li>\n</ol>\n<p>可以看到，整个 TCP stack 有如下的两个 queue:</p>\n<ol>\n<li><p>一个是 half open(syn queue) queue(max(tcp_max_syn_backlog, 64))，用来保存 SYN_SENT 以及 SYN_RECV 的信息。</p>\n</li>\n<li><p>另外一个是 accept queue(min(somaxconn, backlog))，保存 ESTAB 的状态，但是调用 accept()。</p>\n</li>\n</ol>\n<p>注意，之前我对 Recv-Q/Send-Q 的理解有些误差，使用 ss 获取到的 Recv-Q/Send-Q 在 LISTEN 状态以及非 LISTEN 状态所表达的含义是不同的。从 tcp_diag.c 源码中可以看到二者的区别:</p>\n<p>LISTEN 状态: Recv-Q 表示的当前等待服务端调用 accept 完成三次握手的 listen backlog 数值，也就是说，当客户端通过 connect() 去连接正在 listen() 的服务端时，这些连接会一直处于这个 queue 里面直到被服务端 accept()；Send-Q 表示的则是最大的 listen backlog 数值，这就就是上面提到的 min(backlog, somaxconn) 的值。其余状态: 非 LISTEN 状态之前理解的没有问题。Recv-Q 表示 receive queue 中的 bytes 数量；Send-Q 表示 send queue 中的 bytes 数值。</p>\n<p>要理解上面总结的这些，可以参见下这两个案例(1, 2)。 </p>\n<p>通过 “SYNs to LISTEN sockets dropped” 以及 “times the listen queue of a socket overflowed” 这两个 netstat -s 获取到的 TCP 状态，可以很快的发现系统存在的一些问题。任何一个包含 “dropped” 或者 “overflowed” 并且数值一直居高不下的 metric 从字面含义理解来看，都不是一个好现象。</p>\n<p>对于 Nginx 来说，backlog 的默认值为 511，这个可以通过 ss/netstat 的 Send-Q 确认:State      Recv-Q Send-Q        Local Address:Port          Peer Address:PortLISTEN     0      511                       <em>:80                       </em>:*     </p>\n<p>可以通过适当的增大 nginx 的 backlog 以及 somaxconn 来增大队列:listen 80 backlog=1638</p>\n<p>上面说了这么多，其实就是为了引入下面这个问题。我们线上一个基于 Netty 的代码，3.5.12 的版本，监控显示 “times the listen queue of a socket overflowed” 常年居高不下，动辄几十 K，通过 ss，我们发现其 backlog 的值只有 50:Recv-Q Send-Q           Local Address:Port               Peer Address:Port   0      50                           <em>:6928                          </em>:*        users:((“java”,454409,196))</p>\n<p>g 了一下，发现这个版本复用了 Java 默认的 50 这个值。将其增加到 1024 测试，监控曲线一下子降低到了 0。</p>\n<p>除了上面这些，还有一个比较基础的 net.core.netdev_max_backlog，如果内核接受包的速度大于被 userspace 处理的速度，该值定义了可以在接口输入最大的的包数量。</p>\n<p>chartbeat 分享了两篇很精彩的文档，其中涉及到了 queue 的一些问题。Lessons learned tuning TCP and Nginx in EC2 1 Lessons learned tuning TCP and Nginx in EC2 2</p>\n<p>ref:<a href=\"http://madalanarayana.wordpress.com/2014/04/13/learnings-on-tcp-syn/\" target=\"_blank\" rel=\"external\">http://madalanarayana.wordpress.com/2014/04/13/learnings-on-tcp-syn/</a></p>\n<p>RELATED POSTS:</p>\n<p>How Many Non-Persistent Connections Can Nginx/Tengine…</p>\n<p>tcp_keepalive_time and rst Flag in NAT Environment</p>\n<p>Router Matters</p>\n<p>通过 tcpcopy(pf_ring) 对 BCM 5719 小包做的多组…</p>\n<p>通过 noVNC 实现数千台自助机的实时可视化</p>\n<p>参考文档：</p>\n<p><a href=\"http://jaseywang.me/2014/07/20/tcp-queue-%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/\" target=\"_blank\" rel=\"external\">http://jaseywang.me/2014/07/20/tcp-queue-%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/yH3PzGEFopbpA-jw4MythQ\" target=\"_blank\" rel=\"external\">https://mp.weixin.qq.com/s/yH3PzGEFopbpA-jw4MythQ</a></p>\n<p><a href=\"https://www.douban.com/note/178129553/\" target=\"_blank\" rel=\"external\">https://www.douban.com/note/178129553/</a></p>\n","excerpt":"","more":"<p>先来回顾下三次握手里面涉及到的问题:</p>\n<ol>\n<li><p>当 client 通过 connect 向 server 发出 SYN 包时，client 会维护一个 socket 等待队列，而 server 会维护一个 SYN 队列。</p>\n</li>\n<li><p>此时进入半链接的状态，如果 socket 等待队列满了，server 则会丢弃，而 client 也会由此返回 connection time out；只要是 client 没有收到 SYN+ACK，3s 之后，client 会再次发送，如果依然没有收到，9s 之后会继续发送。</p>\n</li>\n<li><p>半连接 syn 队列的长度为 max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog)  决定。</p>\n</li>\n<li><p>当 server 收到 client 的 SYN 包后，会返回 SYN, ACK 的包加以确认，client 的 TCP 协议栈会唤醒 socket 等待队列，发出 connect 调用。</p>\n</li>\n<li><p>client 返回 ACK 的包后，server 会进入一个新的叫 accept 的队列，该队列的长度为 min(backlog, somaxconn)，默认情况下，somaxconn 的值为 128，表示最多有 129 的 ESTAB 的连接等待 accept()，而 backlog 的值则由 int listen(int sockfd, int backlog) 中的第二个参数指定，listen 里面的 backlog 的含义请看这里。需要注意的是，一些 Linux 的发型版本可能存在对 somaxcon 错误 truncating 方式。</p>\n</li>\n<li><p>当 accept 队列满了之后，即使 client 继续向 server 发送 ACK 的包，也会不被相应，此时，server 通过 /proc/sys/net/ipv4/tcp_abort_on_overflow 来决定如何返回，0 表示直接丢弃该 ACK，1 表示发送 RST 通知 client；相应的，client 则会分别返回 read timeout 或者 connection reset by peer。上面说的只是些理论，如果服务器不及时的调用 accept()，当 queue 满了之后，服务器并不会按照理论所述，不再对 SYN 进行应答，返回 ETIMEDOUT。根据这篇文档的描述，实际情况并非如此，服务器会随机的忽略收到的 SYN，建立起来的连接数可以无限的增加，只不过客户端会遇到延时以及超时的情况。</p>\n</li>\n</ol>\n<p>可以看到，整个 TCP stack 有如下的两个 queue:</p>\n<ol>\n<li><p>一个是 half open(syn queue) queue(max(tcp_max_syn_backlog, 64))，用来保存 SYN_SENT 以及 SYN_RECV 的信息。</p>\n</li>\n<li><p>另外一个是 accept queue(min(somaxconn, backlog))，保存 ESTAB 的状态，但是调用 accept()。</p>\n</li>\n</ol>\n<p>注意，之前我对 Recv-Q/Send-Q 的理解有些误差，使用 ss 获取到的 Recv-Q/Send-Q 在 LISTEN 状态以及非 LISTEN 状态所表达的含义是不同的。从 tcp_diag.c 源码中可以看到二者的区别:</p>\n<p>LISTEN 状态: Recv-Q 表示的当前等待服务端调用 accept 完成三次握手的 listen backlog 数值，也就是说，当客户端通过 connect() 去连接正在 listen() 的服务端时，这些连接会一直处于这个 queue 里面直到被服务端 accept()；Send-Q 表示的则是最大的 listen backlog 数值，这就就是上面提到的 min(backlog, somaxconn) 的值。其余状态: 非 LISTEN 状态之前理解的没有问题。Recv-Q 表示 receive queue 中的 bytes 数量；Send-Q 表示 send queue 中的 bytes 数值。</p>\n<p>要理解上面总结的这些，可以参见下这两个案例(1, 2)。 </p>\n<p>通过 “SYNs to LISTEN sockets dropped” 以及 “times the listen queue of a socket overflowed” 这两个 netstat -s 获取到的 TCP 状态，可以很快的发现系统存在的一些问题。任何一个包含 “dropped” 或者 “overflowed” 并且数值一直居高不下的 metric 从字面含义理解来看，都不是一个好现象。</p>\n<p>对于 Nginx 来说，backlog 的默认值为 511，这个可以通过 ss/netstat 的 Send-Q 确认:State      Recv-Q Send-Q        Local Address:Port          Peer Address:PortLISTEN     0      511                       <em>:80                       </em>:*     </p>\n<p>可以通过适当的增大 nginx 的 backlog 以及 somaxconn 来增大队列:listen 80 backlog=1638</p>\n<p>上面说了这么多，其实就是为了引入下面这个问题。我们线上一个基于 Netty 的代码，3.5.12 的版本，监控显示 “times the listen queue of a socket overflowed” 常年居高不下，动辄几十 K，通过 ss，我们发现其 backlog 的值只有 50:Recv-Q Send-Q           Local Address:Port               Peer Address:Port   0      50                           <em>:6928                          </em>:*        users:((“java”,454409,196))</p>\n<p>g 了一下，发现这个版本复用了 Java 默认的 50 这个值。将其增加到 1024 测试，监控曲线一下子降低到了 0。</p>\n<p>除了上面这些，还有一个比较基础的 net.core.netdev_max_backlog，如果内核接受包的速度大于被 userspace 处理的速度，该值定义了可以在接口输入最大的的包数量。</p>\n<p>chartbeat 分享了两篇很精彩的文档，其中涉及到了 queue 的一些问题。Lessons learned tuning TCP and Nginx in EC2 1 Lessons learned tuning TCP and Nginx in EC2 2</p>\n<p>ref:<a href=\"http://madalanarayana.wordpress.com/2014/04/13/learnings-on-tcp-syn/\">http://madalanarayana.wordpress.com/2014/04/13/learnings-on-tcp-syn/</a></p>\n<p>RELATED POSTS:</p>\n<p>How Many Non-Persistent Connections Can Nginx/Tengine…</p>\n<p>tcp_keepalive_time and rst Flag in NAT Environment</p>\n<p>Router Matters</p>\n<p>通过 tcpcopy(pf_ring) 对 BCM 5719 小包做的多组…</p>\n<p>通过 noVNC 实现数千台自助机的实时可视化</p>\n<p>参考文档：</p>\n<p><a href=\"http://jaseywang.me/2014/07/20/tcp-queue-%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/\">http://jaseywang.me/2014/07/20/tcp-queue-%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/yH3PzGEFopbpA-jw4MythQ\">https://mp.weixin.qq.com/s/yH3PzGEFopbpA-jw4MythQ</a></p>\n<p><a href=\"https://www.douban.com/note/178129553/\">https://www.douban.com/note/178129553/</a></p>\n"},{"title":"POM文件详解","date":"2018-01-15T12:43:01.000Z","_content":"\n在Java语言中，框架通常是海量的，如果盲目的去学习某个框架，最终的结果就是两败俱伤，学习的人白白浪费了时间和精力，\n而新的框架又在不断产生，可能今天学习的框架，明天又出了一个更好的。但是有些软件却是非常值得“深究”的，\n因为他/她总会在某个特定的时刻，让人爱的无法自拔。。。。\n要学习maven，首先要爱上它，我爱上它的原因是实在无法忍受种种框架依赖的种种jar包。在使用maven以前，\n例如搭建一个非常熟悉的SSH框架，就首先要去Struts、Spring、Hibernate下载各个sdk，然后参照各自的help文档，来“集合”需要的jar，\n其中有许多jar只会在特定的条件下才会用到，通常情况下都用不到。而且，有些jar属于第三方的jar，\n这意味着必须得自己找那些jar，例如commons-xxxx系列。所有jar集齐后，在排除冲突，最后将搭好的框架放在eclipse里测试运行，\n再看看有哪些问题。这样“千辛万苦”搭好的环境，可能随着其中一个组件版本的变化，例如spring版本的升级，又需要重新在来一次。\n而且最后搭好的框架光jar可能就几百M。每次向svn上传时，就会特别悲伤。。。。\n<!--more-->\n\n```\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd \">\n\n  <!-- 父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。 -->\n  <parent>\n    <!-- 被继承的父项目的构件标识符 -->\n    <artifactId />\n    <!-- 被继承的父项目的全球唯一标识符 -->\n    <groupId />\n    <!-- 被继承的父项目的版本 -->\n    <version />\n    <!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 -->\n    <relativePath />\n  </parent>\n\n  <!-- 声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 -->\n  <modelVersion> 4.0.0 </modelVersion>\n  <!-- 项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app -->\n  <groupId> asia.banseon </groupId>\n  <!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源码，二进制发布和WARs等。 -->\n  <artifactId> banseon-maven2 </artifactId>\n  <!-- 项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 -->\n  <packaging> jar </packaging>\n  <!-- 项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 -->\n  <version> 1.0-SNAPSHOT </version>\n  <!-- 项目的名称, Maven产生的文档用 -->\n  <name> banseon-maven </name>\n  <!-- 项目主页的URL, Maven产生的文档用 -->\n  <url> http://www.baidu.com/banseon </url>\n  <!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 -->\n  <description> A maven project to study maven. </description>\n\n  <!-- 描述了这个项目构建环境中的前提条件。 -->\n  <prerequisites>\n    <!-- 构建该项目或使用该插件所需要的Maven的最低版本 -->\n    <maven />\n  </prerequisites>\n\n  <!-- 项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira -->\n  <issueManagement>\n    <!-- 问题管理系统（例如jira）的名字， -->\n    <system> jira </system>\n    <!-- 该项目使用的问题管理系统的URL -->\n    <url> http://jira.baidu.com/banseon </url>\n  </issueManagement>\n\n  <!-- 项目持续集成信息 -->\n  <ciManagement>\n    <!-- 持续集成系统的名字，例如continuum -->\n    <system />\n    <!-- 该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 -->\n    <url />\n    <!-- 构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） -->\n    <notifiers>\n      <!-- 配置一种方式，当构建中断时，以该方式通知用户/开发者 -->\n      <notifier>\n        <!-- 传送通知的途径 -->\n        <type />\n        <!-- 发生错误时是否通知 -->\n        <sendOnError />\n        <!-- 构建失败时是否通知 -->\n        <sendOnFailure />\n        <!-- 构建成功时是否通知 -->\n        <sendOnSuccess />\n        <!-- 发生警告时是否通知 -->\n        <sendOnWarning />\n        <!-- 不赞成使用。通知发送到哪里 -->\n        <address />\n        <!-- 扩展配置项 -->\n        <configuration />\n      </notifier>\n    </notifiers>\n  </ciManagement>\n\n  <!-- 项目创建年份，4位数字。当产生版权信息时需要使用这个值。 -->\n  <inceptionYear />\n\n  <!-- 项目相关邮件列表信息 -->\n  <mailingLists>\n    <!-- 该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 -->\n    <mailingList>\n      <!-- 邮件的名称 -->\n      <name> Demo </name>\n      <!-- 发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 -->\n      <post> banseon@126.com </post>\n      <!-- 订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 -->\n      <subscribe> banseon@126.com </subscribe>\n      <!-- 取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 -->\n      <unsubscribe> banseon@126.com </unsubscribe>\n      <!-- 你可以浏览邮件信息的URL -->\n      <archive> http:/hi.baidu.com/banseon/demo/dev/ </archive>\n    </mailingList>\n  </mailingLists>\n\n  <!-- 项目开发者列表 -->\n  <developers>\n    <!-- 某个项目开发者的信息 -->\n    <developer>\n      <!-- SCM里项目开发者的唯一标识符 -->\n      <id> HELLO WORLD </id>\n      <!-- 项目开发者的全名 -->\n      <name> banseon </name>\n      <!-- 项目开发者的email -->\n      <email> banseon@126.com </email>\n      <!-- 项目开发者的主页的URL -->\n      <url />\n      <!-- 项目开发者在项目中扮演的角色，角色元素描述了各种角色 -->\n      <roles>\n        <role> Project Manager </role>\n        <role> Architect </role>\n      </roles>\n      <!-- 项目开发者所属组织 -->\n      <organization> demo </organization>\n      <!-- 项目开发者所属组织的URL -->\n      <organizationUrl> http://hi.baidu.com/banseon </organizationUrl>\n      <!-- 项目开发者属性，如即时消息如何处理等 -->\n      <properties>\n        <dept> No </dept>\n      </properties>\n      <!-- 项目开发者所在时区， -11到12范围内的整数。 -->\n      <timezone> -5 </timezone>\n    </developer>\n  </developers>\n\n  <!-- 项目的其他贡献者列表 -->\n  <contributors>\n    <!-- 项目的其他贡献者。参见developers/developer元素 -->\n    <contributor>\n      <name />\n      <email />\n      <url />\n      <organization />\n      <organizationUrl />\n      <roles />\n      <timezone />\n      <properties />\n    </contributor>\n  </contributors>\n\n  <!-- 该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 -->\n  <licenses>\n    <!-- 描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 -->\n    <license>\n    <!-- license用于法律上的名称 -->\n    <name> Apache 2 </name>\n    <!-- 官方的license正文页面的URL -->\n    <url> http://www.baidu.com/banseon/LICENSE-2.0.txt </url>\n    <!-- 项目分发的主要方式：\n    repo，可以从Maven库下载\n    manual， 用户必须手动下载和安装依赖 -->\n    <distribution> repo </distribution>\n    <!-- 关于license的补充信息 -->\n    <comments> A business-friendly OSS license </comments>\n    </license>\n  </licenses>\n\n  <!-- SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 -->\n  <scm>\n    <!-- SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 -->\n    <connection> scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk) </connection>\n    <!-- 给开发者使用的，类似connection元素。即该连接不仅仅只读 -->\n    <developerConnection> scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk </developerConnection>\n    <!-- 当前代码的标签，在开发阶段默认为HEAD -->\n    <tag />\n    <!-- 指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 -->\n    <url> http://svn.baidu.com/banseon </url>\n  </scm>\n\n  <!-- 描述项目所属组织的各种属性。Maven产生的文档用 -->\n  <organization>\n    <!-- 组织的全名 -->\n    <name> demo </name>\n    <!-- 组织主页的URL -->\n    <url> http://www.baidu.com/banseon </url>\n  </organization>\n\n  <!-- 构建项目需要的信息 -->\n  <build>\n  <!-- 该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 -->\n  <sourceDirectory />\n  <!-- 该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 -->\n  <scriptSourceDirectory />\n  <!-- 该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 -->\n  <testSourceDirectory />\n  <!-- 被编译过的应用程序class文件存放的目录。 -->\n  <outputDirectory />\n  <!-- 被编译过的测试class文件存放的目录。 -->\n  <testOutputDirectory />\n  <!-- 使用来自该项目的一系列构建扩展 -->\n  <extensions>\n    <!-- 描述使用到的构建扩展。 -->\n    <extension>\n      <!-- 构建扩展的groupId -->\n      <groupId />\n      <!-- 构建扩展的artifactId -->\n      <artifactId />\n      <!-- 构建扩展的版本 -->\n      <version />\n    </extension>\n  </extensions>\n  <!-- 当项目没有规定目标（Maven2 叫做阶段）时的默认值 -->\n  <defaultGoal />\n  <!-- 这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 -->\n  <resources>\n    <!-- 这个元素描述了项目相关或测试相关的所有资源路径 -->\n    <resource>\n    <!-- 描述了资源的目标路径。该路径相对target/classes目录（例如${project.build.outputDirectory}）。举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven/messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 -->\n    <targetPath />\n    <!-- 是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 -->\n    <filtering />\n    <!-- 描述存放资源的目录，该路径相对POM路径 -->\n    <directory />\n    <!-- 包含的模式列表，例如**/*.xml. -->\n    <includes />\n    <!-- 排除的模式列表，例如**/*.xml -->\n    <excludes />\n    </resource>\n  </resources>\n  <!-- 这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 -->\n  <testResources>\n    <!-- 这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 -->\n    <testResource>\n    <targetPath /><filtering /><directory /><includes /><excludes />\n    </testResource>\n  </testResources>\n  <!-- 构建产生的所有文件存放的目录 -->\n  <directory />\n  <!-- 产生的构件的文件名，默认值是${artifactId}-${version}。 -->\n  <finalName />\n  <!-- 当filtering开关打开时，使用到的过滤器属性文件列表 -->\n  <filters />\n  <!-- 子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 -->\n  <pluginManagement>\n  <!-- 使用的插件列表 。 -->\n  <plugins>\n  <!-- plugin元素包含描述插件所需要的信息。 -->\n  <plugin>\n  <!-- 插件在仓库里的group ID -->\n  <groupId />\n  <!-- 插件在仓库里的artifact ID -->\n  <artifactId />\n  <!-- 被使用的插件的版本（或版本范围） -->\n  <version />\n  <!-- 是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 -->\n  <extensions />\n  <!-- 在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 -->\n  <executions>\n  <!-- execution元素包含了插件执行需要的信息 -->\n  <execution>\n\n  <!-- 执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 -->\n\n  <id />\n\n  <!-- 绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 -->\n\n  <phase />\n\n  <!-- 配置的执行目标 -->\n\n  <goals />\n\n  <!-- 配置是否被传播到子POM -->\n\n  <inherited />\n\n  <!-- 作为DOM对象的配置 -->\n\n  <configuration />\n\n  </execution>\n\n  </executions>\n\n  <!-- 项目引入插件所需要的额外依赖 -->\n\n  <dependencies>\n\n  <!-- 参见dependencies/dependency元素 -->\n\n  <dependency>\n\n\n\n  </dependency>\n\n  </dependencies>\n\n  <!-- 任何配置是否被传播到子项目 -->\n\n  <inherited />\n\n  <!-- 作为DOM对象的配置 -->\n\n  <configuration />\n\n  </plugin>\n\n  </plugins>\n\n  </pluginManagement>\n\n  <!-- 使用的插件列表 -->\n\n  <plugins>\n\n  <!-- 参见build/pluginManagement/plugins/plugin元素 -->\n\n  <plugin>\n\n  <groupId /><artifactId /><version /><extensions />\n\n  <executions>\n\n  <execution>\n\n  <id /><phase /><goals /><inherited /><configuration />\n\n  </execution>\n\n  </executions>\n\n  <dependencies>\n\n  <!-- 参见dependencies/dependency元素 -->\n\n  <dependency>\n\n\n\n  </dependency>\n\n  </dependencies>\n\n  <goals /><inherited /><configuration />\n\n  </plugin>\n\n  </plugins>\n\n  </build>\n\n  <!-- 在列的项目构建profile，如果被激活，会修改构建处理 -->\n\n  <profiles>\n\n  <!-- 根据环境参数或命令行参数激活某个构建处理 -->\n\n  <profile>\n\n  <!-- 构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 -->\n\n  <id />\n\n  <!-- 自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它\n\n  能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 -->\n\n  <activation>\n\n  <!-- profile默认是否激活的标志 -->\n\n  <activeByDefault />\n\n  <!-- 当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 -->\n\n  <jdk />\n\n  <!-- 当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 -->\n\n  <os>\n\n  <!-- 激活profile的操作系统的名字 -->\n\n  <name> Windows XP </name>\n\n  <!-- 激活profile的操作系统所属家族(如 'windows') -->\n\n  <family> Windows </family>\n\n  <!-- 激活profile的操作系统体系结构 -->\n\n  <arch> x86 </arch>\n\n  <!-- 激活profile的操作系统版本 -->\n\n  <version> 5.1.2600 </version>\n\n  </os>\n\n  <!-- 如果Maven检测到某一个属性（其值可以在POM中通过${名称}引用），其拥有对应的名称和值，Profile就会被激活。如果值\n\n  字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 -->\n\n  <property>\n\n  <!-- 激活profile的属性的名称 -->\n\n  <name> mavenVersion </name>\n\n  <!-- 激活profile的属性的值 -->\n\n  <value> 2.0.3 </value>\n\n  </property>\n\n  <!-- 提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活\n\n  profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 -->\n\n  <file>\n\n  <!-- 如果指定的文件存在，则激活profile。 -->\n\n  <exists> /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ </exists>\n\n  <!-- 如果指定的文件不存在，则激活profile。 -->\n\n  <missing> /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ </missing>\n\n  </file>\n\n  </activation>\n\n  <!-- 构建项目所需要的信息。参见build元素 -->\n\n  <build>\n\n  <defaultGoal />\n\n  <resources>\n\n  <resource>\n\n  <targetPath /><filtering /><directory /><includes /><excludes />\n\n  </resource>\n\n  </resources>\n\n  <testResources>\n\n  <testResource>\n\n  <targetPath /><filtering /><directory /><includes /><excludes />\n\n  </testResource>\n\n  </testResources>\n\n  <directory /><finalName /><filters />\n\n  <pluginManagement>\n\n  <plugins>\n\n  <!-- 参见build/pluginManagement/plugins/plugin元素 -->\n\n  <plugin>\n\n  <groupId /><artifactId /><version /><extensions />\n\n  <executions>\n\n  <execution>\n\n  <id /><phase /><goals /><inherited /><configuration />\n\n  </execution>\n\n  </executions>\n\n  <dependencies>\n\n  <!-- 参见dependencies/dependency元素 -->\n\n  <dependency>\n\n\n\n  </dependency>\n\n  </dependencies>\n\n  <goals /><inherited /><configuration />\n\n  </plugin>\n\n  </plugins>\n\n  </pluginManagement>\n\n  <plugins>\n\n  <!-- 参见build/pluginManagement/plugins/plugin元素 -->\n\n  <plugin>\n\n  <groupId /><artifactId /><version /><extensions />\n\n  <executions>\n\n  <execution>\n\n  <id /><phase /><goals /><inherited /><configuration />\n\n  </execution>\n\n  </executions>\n\n  <dependencies>\n\n  <!-- 参见dependencies/dependency元素 -->\n\n  <dependency>\n\n\n\n  </dependency>\n\n  </dependencies>\n\n  <goals /><inherited /><configuration />\n\n  </plugin>\n\n  </plugins>\n\n  </build>\n\n  <!-- 模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 -->\n\n  <modules />\n\n  <!-- 发现依赖和扩展的远程仓库列表。 -->\n\n  <repositories>\n\n  <!-- 参见repositories/repository元素 -->\n\n  <repository>\n\n  <releases>\n\n  <enabled /><updatePolicy /><checksumPolicy />\n\n  </releases>\n\n  <snapshots>\n\n  <enabled /><updatePolicy /><checksumPolicy />\n\n  </snapshots>\n\n  <id /><name /><url /><layout />\n\n  </repository>\n\n  </repositories>\n\n  <!-- 发现插件的远程仓库列表，这些插件用于构建和报表 -->\n\n  <pluginRepositories>\n\n  <!-- 包含需要连接到远程插件仓库的信息.参见repositories/repository元素 -->\n\n  <pluginRepository>\n\n  <releases>\n\n  <enabled /><updatePolicy /><checksumPolicy />\n\n  </releases>\n\n  <snapshots>\n\n  <enabled /><updatePolicy /><checksumPolicy />\n\n  </snapshots>\n\n  <id /><name /><url /><layout />\n\n  </pluginRepository>\n\n  </pluginRepositories>\n\n  <!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 -->\n\n  <dependencies>\n\n  <!-- 参见dependencies/dependency元素 -->\n\n  <dependency>\n\n\n\n  </dependency>\n\n  </dependencies>\n\n  <!-- 不赞成使用. 现在Maven忽略该元素. -->\n\n  <reports />\n\n  <!-- 该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 -->\n\n  <reporting>\n\n\n\n  </reporting>\n\n  <!-- 参见dependencyManagement元素 -->\n\n  <dependencyManagement>\n\n  <dependencies>\n\n  <!-- 参见dependencies/dependency元素 -->\n\n  <dependency>\n\n\n\n  </dependency>\n\n  </dependencies>\n\n  </dependencyManagement>\n\n  <!-- 参见distributionManagement元素 -->\n\n  <distributionManagement>\n\n\n\n  </distributionManagement>\n\n  <!-- 参见properties元素 -->\n\n  <properties />\n\n  </profile>\n\n  </profiles>\n\n  <!-- 模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 -->\n\n  <modules />\n\n  <!-- 发现依赖和扩展的远程仓库列表。 -->\n\n  <repositories>\n\n  <!-- 包含需要连接到远程仓库的信息 -->\n\n  <repository>\n\n  <!-- 如何处理远程仓库里发布版本的下载 -->\n\n  <releases>\n\n  <!-- true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 -->\n\n  <enabled />\n\n  <!-- 该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 -->\n\n  <updatePolicy />\n\n  <!-- 当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 -->\n\n  <checksumPolicy />\n\n  </releases>\n\n  <!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 -->\n\n  <snapshots>\n\n  <enabled /><updatePolicy /><checksumPolicy />\n\n  </snapshots>\n\n  <!-- 远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 -->\n\n  <id> banseon-repository-proxy </id>\n\n  <!-- 远程仓库名称 -->\n\n  <name> banseon-repository-proxy </name>\n\n  <!-- 远程仓库URL，按protocol://hostname/path形式 -->\n\n  <url> http://192.168.1.169:9999/repository/ </url>\n\n  <!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 -->\n\n  <layout> default </layout>\n\n  </repository>\n\n  </repositories>\n\n  <!-- 发现插件的远程仓库列表，这些插件用于构建和报表 -->\n\n  <pluginRepositories>\n\n  <!-- 包含需要连接到远程插件仓库的信息.参见repositories/repository元素 -->\n\n  <pluginRepository>\n\n\n\n  </pluginRepository>\n\n  </pluginRepositories>\n\n\n\n  <!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 -->\n\n  <dependencies>\n\n  <dependency>\n\n  <!-- 依赖的group ID -->\n\n  <groupId> org.apache.maven </groupId>\n\n  <!-- 依赖的artifact ID -->\n\n  <artifactId> maven-artifact </artifactId>\n\n  <!-- 依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 -->\n\n  <version> 3.8.1 </version>\n\n  <!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应，尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在plugin里定义新的类型。所以前面的类型的例子不完整。 -->\n\n  <type> jar </type>\n\n  <!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 -->\n\n  <classifier></classifier>\n\n  <!-- 依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。\n\n  - compile ：默认范围，用于编译\n\n  - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath\n\n  - runtime: 在执行时需要使用\n\n  - test: 用于test任务时使用\n\n  - system: 需要外在提供相应的元素。通过systemPath来取得\n\n  - systemPath: 仅用于范围为system。提供相应的路径\n\n  - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 -->\n\n  <scope> test </scope>\n\n  <!-- 仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如${java.home}。 -->\n\n  <systemPath></systemPath>\n\n  <!-- 当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 -->\n\n  <exclusions>\n\n  <exclusion>\n\n  <artifactId> spring-core </artifactId>\n\n  <groupId> org.springframework </groupId>\n\n  </exclusion>\n\n  </exclusions>\n\n  <!-- 可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 -->\n\n  <optional> true </optional>\n\n  </dependency>\n\n  </dependencies>\n\n  <!-- 不赞成使用. 现在Maven忽略该元素. -->\n\n  <reports></reports>\n\n  <!-- 该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 -->\n\n  <reporting>\n\n  <!-- true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。 -->\n\n  <excludeDefaults />\n\n  <!-- 所有产生的报表存放到哪里。默认值是${project.build.directory}/site。 -->\n\n  <outputDirectory />\n\n  <!-- 使用的报表插件和他们的配置。 -->\n\n  <plugins>\n\n  <!-- plugin元素包含描述报表插件需要的信息 -->\n\n  <plugin>\n\n  <!-- 报表插件在仓库里的group ID -->\n\n  <groupId />\n\n  <!-- 报表插件在仓库里的artifact ID -->\n\n  <artifactId />\n\n  <!-- 被使用的报表插件的版本（或版本范围） -->\n\n  <version />\n\n  <!-- 任何配置是否被传播到子项目 -->\n\n  <inherited />\n\n  <!-- 报表插件的配置 -->\n\n  <configuration />\n\n  <!-- 一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 -->\n\n  <reportSets>\n\n  <!-- 表示报表的一个集合，以及产生该集合的配置 -->\n\n  <reportSet>\n\n  <!-- 报表集合的唯一标识符，POM继承时用到 -->\n\n  <id />\n\n  <!-- 产生报表集合时，被使用的报表的配置 -->\n\n  <configuration />\n\n  <!-- 配置是否被继承到子POMs -->\n\n  <inherited />\n\n  <!-- 这个集合里使用到哪些报表 -->\n\n  <reports />\n\n  </reportSet>\n\n  </reportSets>\n\n  </plugin>\n\n  </plugins>\n\n  </reporting>\n\n  <!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID匹配到这里的依赖，并使用这里的依赖信息。 -->\n\n  <dependencyManagement>\n\n  <dependencies>\n\n  <!-- 参见dependencies/dependency元素 -->\n\n  <dependency>\n\n\n\n  </dependency>\n\n  </dependencies>\n\n  </dependencyManagement>\n\n  <!-- 项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 -->\n\n  <distributionManagement>\n\n  <!-- 部署项目产生的构件到远程仓库需要的信息 -->\n\n  <repository>\n\n  <!-- 是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 -->\n\n  <uniqueVersion />\n\n  <id> banseon-maven2 </id>\n\n  <name> banseon maven2 </name>\n\n  <url> file://${basedir}/target/deploy </url>\n\n  <layout />\n\n  </repository>\n\n  <!-- 构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 -->\n\n  <snapshotRepository>\n\n  <uniqueVersion />\n\n  <id> banseon-maven2 </id>\n\n  <name> Banseon-maven2 Snapshot Repository </name>\n\n  <url> scp://svn.baidu.com/banseon:/usr/local/maven-snapshot </url>\n\n  <layout />\n\n  </snapshotRepository>\n\n  <!-- 部署项目的网站需要的信息 -->\n\n  <site>\n\n  <!-- 部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 -->\n\n  <id> banseon-site </id>\n\n  <!-- 部署位置的名称 -->\n\n  <name> business api website </name>\n\n  <!-- 部署位置的URL，按protocol://hostname/path形式 -->\n\n  <url>\n\n  scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web\n\n  </url>\n\n  </site>\n\n  <!-- 项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 -->\n\n  <downloadUrl />\n\n  <!-- 如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 -->\n\n  <relocation>\n\n  <!-- 构件新的group ID -->\n\n  <groupId />\n\n  <!-- 构件新的artifact ID -->\n\n  <artifactId />\n\n  <!-- 构件新的版本号 -->\n\n  <version />\n\n  <!-- 显示给用户的，关于移动的额外信息，例如原因。 -->\n\n  <message />\n\n  </relocation>\n\n  <!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部署），verified（被核实时正确的和最终的）。 -->\n\n  <status />\n\n  </distributionManagement>\n\n  <!-- 以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是<name>value</name>。 -->\n\n  <properties />\n\n</project>\n```","source":"_posts/28POM文件详解.md","raw":"---\ntitle: POM文件详解\ndate: 2018-01-15 20:43:01\ntags:\n---\n\n在Java语言中，框架通常是海量的，如果盲目的去学习某个框架，最终的结果就是两败俱伤，学习的人白白浪费了时间和精力，\n而新的框架又在不断产生，可能今天学习的框架，明天又出了一个更好的。但是有些软件却是非常值得“深究”的，\n因为他/她总会在某个特定的时刻，让人爱的无法自拔。。。。\n要学习maven，首先要爱上它，我爱上它的原因是实在无法忍受种种框架依赖的种种jar包。在使用maven以前，\n例如搭建一个非常熟悉的SSH框架，就首先要去Struts、Spring、Hibernate下载各个sdk，然后参照各自的help文档，来“集合”需要的jar，\n其中有许多jar只会在特定的条件下才会用到，通常情况下都用不到。而且，有些jar属于第三方的jar，\n这意味着必须得自己找那些jar，例如commons-xxxx系列。所有jar集齐后，在排除冲突，最后将搭好的框架放在eclipse里测试运行，\n再看看有哪些问题。这样“千辛万苦”搭好的环境，可能随着其中一个组件版本的变化，例如spring版本的升级，又需要重新在来一次。\n而且最后搭好的框架光jar可能就几百M。每次向svn上传时，就会特别悲伤。。。。\n<!--more-->\n\n```\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd \">\n\n  <!-- 父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。 -->\n  <parent>\n    <!-- 被继承的父项目的构件标识符 -->\n    <artifactId />\n    <!-- 被继承的父项目的全球唯一标识符 -->\n    <groupId />\n    <!-- 被继承的父项目的版本 -->\n    <version />\n    <!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 -->\n    <relativePath />\n  </parent>\n\n  <!-- 声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 -->\n  <modelVersion> 4.0.0 </modelVersion>\n  <!-- 项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app -->\n  <groupId> asia.banseon </groupId>\n  <!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源码，二进制发布和WARs等。 -->\n  <artifactId> banseon-maven2 </artifactId>\n  <!-- 项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 -->\n  <packaging> jar </packaging>\n  <!-- 项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 -->\n  <version> 1.0-SNAPSHOT </version>\n  <!-- 项目的名称, Maven产生的文档用 -->\n  <name> banseon-maven </name>\n  <!-- 项目主页的URL, Maven产生的文档用 -->\n  <url> http://www.baidu.com/banseon </url>\n  <!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 -->\n  <description> A maven project to study maven. </description>\n\n  <!-- 描述了这个项目构建环境中的前提条件。 -->\n  <prerequisites>\n    <!-- 构建该项目或使用该插件所需要的Maven的最低版本 -->\n    <maven />\n  </prerequisites>\n\n  <!-- 项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira -->\n  <issueManagement>\n    <!-- 问题管理系统（例如jira）的名字， -->\n    <system> jira </system>\n    <!-- 该项目使用的问题管理系统的URL -->\n    <url> http://jira.baidu.com/banseon </url>\n  </issueManagement>\n\n  <!-- 项目持续集成信息 -->\n  <ciManagement>\n    <!-- 持续集成系统的名字，例如continuum -->\n    <system />\n    <!-- 该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 -->\n    <url />\n    <!-- 构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） -->\n    <notifiers>\n      <!-- 配置一种方式，当构建中断时，以该方式通知用户/开发者 -->\n      <notifier>\n        <!-- 传送通知的途径 -->\n        <type />\n        <!-- 发生错误时是否通知 -->\n        <sendOnError />\n        <!-- 构建失败时是否通知 -->\n        <sendOnFailure />\n        <!-- 构建成功时是否通知 -->\n        <sendOnSuccess />\n        <!-- 发生警告时是否通知 -->\n        <sendOnWarning />\n        <!-- 不赞成使用。通知发送到哪里 -->\n        <address />\n        <!-- 扩展配置项 -->\n        <configuration />\n      </notifier>\n    </notifiers>\n  </ciManagement>\n\n  <!-- 项目创建年份，4位数字。当产生版权信息时需要使用这个值。 -->\n  <inceptionYear />\n\n  <!-- 项目相关邮件列表信息 -->\n  <mailingLists>\n    <!-- 该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 -->\n    <mailingList>\n      <!-- 邮件的名称 -->\n      <name> Demo </name>\n      <!-- 发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 -->\n      <post> banseon@126.com </post>\n      <!-- 订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 -->\n      <subscribe> banseon@126.com </subscribe>\n      <!-- 取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 -->\n      <unsubscribe> banseon@126.com </unsubscribe>\n      <!-- 你可以浏览邮件信息的URL -->\n      <archive> http:/hi.baidu.com/banseon/demo/dev/ </archive>\n    </mailingList>\n  </mailingLists>\n\n  <!-- 项目开发者列表 -->\n  <developers>\n    <!-- 某个项目开发者的信息 -->\n    <developer>\n      <!-- SCM里项目开发者的唯一标识符 -->\n      <id> HELLO WORLD </id>\n      <!-- 项目开发者的全名 -->\n      <name> banseon </name>\n      <!-- 项目开发者的email -->\n      <email> banseon@126.com </email>\n      <!-- 项目开发者的主页的URL -->\n      <url />\n      <!-- 项目开发者在项目中扮演的角色，角色元素描述了各种角色 -->\n      <roles>\n        <role> Project Manager </role>\n        <role> Architect </role>\n      </roles>\n      <!-- 项目开发者所属组织 -->\n      <organization> demo </organization>\n      <!-- 项目开发者所属组织的URL -->\n      <organizationUrl> http://hi.baidu.com/banseon </organizationUrl>\n      <!-- 项目开发者属性，如即时消息如何处理等 -->\n      <properties>\n        <dept> No </dept>\n      </properties>\n      <!-- 项目开发者所在时区， -11到12范围内的整数。 -->\n      <timezone> -5 </timezone>\n    </developer>\n  </developers>\n\n  <!-- 项目的其他贡献者列表 -->\n  <contributors>\n    <!-- 项目的其他贡献者。参见developers/developer元素 -->\n    <contributor>\n      <name />\n      <email />\n      <url />\n      <organization />\n      <organizationUrl />\n      <roles />\n      <timezone />\n      <properties />\n    </contributor>\n  </contributors>\n\n  <!-- 该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 -->\n  <licenses>\n    <!-- 描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 -->\n    <license>\n    <!-- license用于法律上的名称 -->\n    <name> Apache 2 </name>\n    <!-- 官方的license正文页面的URL -->\n    <url> http://www.baidu.com/banseon/LICENSE-2.0.txt </url>\n    <!-- 项目分发的主要方式：\n    repo，可以从Maven库下载\n    manual， 用户必须手动下载和安装依赖 -->\n    <distribution> repo </distribution>\n    <!-- 关于license的补充信息 -->\n    <comments> A business-friendly OSS license </comments>\n    </license>\n  </licenses>\n\n  <!-- SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 -->\n  <scm>\n    <!-- SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 -->\n    <connection> scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk) </connection>\n    <!-- 给开发者使用的，类似connection元素。即该连接不仅仅只读 -->\n    <developerConnection> scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk </developerConnection>\n    <!-- 当前代码的标签，在开发阶段默认为HEAD -->\n    <tag />\n    <!-- 指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 -->\n    <url> http://svn.baidu.com/banseon </url>\n  </scm>\n\n  <!-- 描述项目所属组织的各种属性。Maven产生的文档用 -->\n  <organization>\n    <!-- 组织的全名 -->\n    <name> demo </name>\n    <!-- 组织主页的URL -->\n    <url> http://www.baidu.com/banseon </url>\n  </organization>\n\n  <!-- 构建项目需要的信息 -->\n  <build>\n  <!-- 该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 -->\n  <sourceDirectory />\n  <!-- 该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 -->\n  <scriptSourceDirectory />\n  <!-- 该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 -->\n  <testSourceDirectory />\n  <!-- 被编译过的应用程序class文件存放的目录。 -->\n  <outputDirectory />\n  <!-- 被编译过的测试class文件存放的目录。 -->\n  <testOutputDirectory />\n  <!-- 使用来自该项目的一系列构建扩展 -->\n  <extensions>\n    <!-- 描述使用到的构建扩展。 -->\n    <extension>\n      <!-- 构建扩展的groupId -->\n      <groupId />\n      <!-- 构建扩展的artifactId -->\n      <artifactId />\n      <!-- 构建扩展的版本 -->\n      <version />\n    </extension>\n  </extensions>\n  <!-- 当项目没有规定目标（Maven2 叫做阶段）时的默认值 -->\n  <defaultGoal />\n  <!-- 这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 -->\n  <resources>\n    <!-- 这个元素描述了项目相关或测试相关的所有资源路径 -->\n    <resource>\n    <!-- 描述了资源的目标路径。该路径相对target/classes目录（例如${project.build.outputDirectory}）。举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven/messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 -->\n    <targetPath />\n    <!-- 是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 -->\n    <filtering />\n    <!-- 描述存放资源的目录，该路径相对POM路径 -->\n    <directory />\n    <!-- 包含的模式列表，例如**/*.xml. -->\n    <includes />\n    <!-- 排除的模式列表，例如**/*.xml -->\n    <excludes />\n    </resource>\n  </resources>\n  <!-- 这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 -->\n  <testResources>\n    <!-- 这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 -->\n    <testResource>\n    <targetPath /><filtering /><directory /><includes /><excludes />\n    </testResource>\n  </testResources>\n  <!-- 构建产生的所有文件存放的目录 -->\n  <directory />\n  <!-- 产生的构件的文件名，默认值是${artifactId}-${version}。 -->\n  <finalName />\n  <!-- 当filtering开关打开时，使用到的过滤器属性文件列表 -->\n  <filters />\n  <!-- 子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 -->\n  <pluginManagement>\n  <!-- 使用的插件列表 。 -->\n  <plugins>\n  <!-- plugin元素包含描述插件所需要的信息。 -->\n  <plugin>\n  <!-- 插件在仓库里的group ID -->\n  <groupId />\n  <!-- 插件在仓库里的artifact ID -->\n  <artifactId />\n  <!-- 被使用的插件的版本（或版本范围） -->\n  <version />\n  <!-- 是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 -->\n  <extensions />\n  <!-- 在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 -->\n  <executions>\n  <!-- execution元素包含了插件执行需要的信息 -->\n  <execution>\n\n  <!-- 执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 -->\n\n  <id />\n\n  <!-- 绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 -->\n\n  <phase />\n\n  <!-- 配置的执行目标 -->\n\n  <goals />\n\n  <!-- 配置是否被传播到子POM -->\n\n  <inherited />\n\n  <!-- 作为DOM对象的配置 -->\n\n  <configuration />\n\n  </execution>\n\n  </executions>\n\n  <!-- 项目引入插件所需要的额外依赖 -->\n\n  <dependencies>\n\n  <!-- 参见dependencies/dependency元素 -->\n\n  <dependency>\n\n\n\n  </dependency>\n\n  </dependencies>\n\n  <!-- 任何配置是否被传播到子项目 -->\n\n  <inherited />\n\n  <!-- 作为DOM对象的配置 -->\n\n  <configuration />\n\n  </plugin>\n\n  </plugins>\n\n  </pluginManagement>\n\n  <!-- 使用的插件列表 -->\n\n  <plugins>\n\n  <!-- 参见build/pluginManagement/plugins/plugin元素 -->\n\n  <plugin>\n\n  <groupId /><artifactId /><version /><extensions />\n\n  <executions>\n\n  <execution>\n\n  <id /><phase /><goals /><inherited /><configuration />\n\n  </execution>\n\n  </executions>\n\n  <dependencies>\n\n  <!-- 参见dependencies/dependency元素 -->\n\n  <dependency>\n\n\n\n  </dependency>\n\n  </dependencies>\n\n  <goals /><inherited /><configuration />\n\n  </plugin>\n\n  </plugins>\n\n  </build>\n\n  <!-- 在列的项目构建profile，如果被激活，会修改构建处理 -->\n\n  <profiles>\n\n  <!-- 根据环境参数或命令行参数激活某个构建处理 -->\n\n  <profile>\n\n  <!-- 构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 -->\n\n  <id />\n\n  <!-- 自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它\n\n  能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 -->\n\n  <activation>\n\n  <!-- profile默认是否激活的标志 -->\n\n  <activeByDefault />\n\n  <!-- 当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 -->\n\n  <jdk />\n\n  <!-- 当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 -->\n\n  <os>\n\n  <!-- 激活profile的操作系统的名字 -->\n\n  <name> Windows XP </name>\n\n  <!-- 激活profile的操作系统所属家族(如 'windows') -->\n\n  <family> Windows </family>\n\n  <!-- 激活profile的操作系统体系结构 -->\n\n  <arch> x86 </arch>\n\n  <!-- 激活profile的操作系统版本 -->\n\n  <version> 5.1.2600 </version>\n\n  </os>\n\n  <!-- 如果Maven检测到某一个属性（其值可以在POM中通过${名称}引用），其拥有对应的名称和值，Profile就会被激活。如果值\n\n  字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 -->\n\n  <property>\n\n  <!-- 激活profile的属性的名称 -->\n\n  <name> mavenVersion </name>\n\n  <!-- 激活profile的属性的值 -->\n\n  <value> 2.0.3 </value>\n\n  </property>\n\n  <!-- 提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活\n\n  profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 -->\n\n  <file>\n\n  <!-- 如果指定的文件存在，则激活profile。 -->\n\n  <exists> /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ </exists>\n\n  <!-- 如果指定的文件不存在，则激活profile。 -->\n\n  <missing> /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ </missing>\n\n  </file>\n\n  </activation>\n\n  <!-- 构建项目所需要的信息。参见build元素 -->\n\n  <build>\n\n  <defaultGoal />\n\n  <resources>\n\n  <resource>\n\n  <targetPath /><filtering /><directory /><includes /><excludes />\n\n  </resource>\n\n  </resources>\n\n  <testResources>\n\n  <testResource>\n\n  <targetPath /><filtering /><directory /><includes /><excludes />\n\n  </testResource>\n\n  </testResources>\n\n  <directory /><finalName /><filters />\n\n  <pluginManagement>\n\n  <plugins>\n\n  <!-- 参见build/pluginManagement/plugins/plugin元素 -->\n\n  <plugin>\n\n  <groupId /><artifactId /><version /><extensions />\n\n  <executions>\n\n  <execution>\n\n  <id /><phase /><goals /><inherited /><configuration />\n\n  </execution>\n\n  </executions>\n\n  <dependencies>\n\n  <!-- 参见dependencies/dependency元素 -->\n\n  <dependency>\n\n\n\n  </dependency>\n\n  </dependencies>\n\n  <goals /><inherited /><configuration />\n\n  </plugin>\n\n  </plugins>\n\n  </pluginManagement>\n\n  <plugins>\n\n  <!-- 参见build/pluginManagement/plugins/plugin元素 -->\n\n  <plugin>\n\n  <groupId /><artifactId /><version /><extensions />\n\n  <executions>\n\n  <execution>\n\n  <id /><phase /><goals /><inherited /><configuration />\n\n  </execution>\n\n  </executions>\n\n  <dependencies>\n\n  <!-- 参见dependencies/dependency元素 -->\n\n  <dependency>\n\n\n\n  </dependency>\n\n  </dependencies>\n\n  <goals /><inherited /><configuration />\n\n  </plugin>\n\n  </plugins>\n\n  </build>\n\n  <!-- 模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 -->\n\n  <modules />\n\n  <!-- 发现依赖和扩展的远程仓库列表。 -->\n\n  <repositories>\n\n  <!-- 参见repositories/repository元素 -->\n\n  <repository>\n\n  <releases>\n\n  <enabled /><updatePolicy /><checksumPolicy />\n\n  </releases>\n\n  <snapshots>\n\n  <enabled /><updatePolicy /><checksumPolicy />\n\n  </snapshots>\n\n  <id /><name /><url /><layout />\n\n  </repository>\n\n  </repositories>\n\n  <!-- 发现插件的远程仓库列表，这些插件用于构建和报表 -->\n\n  <pluginRepositories>\n\n  <!-- 包含需要连接到远程插件仓库的信息.参见repositories/repository元素 -->\n\n  <pluginRepository>\n\n  <releases>\n\n  <enabled /><updatePolicy /><checksumPolicy />\n\n  </releases>\n\n  <snapshots>\n\n  <enabled /><updatePolicy /><checksumPolicy />\n\n  </snapshots>\n\n  <id /><name /><url /><layout />\n\n  </pluginRepository>\n\n  </pluginRepositories>\n\n  <!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 -->\n\n  <dependencies>\n\n  <!-- 参见dependencies/dependency元素 -->\n\n  <dependency>\n\n\n\n  </dependency>\n\n  </dependencies>\n\n  <!-- 不赞成使用. 现在Maven忽略该元素. -->\n\n  <reports />\n\n  <!-- 该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 -->\n\n  <reporting>\n\n\n\n  </reporting>\n\n  <!-- 参见dependencyManagement元素 -->\n\n  <dependencyManagement>\n\n  <dependencies>\n\n  <!-- 参见dependencies/dependency元素 -->\n\n  <dependency>\n\n\n\n  </dependency>\n\n  </dependencies>\n\n  </dependencyManagement>\n\n  <!-- 参见distributionManagement元素 -->\n\n  <distributionManagement>\n\n\n\n  </distributionManagement>\n\n  <!-- 参见properties元素 -->\n\n  <properties />\n\n  </profile>\n\n  </profiles>\n\n  <!-- 模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 -->\n\n  <modules />\n\n  <!-- 发现依赖和扩展的远程仓库列表。 -->\n\n  <repositories>\n\n  <!-- 包含需要连接到远程仓库的信息 -->\n\n  <repository>\n\n  <!-- 如何处理远程仓库里发布版本的下载 -->\n\n  <releases>\n\n  <!-- true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 -->\n\n  <enabled />\n\n  <!-- 该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 -->\n\n  <updatePolicy />\n\n  <!-- 当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 -->\n\n  <checksumPolicy />\n\n  </releases>\n\n  <!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 -->\n\n  <snapshots>\n\n  <enabled /><updatePolicy /><checksumPolicy />\n\n  </snapshots>\n\n  <!-- 远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 -->\n\n  <id> banseon-repository-proxy </id>\n\n  <!-- 远程仓库名称 -->\n\n  <name> banseon-repository-proxy </name>\n\n  <!-- 远程仓库URL，按protocol://hostname/path形式 -->\n\n  <url> http://192.168.1.169:9999/repository/ </url>\n\n  <!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 -->\n\n  <layout> default </layout>\n\n  </repository>\n\n  </repositories>\n\n  <!-- 发现插件的远程仓库列表，这些插件用于构建和报表 -->\n\n  <pluginRepositories>\n\n  <!-- 包含需要连接到远程插件仓库的信息.参见repositories/repository元素 -->\n\n  <pluginRepository>\n\n\n\n  </pluginRepository>\n\n  </pluginRepositories>\n\n\n\n  <!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 -->\n\n  <dependencies>\n\n  <dependency>\n\n  <!-- 依赖的group ID -->\n\n  <groupId> org.apache.maven </groupId>\n\n  <!-- 依赖的artifact ID -->\n\n  <artifactId> maven-artifact </artifactId>\n\n  <!-- 依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 -->\n\n  <version> 3.8.1 </version>\n\n  <!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应，尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在plugin里定义新的类型。所以前面的类型的例子不完整。 -->\n\n  <type> jar </type>\n\n  <!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 -->\n\n  <classifier></classifier>\n\n  <!-- 依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。\n\n  - compile ：默认范围，用于编译\n\n  - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath\n\n  - runtime: 在执行时需要使用\n\n  - test: 用于test任务时使用\n\n  - system: 需要外在提供相应的元素。通过systemPath来取得\n\n  - systemPath: 仅用于范围为system。提供相应的路径\n\n  - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 -->\n\n  <scope> test </scope>\n\n  <!-- 仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如${java.home}。 -->\n\n  <systemPath></systemPath>\n\n  <!-- 当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 -->\n\n  <exclusions>\n\n  <exclusion>\n\n  <artifactId> spring-core </artifactId>\n\n  <groupId> org.springframework </groupId>\n\n  </exclusion>\n\n  </exclusions>\n\n  <!-- 可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 -->\n\n  <optional> true </optional>\n\n  </dependency>\n\n  </dependencies>\n\n  <!-- 不赞成使用. 现在Maven忽略该元素. -->\n\n  <reports></reports>\n\n  <!-- 该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 -->\n\n  <reporting>\n\n  <!-- true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。 -->\n\n  <excludeDefaults />\n\n  <!-- 所有产生的报表存放到哪里。默认值是${project.build.directory}/site。 -->\n\n  <outputDirectory />\n\n  <!-- 使用的报表插件和他们的配置。 -->\n\n  <plugins>\n\n  <!-- plugin元素包含描述报表插件需要的信息 -->\n\n  <plugin>\n\n  <!-- 报表插件在仓库里的group ID -->\n\n  <groupId />\n\n  <!-- 报表插件在仓库里的artifact ID -->\n\n  <artifactId />\n\n  <!-- 被使用的报表插件的版本（或版本范围） -->\n\n  <version />\n\n  <!-- 任何配置是否被传播到子项目 -->\n\n  <inherited />\n\n  <!-- 报表插件的配置 -->\n\n  <configuration />\n\n  <!-- 一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 -->\n\n  <reportSets>\n\n  <!-- 表示报表的一个集合，以及产生该集合的配置 -->\n\n  <reportSet>\n\n  <!-- 报表集合的唯一标识符，POM继承时用到 -->\n\n  <id />\n\n  <!-- 产生报表集合时，被使用的报表的配置 -->\n\n  <configuration />\n\n  <!-- 配置是否被继承到子POMs -->\n\n  <inherited />\n\n  <!-- 这个集合里使用到哪些报表 -->\n\n  <reports />\n\n  </reportSet>\n\n  </reportSets>\n\n  </plugin>\n\n  </plugins>\n\n  </reporting>\n\n  <!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID匹配到这里的依赖，并使用这里的依赖信息。 -->\n\n  <dependencyManagement>\n\n  <dependencies>\n\n  <!-- 参见dependencies/dependency元素 -->\n\n  <dependency>\n\n\n\n  </dependency>\n\n  </dependencies>\n\n  </dependencyManagement>\n\n  <!-- 项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 -->\n\n  <distributionManagement>\n\n  <!-- 部署项目产生的构件到远程仓库需要的信息 -->\n\n  <repository>\n\n  <!-- 是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 -->\n\n  <uniqueVersion />\n\n  <id> banseon-maven2 </id>\n\n  <name> banseon maven2 </name>\n\n  <url> file://${basedir}/target/deploy </url>\n\n  <layout />\n\n  </repository>\n\n  <!-- 构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 -->\n\n  <snapshotRepository>\n\n  <uniqueVersion />\n\n  <id> banseon-maven2 </id>\n\n  <name> Banseon-maven2 Snapshot Repository </name>\n\n  <url> scp://svn.baidu.com/banseon:/usr/local/maven-snapshot </url>\n\n  <layout />\n\n  </snapshotRepository>\n\n  <!-- 部署项目的网站需要的信息 -->\n\n  <site>\n\n  <!-- 部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 -->\n\n  <id> banseon-site </id>\n\n  <!-- 部署位置的名称 -->\n\n  <name> business api website </name>\n\n  <!-- 部署位置的URL，按protocol://hostname/path形式 -->\n\n  <url>\n\n  scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web\n\n  </url>\n\n  </site>\n\n  <!-- 项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 -->\n\n  <downloadUrl />\n\n  <!-- 如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 -->\n\n  <relocation>\n\n  <!-- 构件新的group ID -->\n\n  <groupId />\n\n  <!-- 构件新的artifact ID -->\n\n  <artifactId />\n\n  <!-- 构件新的版本号 -->\n\n  <version />\n\n  <!-- 显示给用户的，关于移动的额外信息，例如原因。 -->\n\n  <message />\n\n  </relocation>\n\n  <!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部署），verified（被核实时正确的和最终的）。 -->\n\n  <status />\n\n  </distributionManagement>\n\n  <!-- 以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是<name>value</name>。 -->\n\n  <properties />\n\n</project>\n```","slug":"28POM文件详解","published":1,"updated":"2018-01-30T03:01:08.357Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tcak001pa7xwnm7xvci9","content":"<p>在Java语言中，框架通常是海量的，如果盲目的去学习某个框架，最终的结果就是两败俱伤，学习的人白白浪费了时间和精力，<br>而新的框架又在不断产生，可能今天学习的框架，明天又出了一个更好的。但是有些软件却是非常值得“深究”的，<br>因为他/她总会在某个特定的时刻，让人爱的无法自拔。。。。<br>要学习maven，首先要爱上它，我爱上它的原因是实在无法忍受种种框架依赖的种种jar包。在使用maven以前，<br>例如搭建一个非常熟悉的SSH框架，就首先要去Struts、Spring、Hibernate下载各个sdk，然后参照各自的help文档，来“集合”需要的jar，<br>其中有许多jar只会在特定的条件下才会用到，通常情况下都用不到。而且，有些jar属于第三方的jar，<br>这意味着必须得自己找那些jar，例如commons-xxxx系列。所有jar集齐后，在排除冲突，最后将搭好的框架放在eclipse里测试运行，<br>再看看有哪些问题。这样“千辛万苦”搭好的环境，可能随着其中一个组件版本的变化，例如spring版本的升级，又需要重新在来一次。<br>而且最后搭好的框架光jar可能就几百M。每次向svn上传时，就会特别悲伤。。。。<br><a id=\"more\"></a></p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div><div class=\"line\">338</div><div class=\"line\">339</div><div class=\"line\">340</div><div class=\"line\">341</div><div class=\"line\">342</div><div class=\"line\">343</div><div class=\"line\">344</div><div class=\"line\">345</div><div class=\"line\">346</div><div class=\"line\">347</div><div class=\"line\">348</div><div class=\"line\">349</div><div class=\"line\">350</div><div class=\"line\">351</div><div class=\"line\">352</div><div class=\"line\">353</div><div class=\"line\">354</div><div class=\"line\">355</div><div class=\"line\">356</div><div class=\"line\">357</div><div class=\"line\">358</div><div class=\"line\">359</div><div class=\"line\">360</div><div class=\"line\">361</div><div class=\"line\">362</div><div class=\"line\">363</div><div class=\"line\">364</div><div class=\"line\">365</div><div class=\"line\">366</div><div class=\"line\">367</div><div class=\"line\">368</div><div class=\"line\">369</div><div class=\"line\">370</div><div class=\"line\">371</div><div class=\"line\">372</div><div class=\"line\">373</div><div class=\"line\">374</div><div class=\"line\">375</div><div class=\"line\">376</div><div class=\"line\">377</div><div class=\"line\">378</div><div class=\"line\">379</div><div class=\"line\">380</div><div class=\"line\">381</div><div class=\"line\">382</div><div class=\"line\">383</div><div class=\"line\">384</div><div class=\"line\">385</div><div class=\"line\">386</div><div class=\"line\">387</div><div class=\"line\">388</div><div class=\"line\">389</div><div class=\"line\">390</div><div class=\"line\">391</div><div class=\"line\">392</div><div class=\"line\">393</div><div class=\"line\">394</div><div class=\"line\">395</div><div class=\"line\">396</div><div class=\"line\">397</div><div class=\"line\">398</div><div class=\"line\">399</div><div class=\"line\">400</div><div class=\"line\">401</div><div class=\"line\">402</div><div class=\"line\">403</div><div class=\"line\">404</div><div class=\"line\">405</div><div class=\"line\">406</div><div class=\"line\">407</div><div class=\"line\">408</div><div class=\"line\">409</div><div class=\"line\">410</div><div class=\"line\">411</div><div class=\"line\">412</div><div class=\"line\">413</div><div class=\"line\">414</div><div class=\"line\">415</div><div class=\"line\">416</div><div class=\"line\">417</div><div class=\"line\">418</div><div class=\"line\">419</div><div class=\"line\">420</div><div class=\"line\">421</div><div class=\"line\">422</div><div class=\"line\">423</div><div class=\"line\">424</div><div class=\"line\">425</div><div class=\"line\">426</div><div class=\"line\">427</div><div class=\"line\">428</div><div class=\"line\">429</div><div class=\"line\">430</div><div class=\"line\">431</div><div class=\"line\">432</div><div class=\"line\">433</div><div class=\"line\">434</div><div class=\"line\">435</div><div class=\"line\">436</div><div class=\"line\">437</div><div class=\"line\">438</div><div class=\"line\">439</div><div class=\"line\">440</div><div class=\"line\">441</div><div class=\"line\">442</div><div class=\"line\">443</div><div class=\"line\">444</div><div class=\"line\">445</div><div class=\"line\">446</div><div class=\"line\">447</div><div class=\"line\">448</div><div class=\"line\">449</div><div class=\"line\">450</div><div class=\"line\">451</div><div class=\"line\">452</div><div class=\"line\">453</div><div class=\"line\">454</div><div class=\"line\">455</div><div class=\"line\">456</div><div class=\"line\">457</div><div class=\"line\">458</div><div class=\"line\">459</div><div class=\"line\">460</div><div class=\"line\">461</div><div class=\"line\">462</div><div class=\"line\">463</div><div class=\"line\">464</div><div class=\"line\">465</div><div class=\"line\">466</div><div class=\"line\">467</div><div class=\"line\">468</div><div class=\"line\">469</div><div class=\"line\">470</div><div class=\"line\">471</div><div class=\"line\">472</div><div class=\"line\">473</div><div class=\"line\">474</div><div class=\"line\">475</div><div class=\"line\">476</div><div class=\"line\">477</div><div class=\"line\">478</div><div class=\"line\">479</div><div class=\"line\">480</div><div class=\"line\">481</div><div class=\"line\">482</div><div class=\"line\">483</div><div class=\"line\">484</div><div class=\"line\">485</div><div class=\"line\">486</div><div class=\"line\">487</div><div class=\"line\">488</div><div class=\"line\">489</div><div class=\"line\">490</div><div class=\"line\">491</div><div class=\"line\">492</div><div class=\"line\">493</div><div class=\"line\">494</div><div class=\"line\">495</div><div class=\"line\">496</div><div class=\"line\">497</div><div class=\"line\">498</div><div class=\"line\">499</div><div class=\"line\">500</div><div class=\"line\">501</div><div class=\"line\">502</div><div class=\"line\">503</div><div class=\"line\">504</div><div class=\"line\">505</div><div class=\"line\">506</div><div class=\"line\">507</div><div class=\"line\">508</div><div class=\"line\">509</div><div class=\"line\">510</div><div class=\"line\">511</div><div class=\"line\">512</div><div class=\"line\">513</div><div class=\"line\">514</div><div class=\"line\">515</div><div class=\"line\">516</div><div class=\"line\">517</div><div class=\"line\">518</div><div class=\"line\">519</div><div class=\"line\">520</div><div class=\"line\">521</div><div class=\"line\">522</div><div class=\"line\">523</div><div class=\"line\">524</div><div class=\"line\">525</div><div class=\"line\">526</div><div class=\"line\">527</div><div class=\"line\">528</div><div class=\"line\">529</div><div class=\"line\">530</div><div class=\"line\">531</div><div class=\"line\">532</div><div class=\"line\">533</div><div class=\"line\">534</div><div class=\"line\">535</div><div class=\"line\">536</div><div class=\"line\">537</div><div class=\"line\">538</div><div class=\"line\">539</div><div class=\"line\">540</div><div class=\"line\">541</div><div class=\"line\">542</div><div class=\"line\">543</div><div class=\"line\">544</div><div class=\"line\">545</div><div class=\"line\">546</div><div class=\"line\">547</div><div class=\"line\">548</div><div class=\"line\">549</div><div class=\"line\">550</div><div class=\"line\">551</div><div class=\"line\">552</div><div class=\"line\">553</div><div class=\"line\">554</div><div class=\"line\">555</div><div class=\"line\">556</div><div class=\"line\">557</div><div class=\"line\">558</div><div class=\"line\">559</div><div class=\"line\">560</div><div class=\"line\">561</div><div class=\"line\">562</div><div class=\"line\">563</div><div class=\"line\">564</div><div class=\"line\">565</div><div class=\"line\">566</div><div class=\"line\">567</div><div class=\"line\">568</div><div class=\"line\">569</div><div class=\"line\">570</div><div class=\"line\">571</div><div class=\"line\">572</div><div class=\"line\">573</div><div class=\"line\">574</div><div class=\"line\">575</div><div class=\"line\">576</div><div class=\"line\">577</div><div class=\"line\">578</div><div class=\"line\">579</div><div class=\"line\">580</div><div class=\"line\">581</div><div class=\"line\">582</div><div class=\"line\">583</div><div class=\"line\">584</div><div class=\"line\">585</div><div class=\"line\">586</div><div class=\"line\">587</div><div class=\"line\">588</div><div class=\"line\">589</div><div class=\"line\">590</div><div class=\"line\">591</div><div class=\"line\">592</div><div class=\"line\">593</div><div class=\"line\">594</div><div class=\"line\">595</div><div class=\"line\">596</div><div class=\"line\">597</div><div class=\"line\">598</div><div class=\"line\">599</div><div class=\"line\">600</div><div class=\"line\">601</div><div class=\"line\">602</div><div class=\"line\">603</div><div class=\"line\">604</div><div class=\"line\">605</div><div class=\"line\">606</div><div class=\"line\">607</div><div class=\"line\">608</div><div class=\"line\">609</div><div class=\"line\">610</div><div class=\"line\">611</div><div class=\"line\">612</div><div class=\"line\">613</div><div class=\"line\">614</div><div class=\"line\">615</div><div class=\"line\">616</div><div class=\"line\">617</div><div class=\"line\">618</div><div class=\"line\">619</div><div class=\"line\">620</div><div class=\"line\">621</div><div class=\"line\">622</div><div class=\"line\">623</div><div class=\"line\">624</div><div class=\"line\">625</div><div class=\"line\">626</div><div class=\"line\">627</div><div class=\"line\">628</div><div class=\"line\">629</div><div class=\"line\">630</div><div class=\"line\">631</div><div class=\"line\">632</div><div class=\"line\">633</div><div class=\"line\">634</div><div class=\"line\">635</div><div class=\"line\">636</div><div class=\"line\">637</div><div class=\"line\">638</div><div class=\"line\">639</div><div class=\"line\">640</div><div class=\"line\">641</div><div class=\"line\">642</div><div class=\"line\">643</div><div class=\"line\">644</div><div class=\"line\">645</div><div class=\"line\">646</div><div class=\"line\">647</div><div class=\"line\">648</div><div class=\"line\">649</div><div class=\"line\">650</div><div class=\"line\">651</div><div class=\"line\">652</div><div class=\"line\">653</div><div class=\"line\">654</div><div class=\"line\">655</div><div class=\"line\">656</div><div class=\"line\">657</div><div class=\"line\">658</div><div class=\"line\">659</div><div class=\"line\">660</div><div class=\"line\">661</div><div class=\"line\">662</div><div class=\"line\">663</div><div class=\"line\">664</div><div class=\"line\">665</div><div class=\"line\">666</div><div class=\"line\">667</div><div class=\"line\">668</div><div class=\"line\">669</div><div class=\"line\">670</div><div class=\"line\">671</div><div class=\"line\">672</div><div class=\"line\">673</div><div class=\"line\">674</div><div class=\"line\">675</div><div class=\"line\">676</div><div class=\"line\">677</div><div class=\"line\">678</div><div class=\"line\">679</div><div class=\"line\">680</div><div class=\"line\">681</div><div class=\"line\">682</div><div class=\"line\">683</div><div class=\"line\">684</div><div class=\"line\">685</div><div class=\"line\">686</div><div class=\"line\">687</div><div class=\"line\">688</div><div class=\"line\">689</div><div class=\"line\">690</div><div class=\"line\">691</div><div class=\"line\">692</div><div class=\"line\">693</div><div class=\"line\">694</div><div class=\"line\">695</div><div class=\"line\">696</div><div class=\"line\">697</div><div class=\"line\">698</div><div class=\"line\">699</div><div class=\"line\">700</div><div class=\"line\">701</div><div class=\"line\">702</div><div class=\"line\">703</div><div class=\"line\">704</div><div class=\"line\">705</div><div class=\"line\">706</div><div class=\"line\">707</div><div class=\"line\">708</div><div class=\"line\">709</div><div class=\"line\">710</div><div class=\"line\">711</div><div class=\"line\">712</div><div class=\"line\">713</div><div class=\"line\">714</div><div class=\"line\">715</div><div class=\"line\">716</div><div class=\"line\">717</div><div class=\"line\">718</div><div class=\"line\">719</div><div class=\"line\">720</div><div class=\"line\">721</div><div class=\"line\">722</div><div class=\"line\">723</div><div class=\"line\">724</div><div class=\"line\">725</div><div class=\"line\">726</div><div class=\"line\">727</div><div class=\"line\">728</div><div class=\"line\">729</div><div class=\"line\">730</div><div class=\"line\">731</div><div class=\"line\">732</div><div class=\"line\">733</div><div class=\"line\">734</div><div class=\"line\">735</div><div class=\"line\">736</div><div class=\"line\">737</div><div class=\"line\">738</div><div class=\"line\">739</div><div class=\"line\">740</div><div class=\"line\">741</div><div class=\"line\">742</div><div class=\"line\">743</div><div class=\"line\">744</div><div class=\"line\">745</div><div class=\"line\">746</div><div class=\"line\">747</div><div class=\"line\">748</div><div class=\"line\">749</div><div class=\"line\">750</div><div class=\"line\">751</div><div class=\"line\">752</div><div class=\"line\">753</div><div class=\"line\">754</div><div class=\"line\">755</div><div class=\"line\">756</div><div class=\"line\">757</div><div class=\"line\">758</div><div class=\"line\">759</div><div class=\"line\">760</div><div class=\"line\">761</div><div class=\"line\">762</div><div class=\"line\">763</div><div class=\"line\">764</div><div class=\"line\">765</div><div class=\"line\">766</div><div class=\"line\">767</div><div class=\"line\">768</div><div class=\"line\">769</div><div class=\"line\">770</div><div class=\"line\">771</div><div class=\"line\">772</div><div class=\"line\">773</div><div class=\"line\">774</div><div class=\"line\">775</div><div class=\"line\">776</div><div class=\"line\">777</div><div class=\"line\">778</div><div class=\"line\">779</div><div class=\"line\">780</div><div class=\"line\">781</div><div class=\"line\">782</div><div class=\"line\">783</div><div class=\"line\">784</div><div class=\"line\">785</div><div class=\"line\">786</div><div class=\"line\">787</div><div class=\"line\">788</div><div class=\"line\">789</div><div class=\"line\">790</div><div class=\"line\">791</div><div class=\"line\">792</div><div class=\"line\">793</div><div class=\"line\">794</div><div class=\"line\">795</div><div class=\"line\">796</div><div class=\"line\">797</div><div class=\"line\">798</div><div class=\"line\">799</div><div class=\"line\">800</div><div class=\"line\">801</div><div class=\"line\">802</div><div class=\"line\">803</div><div class=\"line\">804</div><div class=\"line\">805</div><div class=\"line\">806</div><div class=\"line\">807</div><div class=\"line\">808</div><div class=\"line\">809</div><div class=\"line\">810</div><div class=\"line\">811</div><div class=\"line\">812</div><div class=\"line\">813</div><div class=\"line\">814</div><div class=\"line\">815</div><div class=\"line\">816</div><div class=\"line\">817</div><div class=\"line\">818</div><div class=\"line\">819</div><div class=\"line\">820</div><div class=\"line\">821</div><div class=\"line\">822</div><div class=\"line\">823</div><div class=\"line\">824</div><div class=\"line\">825</div><div class=\"line\">826</div><div class=\"line\">827</div><div class=\"line\">828</div><div class=\"line\">829</div><div class=\"line\">830</div><div class=\"line\">831</div><div class=\"line\">832</div><div class=\"line\">833</div><div class=\"line\">834</div><div class=\"line\">835</div><div class=\"line\">836</div><div class=\"line\">837</div><div class=\"line\">838</div><div class=\"line\">839</div><div class=\"line\">840</div><div class=\"line\">841</div><div class=\"line\">842</div><div class=\"line\">843</div><div class=\"line\">844</div><div class=\"line\">845</div><div class=\"line\">846</div><div class=\"line\">847</div><div class=\"line\">848</div><div class=\"line\">849</div><div class=\"line\">850</div><div class=\"line\">851</div><div class=\"line\">852</div><div class=\"line\">853</div><div class=\"line\">854</div><div class=\"line\">855</div><div class=\"line\">856</div><div class=\"line\">857</div><div class=\"line\">858</div><div class=\"line\">859</div><div class=\"line\">860</div><div class=\"line\">861</div><div class=\"line\">862</div><div class=\"line\">863</div><div class=\"line\">864</div><div class=\"line\">865</div><div class=\"line\">866</div><div class=\"line\">867</div><div class=\"line\">868</div><div class=\"line\">869</div><div class=\"line\">870</div><div class=\"line\">871</div><div class=\"line\">872</div><div class=\"line\">873</div><div class=\"line\">874</div><div class=\"line\">875</div><div class=\"line\">876</div><div class=\"line\">877</div><div class=\"line\">878</div><div class=\"line\">879</div><div class=\"line\">880</div><div class=\"line\">881</div><div class=\"line\">882</div><div class=\"line\">883</div><div class=\"line\">884</div><div class=\"line\">885</div><div class=\"line\">886</div><div class=\"line\">887</div><div class=\"line\">888</div><div class=\"line\">889</div><div class=\"line\">890</div><div class=\"line\">891</div><div class=\"line\">892</div><div class=\"line\">893</div><div class=\"line\">894</div><div class=\"line\">895</div><div class=\"line\">896</div><div class=\"line\">897</div><div class=\"line\">898</div><div class=\"line\">899</div><div class=\"line\">900</div><div class=\"line\">901</div><div class=\"line\">902</div><div class=\"line\">903</div><div class=\"line\">904</div><div class=\"line\">905</div><div class=\"line\">906</div><div class=\"line\">907</div><div class=\"line\">908</div><div class=\"line\">909</div><div class=\"line\">910</div><div class=\"line\">911</div><div class=\"line\">912</div><div class=\"line\">913</div><div class=\"line\">914</div><div class=\"line\">915</div><div class=\"line\">916</div><div class=\"line\">917</div><div class=\"line\">918</div><div class=\"line\">919</div><div class=\"line\">920</div><div class=\"line\">921</div><div class=\"line\">922</div><div class=\"line\">923</div><div class=\"line\">924</div><div class=\"line\">925</div><div class=\"line\">926</div><div class=\"line\">927</div><div class=\"line\">928</div><div class=\"line\">929</div><div class=\"line\">930</div><div class=\"line\">931</div><div class=\"line\">932</div><div class=\"line\">933</div><div class=\"line\">934</div><div class=\"line\">935</div><div class=\"line\">936</div><div class=\"line\">937</div><div class=\"line\">938</div><div class=\"line\">939</div><div class=\"line\">940</div><div class=\"line\">941</div><div class=\"line\">942</div><div class=\"line\">943</div><div class=\"line\">944</div><div class=\"line\">945</div><div class=\"line\">946</div><div class=\"line\">947</div><div class=\"line\">948</div><div class=\"line\">949</div><div class=\"line\">950</div><div class=\"line\">951</div><div class=\"line\">952</div><div class=\"line\">953</div><div class=\"line\">954</div><div class=\"line\">955</div><div class=\"line\">956</div><div class=\"line\">957</div><div class=\"line\">958</div><div class=\"line\">959</div><div class=\"line\">960</div><div class=\"line\">961</div><div class=\"line\">962</div><div class=\"line\">963</div><div class=\"line\">964</div><div class=\"line\">965</div><div class=\"line\">966</div><div class=\"line\">967</div><div class=\"line\">968</div><div class=\"line\">969</div><div class=\"line\">970</div><div class=\"line\">971</div><div class=\"line\">972</div><div class=\"line\">973</div><div class=\"line\">974</div><div class=\"line\">975</div><div class=\"line\">976</div><div class=\"line\">977</div><div class=\"line\">978</div><div class=\"line\">979</div><div class=\"line\">980</div><div class=\"line\">981</div><div class=\"line\">982</div><div class=\"line\">983</div><div class=\"line\">984</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span></span></span></div><div class=\"line\"><span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\"><span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd \"</span>&gt;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 被继承的父项目的构件标识符 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span> /&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 被继承的父项目的全球唯一标识符 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span> /&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 被继承的父项目的版本 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span> /&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">relativePath</span> /&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span> 4.0.0 <span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span> asia.banseon <span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源码，二进制发布和WARs等。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span> banseon-maven2 <span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span> jar <span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span> 1.0-SNAPSHOT <span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目的名称, Maven产生的文档用 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> banseon-maven <span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目主页的URL, Maven产生的文档用 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span> http://www.baidu.com/banseon <span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span> A maven project to study maven. <span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 描述了这个项目构建环境中的前提条件。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">prerequisites</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 构建该项目或使用该插件所需要的Maven的最低版本 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">maven</span> /&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">prerequisites</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">issueManagement</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 问题管理系统（例如jira）的名字， --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">system</span>&gt;</span> jira <span class=\"tag\">&lt;/<span class=\"name\">system</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 该项目使用的问题管理系统的URL --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span> http://jira.baidu.com/banseon <span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">issueManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目持续集成信息 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">ciManagement</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 持续集成系统的名字，例如continuum --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">system</span> /&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url</span> /&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">notifiers</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">notifier</span>&gt;</span></div><div class=\"line\">        <span class=\"comment\">&lt;!-- 传送通知的途径 --&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">type</span> /&gt;</span></div><div class=\"line\">        <span class=\"comment\">&lt;!-- 发生错误时是否通知 --&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">sendOnError</span> /&gt;</span></div><div class=\"line\">        <span class=\"comment\">&lt;!-- 构建失败时是否通知 --&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">sendOnFailure</span> /&gt;</span></div><div class=\"line\">        <span class=\"comment\">&lt;!-- 构建成功时是否通知 --&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">sendOnSuccess</span> /&gt;</span></div><div class=\"line\">        <span class=\"comment\">&lt;!-- 发生警告时是否通知 --&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">sendOnWarning</span> /&gt;</span></div><div class=\"line\">        <span class=\"comment\">&lt;!-- 不赞成使用。通知发送到哪里 --&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">address</span> /&gt;</span></div><div class=\"line\">        <span class=\"comment\">&lt;!-- 扩展配置项 --&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">configuration</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">notifier</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">notifiers</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">ciManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">inceptionYear</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目相关邮件列表信息 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">mailingLists</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mailingList</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 邮件的名称 --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> Demo <span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">post</span>&gt;</span> banseon@126.com <span class=\"tag\">&lt;/<span class=\"name\">post</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">subscribe</span>&gt;</span> banseon@126.com <span class=\"tag\">&lt;/<span class=\"name\">subscribe</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">unsubscribe</span>&gt;</span> banseon@126.com <span class=\"tag\">&lt;/<span class=\"name\">unsubscribe</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 你可以浏览邮件信息的URL --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">archive</span>&gt;</span> http:/hi.baidu.com/banseon/demo/dev/ <span class=\"tag\">&lt;/<span class=\"name\">archive</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mailingList</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">mailingLists</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目开发者列表 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">developers</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 某个项目开发者的信息 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">developer</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- SCM里项目开发者的唯一标识符 --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span> HELLO WORLD <span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 项目开发者的全名 --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> banseon <span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 项目开发者的email --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">email</span>&gt;</span> banseon@126.com <span class=\"tag\">&lt;/<span class=\"name\">email</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 项目开发者的主页的URL --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">url</span> /&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">roles</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">role</span>&gt;</span> Project Manager <span class=\"tag\">&lt;/<span class=\"name\">role</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">role</span>&gt;</span> Architect <span class=\"tag\">&lt;/<span class=\"name\">role</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">roles</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 项目开发者所属组织 --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">organization</span>&gt;</span> demo <span class=\"tag\">&lt;/<span class=\"name\">organization</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 项目开发者所属组织的URL --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">organizationUrl</span>&gt;</span> http://hi.baidu.com/banseon <span class=\"tag\">&lt;/<span class=\"name\">organizationUrl</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 项目开发者属性，如即时消息如何处理等 --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dept</span>&gt;</span> No <span class=\"tag\">&lt;/<span class=\"name\">dept</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 项目开发者所在时区， -11到12范围内的整数。 --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">timezone</span>&gt;</span> -5 <span class=\"tag\">&lt;/<span class=\"name\">timezone</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">developer</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">developers</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目的其他贡献者列表 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">contributors</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 项目的其他贡献者。参见developers/developer元素 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">contributor</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">name</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">email</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">url</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">organization</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">organizationUrl</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">roles</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">timezone</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">properties</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">contributor</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">contributors</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">licenses</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">license</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- license用于法律上的名称 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> Apache 2 <span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 官方的license正文页面的URL --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span> http://www.baidu.com/banseon/LICENSE-2.0.txt <span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 项目分发的主要方式：</span></div><div class=\"line\">    repo，可以从Maven库下载</div><div class=\"line\">    manual， 用户必须手动下载和安装依赖 --&gt;</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">distribution</span>&gt;</span> repo <span class=\"tag\">&lt;/<span class=\"name\">distribution</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 关于license的补充信息 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">comments</span>&gt;</span> A business-friendly OSS license <span class=\"tag\">&lt;/<span class=\"name\">comments</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">license</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">licenses</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">scm</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">connection</span>&gt;</span> scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk) <span class=\"tag\">&lt;/<span class=\"name\">connection</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">developerConnection</span>&gt;</span> scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk <span class=\"tag\">&lt;/<span class=\"name\">developerConnection</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 当前代码的标签，在开发阶段默认为HEAD --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tag</span> /&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span> http://svn.baidu.com/banseon <span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">scm</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 描述项目所属组织的各种属性。Maven产生的文档用 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">organization</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 组织的全名 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> demo <span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 组织主页的URL --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span> http://www.baidu.com/banseon <span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">organization</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 构建项目需要的信息 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">sourceDirectory</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">scriptSourceDirectory</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">testSourceDirectory</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 被编译过的应用程序class文件存放的目录。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 被编译过的测试class文件存放的目录。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">testOutputDirectory</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 使用来自该项目的一系列构建扩展 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">extensions</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 描述使用到的构建扩展。 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">extension</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 构建扩展的groupId --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span> /&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 构建扩展的artifactId --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span> /&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 构建扩展的版本 --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">extension</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">extensions</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">defaultGoal</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">resources</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 这个元素描述了项目相关或测试相关的所有资源路径 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$</span><span class=\"template-variable\">&#123;project.build.outputDirectory&#125;</span><span class=\"xml\"><span class=\"comment\">）。举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven/messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt;</span></span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">targetPath</span> /&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filtering</span> /&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 描述存放资源的目录，该路径相对POM路径 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">directory</span> /&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 包含的模式列表，例如**/*.xml. --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">includes</span> /&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 排除的模式列表，例如**/*.xml --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">excludes</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">resources</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">testResources</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">testResource</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">targetPath</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">filtering</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">directory</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">includes</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">excludes</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">testResource</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">testResources</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 构建产生的所有文件存放的目录 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">directory</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 产生的构件的文件名，默认值是$</span><span class=\"template-variable\">&#123;artifactId&#125;</span><span class=\"xml\"><span class=\"comment\">-$</span></span><span class=\"template-variable\">&#123;version&#125;</span><span class=\"xml\"><span class=\"comment\">。 --&gt;</span></span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">finalName</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 当filtering开关打开时，使用到的过滤器属性文件列表 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">filters</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">pluginManagement</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 使用的插件列表 。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- plugin元素包含描述插件所需要的信息。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 插件在仓库里的group ID --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 插件在仓库里的artifact ID --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 被使用的插件的版本（或版本范围） --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">extensions</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- execution元素包含了插件执行需要的信息 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">phase</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 配置的执行目标 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">goals</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 配置是否被传播到子POM --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">inherited</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 作为DOM对象的配置 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">configuration</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目引入插件所需要的额外依赖 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见dependencies/dependency元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 任何配置是否被传播到子项目 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">inherited</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 作为DOM对象的配置 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">configuration</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">pluginManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 使用的插件列表 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见build/pluginManagement/plugins/plugin元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">artifactId</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">version</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">extensions</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">phase</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">goals</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">inherited</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">configuration</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见dependencies/dependency元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">goals</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">inherited</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">configuration</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 在列的项目构建profile，如果被激活，会修改构建处理 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">profiles</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 根据环境参数或命令行参数激活某个构建处理 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">profile</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它</span></div><div class=\"line\"></div><div class=\"line\">  能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 --&gt;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">activation</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- profile默认是否激活的标志 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">activeByDefault</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">jdk</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">os</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 激活profile的操作系统的名字 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> Windows XP <span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 激活profile的操作系统所属家族(如 'windows') --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">family</span>&gt;</span> Windows <span class=\"tag\">&lt;/<span class=\"name\">family</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 激活profile的操作系统体系结构 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">arch</span>&gt;</span> x86 <span class=\"tag\">&lt;/<span class=\"name\">arch</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 激活profile的操作系统版本 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span> 5.1.2600 <span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">os</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 如果Maven检测到某一个属性（其值可以在POM中通过$</span><span class=\"template-variable\">&#123;名称&#125;</span><span class=\"xml\"><span class=\"comment\">引用），其拥有对应的名称和值，Profile就会被激活。如果值</span></span></div><div class=\"line\"></div><div class=\"line\">  字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 激活profile的属性的名称 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> mavenVersion <span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 激活profile的属性的值 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span> 2.0.3 <span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活</span></div><div class=\"line\"></div><div class=\"line\">  profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 如果指定的文件存在，则激活profile。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">exists</span>&gt;</span> /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ <span class=\"tag\">&lt;/<span class=\"name\">exists</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 如果指定的文件不存在，则激活profile。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">missing</span>&gt;</span> /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ <span class=\"tag\">&lt;/<span class=\"name\">missing</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">activation</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 构建项目所需要的信息。参见build元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">defaultGoal</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">resources</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">targetPath</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">filtering</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">directory</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">includes</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">excludes</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">resources</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">testResources</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">testResource</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">targetPath</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">filtering</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">directory</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">includes</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">excludes</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">testResource</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">testResources</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">directory</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">finalName</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">filters</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">pluginManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见build/pluginManagement/plugins/plugin元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">artifactId</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">version</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">extensions</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">phase</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">goals</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">inherited</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">configuration</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见dependencies/dependency元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">goals</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">inherited</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">configuration</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">pluginManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见build/pluginManagement/plugins/plugin元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">artifactId</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">version</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">extensions</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">phase</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">goals</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">inherited</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">configuration</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见dependencies/dependency元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">goals</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">inherited</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">configuration</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">modules</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 发现依赖和扩展的远程仓库列表。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">repositories</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见repositories/repository元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">repository</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">releases</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">enabled</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">updatePolicy</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">checksumPolicy</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">releases</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">snapshots</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">enabled</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">updatePolicy</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">checksumPolicy</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">snapshots</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">name</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">url</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">layout</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">repository</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">repositories</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">pluginRepositories</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">pluginRepository</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">releases</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">enabled</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">updatePolicy</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">checksumPolicy</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">releases</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">snapshots</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">enabled</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">updatePolicy</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">checksumPolicy</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">snapshots</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">name</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">url</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">layout</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">pluginRepository</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">pluginRepositories</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见dependencies/dependency元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 不赞成使用. 现在Maven忽略该元素. --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">reports</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">reporting</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">reporting</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见dependencyManagement元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见dependencies/dependency元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见distributionManagement元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">distributionManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">distributionManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见properties元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">properties</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">profile</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">profiles</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">modules</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 发现依赖和扩展的远程仓库列表。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">repositories</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 包含需要连接到远程仓库的信息 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">repository</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 如何处理远程仓库里发布版本的下载 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">releases</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">enabled</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">updatePolicy</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">checksumPolicy</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">releases</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">snapshots</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">enabled</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">updatePolicy</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">checksumPolicy</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">snapshots</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span> banseon-repository-proxy <span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 远程仓库名称 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> banseon-repository-proxy <span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 远程仓库URL，按protocol://hostname/path形式 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span> http://192.168.1.169:9999/repository/ <span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">layout</span>&gt;</span> default <span class=\"tag\">&lt;/<span class=\"name\">layout</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">repository</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">repositories</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">pluginRepositories</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">pluginRepository</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">pluginRepository</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">pluginRepositories</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 依赖的group ID --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span> org.apache.maven <span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 依赖的artifact ID --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span> maven-artifact <span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span> 3.8.1 <span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应，尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span> jar <span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">classifier</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">classifier</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。</span></div><div class=\"line\"></div><div class=\"line\">  - compile ：默认范围，用于编译</div><div class=\"line\"></div><div class=\"line\">  - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath</div><div class=\"line\"></div><div class=\"line\">  - runtime: 在执行时需要使用</div><div class=\"line\"></div><div class=\"line\">  - test: 用于test任务时使用</div><div class=\"line\"></div><div class=\"line\">  - system: 需要外在提供相应的元素。通过systemPath来取得</div><div class=\"line\"></div><div class=\"line\">  - systemPath: 仅用于范围为system。提供相应的路径</div><div class=\"line\"></div><div class=\"line\">  - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span> test <span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$</span><span class=\"template-variable\">&#123;java.home&#125;</span><span class=\"xml\"><span class=\"comment\">。 --&gt;</span></span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">systemPath</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">systemPath</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">exclusions</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">exclusion</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span> spring-core <span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span> org.springframework <span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">exclusion</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">exclusions</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">optional</span>&gt;</span> true <span class=\"tag\">&lt;/<span class=\"name\">optional</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 不赞成使用. 现在Maven忽略该元素. --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">reports</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">reports</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">reporting</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">excludeDefaults</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 所有产生的报表存放到哪里。默认值是$</span><span class=\"template-variable\">&#123;project.build.directory&#125;</span><span class=\"xml\"><span class=\"comment\">/site。 --&gt;</span></span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 使用的报表插件和他们的配置。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- plugin元素包含描述报表插件需要的信息 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 报表插件在仓库里的group ID --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 报表插件在仓库里的artifact ID --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 被使用的报表插件的版本（或版本范围） --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 任何配置是否被传播到子项目 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">inherited</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 报表插件的配置 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">configuration</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">reportSets</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 表示报表的一个集合，以及产生该集合的配置 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">reportSet</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 报表集合的唯一标识符，POM继承时用到 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 产生报表集合时，被使用的报表的配置 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">configuration</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 配置是否被继承到子POMs --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">inherited</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 这个集合里使用到哪些报表 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">reports</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">reportSet</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">reportSets</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">reporting</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID匹配到这里的依赖，并使用这里的依赖信息。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见dependencies/dependency元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">distributionManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 部署项目产生的构件到远程仓库需要的信息 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">repository</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">uniqueVersion</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span> banseon-maven2 <span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> banseon maven2 <span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span> file://$<span class=\"template-variable\">&#123;basedir&#125;</span><span class=\"xml\">/target/deploy <span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">layout</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">repository</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">snapshotRepository</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">uniqueVersion</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span> banseon-maven2 <span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> Banseon-maven2 Snapshot Repository <span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span> scp://svn.baidu.com/banseon:/usr/local/maven-snapshot <span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">layout</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">snapshotRepository</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 部署项目的网站需要的信息 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">site</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span> banseon-site <span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 部署位置的名称 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> business api website <span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 部署位置的URL，按protocol://hostname/path形式 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web</div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">site</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">downloadUrl</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">relocation</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 构件新的group ID --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 构件新的artifact ID --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 构件新的版本号 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 显示给用户的，关于移动的额外信息，例如原因。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">message</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">relocation</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部署），verified（被核实时正确的和最终的）。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">status</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">distributionManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">properties</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></div></pre></td></tr></table></figure>","excerpt":"<p>在Java语言中，框架通常是海量的，如果盲目的去学习某个框架，最终的结果就是两败俱伤，学习的人白白浪费了时间和精力，<br>而新的框架又在不断产生，可能今天学习的框架，明天又出了一个更好的。但是有些软件却是非常值得“深究”的，<br>因为他/她总会在某个特定的时刻，让人爱的无法自拔。。。。<br>要学习maven，首先要爱上它，我爱上它的原因是实在无法忍受种种框架依赖的种种jar包。在使用maven以前，<br>例如搭建一个非常熟悉的SSH框架，就首先要去Struts、Spring、Hibernate下载各个sdk，然后参照各自的help文档，来“集合”需要的jar，<br>其中有许多jar只会在特定的条件下才会用到，通常情况下都用不到。而且，有些jar属于第三方的jar，<br>这意味着必须得自己找那些jar，例如commons-xxxx系列。所有jar集齐后，在排除冲突，最后将搭好的框架放在eclipse里测试运行，<br>再看看有哪些问题。这样“千辛万苦”搭好的环境，可能随着其中一个组件版本的变化，例如spring版本的升级，又需要重新在来一次。<br>而且最后搭好的框架光jar可能就几百M。每次向svn上传时，就会特别悲伤。。。。<br></p>","more":"<p></p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div><div class=\"line\">338</div><div class=\"line\">339</div><div class=\"line\">340</div><div class=\"line\">341</div><div class=\"line\">342</div><div class=\"line\">343</div><div class=\"line\">344</div><div class=\"line\">345</div><div class=\"line\">346</div><div class=\"line\">347</div><div class=\"line\">348</div><div class=\"line\">349</div><div class=\"line\">350</div><div class=\"line\">351</div><div class=\"line\">352</div><div class=\"line\">353</div><div class=\"line\">354</div><div class=\"line\">355</div><div class=\"line\">356</div><div class=\"line\">357</div><div class=\"line\">358</div><div class=\"line\">359</div><div class=\"line\">360</div><div class=\"line\">361</div><div class=\"line\">362</div><div class=\"line\">363</div><div class=\"line\">364</div><div class=\"line\">365</div><div class=\"line\">366</div><div class=\"line\">367</div><div class=\"line\">368</div><div class=\"line\">369</div><div class=\"line\">370</div><div class=\"line\">371</div><div class=\"line\">372</div><div class=\"line\">373</div><div class=\"line\">374</div><div class=\"line\">375</div><div class=\"line\">376</div><div class=\"line\">377</div><div class=\"line\">378</div><div class=\"line\">379</div><div class=\"line\">380</div><div class=\"line\">381</div><div class=\"line\">382</div><div class=\"line\">383</div><div class=\"line\">384</div><div class=\"line\">385</div><div class=\"line\">386</div><div class=\"line\">387</div><div class=\"line\">388</div><div class=\"line\">389</div><div class=\"line\">390</div><div class=\"line\">391</div><div class=\"line\">392</div><div class=\"line\">393</div><div class=\"line\">394</div><div class=\"line\">395</div><div class=\"line\">396</div><div class=\"line\">397</div><div class=\"line\">398</div><div class=\"line\">399</div><div class=\"line\">400</div><div class=\"line\">401</div><div class=\"line\">402</div><div class=\"line\">403</div><div class=\"line\">404</div><div class=\"line\">405</div><div class=\"line\">406</div><div class=\"line\">407</div><div class=\"line\">408</div><div class=\"line\">409</div><div class=\"line\">410</div><div class=\"line\">411</div><div class=\"line\">412</div><div class=\"line\">413</div><div class=\"line\">414</div><div class=\"line\">415</div><div class=\"line\">416</div><div class=\"line\">417</div><div class=\"line\">418</div><div class=\"line\">419</div><div class=\"line\">420</div><div class=\"line\">421</div><div class=\"line\">422</div><div class=\"line\">423</div><div class=\"line\">424</div><div class=\"line\">425</div><div class=\"line\">426</div><div class=\"line\">427</div><div class=\"line\">428</div><div class=\"line\">429</div><div class=\"line\">430</div><div class=\"line\">431</div><div class=\"line\">432</div><div class=\"line\">433</div><div class=\"line\">434</div><div class=\"line\">435</div><div class=\"line\">436</div><div class=\"line\">437</div><div class=\"line\">438</div><div class=\"line\">439</div><div class=\"line\">440</div><div class=\"line\">441</div><div class=\"line\">442</div><div class=\"line\">443</div><div class=\"line\">444</div><div class=\"line\">445</div><div class=\"line\">446</div><div class=\"line\">447</div><div class=\"line\">448</div><div class=\"line\">449</div><div class=\"line\">450</div><div class=\"line\">451</div><div class=\"line\">452</div><div class=\"line\">453</div><div class=\"line\">454</div><div class=\"line\">455</div><div class=\"line\">456</div><div class=\"line\">457</div><div class=\"line\">458</div><div class=\"line\">459</div><div class=\"line\">460</div><div class=\"line\">461</div><div class=\"line\">462</div><div class=\"line\">463</div><div class=\"line\">464</div><div class=\"line\">465</div><div class=\"line\">466</div><div class=\"line\">467</div><div class=\"line\">468</div><div class=\"line\">469</div><div class=\"line\">470</div><div class=\"line\">471</div><div class=\"line\">472</div><div class=\"line\">473</div><div class=\"line\">474</div><div class=\"line\">475</div><div class=\"line\">476</div><div class=\"line\">477</div><div class=\"line\">478</div><div class=\"line\">479</div><div class=\"line\">480</div><div class=\"line\">481</div><div class=\"line\">482</div><div class=\"line\">483</div><div class=\"line\">484</div><div class=\"line\">485</div><div class=\"line\">486</div><div class=\"line\">487</div><div class=\"line\">488</div><div class=\"line\">489</div><div class=\"line\">490</div><div class=\"line\">491</div><div class=\"line\">492</div><div class=\"line\">493</div><div class=\"line\">494</div><div class=\"line\">495</div><div class=\"line\">496</div><div class=\"line\">497</div><div class=\"line\">498</div><div class=\"line\">499</div><div class=\"line\">500</div><div class=\"line\">501</div><div class=\"line\">502</div><div class=\"line\">503</div><div class=\"line\">504</div><div class=\"line\">505</div><div class=\"line\">506</div><div class=\"line\">507</div><div class=\"line\">508</div><div class=\"line\">509</div><div class=\"line\">510</div><div class=\"line\">511</div><div class=\"line\">512</div><div class=\"line\">513</div><div class=\"line\">514</div><div class=\"line\">515</div><div class=\"line\">516</div><div class=\"line\">517</div><div class=\"line\">518</div><div class=\"line\">519</div><div class=\"line\">520</div><div class=\"line\">521</div><div class=\"line\">522</div><div class=\"line\">523</div><div class=\"line\">524</div><div class=\"line\">525</div><div class=\"line\">526</div><div class=\"line\">527</div><div class=\"line\">528</div><div class=\"line\">529</div><div class=\"line\">530</div><div class=\"line\">531</div><div class=\"line\">532</div><div class=\"line\">533</div><div class=\"line\">534</div><div class=\"line\">535</div><div class=\"line\">536</div><div class=\"line\">537</div><div class=\"line\">538</div><div class=\"line\">539</div><div class=\"line\">540</div><div class=\"line\">541</div><div class=\"line\">542</div><div class=\"line\">543</div><div class=\"line\">544</div><div class=\"line\">545</div><div class=\"line\">546</div><div class=\"line\">547</div><div class=\"line\">548</div><div class=\"line\">549</div><div class=\"line\">550</div><div class=\"line\">551</div><div class=\"line\">552</div><div class=\"line\">553</div><div class=\"line\">554</div><div class=\"line\">555</div><div class=\"line\">556</div><div class=\"line\">557</div><div class=\"line\">558</div><div class=\"line\">559</div><div class=\"line\">560</div><div class=\"line\">561</div><div class=\"line\">562</div><div class=\"line\">563</div><div class=\"line\">564</div><div class=\"line\">565</div><div class=\"line\">566</div><div class=\"line\">567</div><div class=\"line\">568</div><div class=\"line\">569</div><div class=\"line\">570</div><div class=\"line\">571</div><div class=\"line\">572</div><div class=\"line\">573</div><div class=\"line\">574</div><div class=\"line\">575</div><div class=\"line\">576</div><div class=\"line\">577</div><div class=\"line\">578</div><div class=\"line\">579</div><div class=\"line\">580</div><div class=\"line\">581</div><div class=\"line\">582</div><div class=\"line\">583</div><div class=\"line\">584</div><div class=\"line\">585</div><div class=\"line\">586</div><div class=\"line\">587</div><div class=\"line\">588</div><div class=\"line\">589</div><div class=\"line\">590</div><div class=\"line\">591</div><div class=\"line\">592</div><div class=\"line\">593</div><div class=\"line\">594</div><div class=\"line\">595</div><div class=\"line\">596</div><div class=\"line\">597</div><div class=\"line\">598</div><div class=\"line\">599</div><div class=\"line\">600</div><div class=\"line\">601</div><div class=\"line\">602</div><div class=\"line\">603</div><div class=\"line\">604</div><div class=\"line\">605</div><div class=\"line\">606</div><div class=\"line\">607</div><div class=\"line\">608</div><div class=\"line\">609</div><div class=\"line\">610</div><div class=\"line\">611</div><div class=\"line\">612</div><div class=\"line\">613</div><div class=\"line\">614</div><div class=\"line\">615</div><div class=\"line\">616</div><div class=\"line\">617</div><div class=\"line\">618</div><div class=\"line\">619</div><div class=\"line\">620</div><div class=\"line\">621</div><div class=\"line\">622</div><div class=\"line\">623</div><div class=\"line\">624</div><div class=\"line\">625</div><div class=\"line\">626</div><div class=\"line\">627</div><div class=\"line\">628</div><div class=\"line\">629</div><div class=\"line\">630</div><div class=\"line\">631</div><div class=\"line\">632</div><div class=\"line\">633</div><div class=\"line\">634</div><div class=\"line\">635</div><div class=\"line\">636</div><div class=\"line\">637</div><div class=\"line\">638</div><div class=\"line\">639</div><div class=\"line\">640</div><div class=\"line\">641</div><div class=\"line\">642</div><div class=\"line\">643</div><div class=\"line\">644</div><div class=\"line\">645</div><div class=\"line\">646</div><div class=\"line\">647</div><div class=\"line\">648</div><div class=\"line\">649</div><div class=\"line\">650</div><div class=\"line\">651</div><div class=\"line\">652</div><div class=\"line\">653</div><div class=\"line\">654</div><div class=\"line\">655</div><div class=\"line\">656</div><div class=\"line\">657</div><div class=\"line\">658</div><div class=\"line\">659</div><div class=\"line\">660</div><div class=\"line\">661</div><div class=\"line\">662</div><div class=\"line\">663</div><div class=\"line\">664</div><div class=\"line\">665</div><div class=\"line\">666</div><div class=\"line\">667</div><div class=\"line\">668</div><div class=\"line\">669</div><div class=\"line\">670</div><div class=\"line\">671</div><div class=\"line\">672</div><div class=\"line\">673</div><div class=\"line\">674</div><div class=\"line\">675</div><div class=\"line\">676</div><div class=\"line\">677</div><div class=\"line\">678</div><div class=\"line\">679</div><div class=\"line\">680</div><div class=\"line\">681</div><div class=\"line\">682</div><div class=\"line\">683</div><div class=\"line\">684</div><div class=\"line\">685</div><div class=\"line\">686</div><div class=\"line\">687</div><div class=\"line\">688</div><div class=\"line\">689</div><div class=\"line\">690</div><div class=\"line\">691</div><div class=\"line\">692</div><div class=\"line\">693</div><div class=\"line\">694</div><div class=\"line\">695</div><div class=\"line\">696</div><div class=\"line\">697</div><div class=\"line\">698</div><div class=\"line\">699</div><div class=\"line\">700</div><div class=\"line\">701</div><div class=\"line\">702</div><div class=\"line\">703</div><div class=\"line\">704</div><div class=\"line\">705</div><div class=\"line\">706</div><div class=\"line\">707</div><div class=\"line\">708</div><div class=\"line\">709</div><div class=\"line\">710</div><div class=\"line\">711</div><div class=\"line\">712</div><div class=\"line\">713</div><div class=\"line\">714</div><div class=\"line\">715</div><div class=\"line\">716</div><div class=\"line\">717</div><div class=\"line\">718</div><div class=\"line\">719</div><div class=\"line\">720</div><div class=\"line\">721</div><div class=\"line\">722</div><div class=\"line\">723</div><div class=\"line\">724</div><div class=\"line\">725</div><div class=\"line\">726</div><div class=\"line\">727</div><div class=\"line\">728</div><div class=\"line\">729</div><div class=\"line\">730</div><div class=\"line\">731</div><div class=\"line\">732</div><div class=\"line\">733</div><div class=\"line\">734</div><div class=\"line\">735</div><div class=\"line\">736</div><div class=\"line\">737</div><div class=\"line\">738</div><div class=\"line\">739</div><div class=\"line\">740</div><div class=\"line\">741</div><div class=\"line\">742</div><div class=\"line\">743</div><div class=\"line\">744</div><div class=\"line\">745</div><div class=\"line\">746</div><div class=\"line\">747</div><div class=\"line\">748</div><div class=\"line\">749</div><div class=\"line\">750</div><div class=\"line\">751</div><div class=\"line\">752</div><div class=\"line\">753</div><div class=\"line\">754</div><div class=\"line\">755</div><div class=\"line\">756</div><div class=\"line\">757</div><div class=\"line\">758</div><div class=\"line\">759</div><div class=\"line\">760</div><div class=\"line\">761</div><div class=\"line\">762</div><div class=\"line\">763</div><div class=\"line\">764</div><div class=\"line\">765</div><div class=\"line\">766</div><div class=\"line\">767</div><div class=\"line\">768</div><div class=\"line\">769</div><div class=\"line\">770</div><div class=\"line\">771</div><div class=\"line\">772</div><div class=\"line\">773</div><div class=\"line\">774</div><div class=\"line\">775</div><div class=\"line\">776</div><div class=\"line\">777</div><div class=\"line\">778</div><div class=\"line\">779</div><div class=\"line\">780</div><div class=\"line\">781</div><div class=\"line\">782</div><div class=\"line\">783</div><div class=\"line\">784</div><div class=\"line\">785</div><div class=\"line\">786</div><div class=\"line\">787</div><div class=\"line\">788</div><div class=\"line\">789</div><div class=\"line\">790</div><div class=\"line\">791</div><div class=\"line\">792</div><div class=\"line\">793</div><div class=\"line\">794</div><div class=\"line\">795</div><div class=\"line\">796</div><div class=\"line\">797</div><div class=\"line\">798</div><div class=\"line\">799</div><div class=\"line\">800</div><div class=\"line\">801</div><div class=\"line\">802</div><div class=\"line\">803</div><div class=\"line\">804</div><div class=\"line\">805</div><div class=\"line\">806</div><div class=\"line\">807</div><div class=\"line\">808</div><div class=\"line\">809</div><div class=\"line\">810</div><div class=\"line\">811</div><div class=\"line\">812</div><div class=\"line\">813</div><div class=\"line\">814</div><div class=\"line\">815</div><div class=\"line\">816</div><div class=\"line\">817</div><div class=\"line\">818</div><div class=\"line\">819</div><div class=\"line\">820</div><div class=\"line\">821</div><div class=\"line\">822</div><div class=\"line\">823</div><div class=\"line\">824</div><div class=\"line\">825</div><div class=\"line\">826</div><div class=\"line\">827</div><div class=\"line\">828</div><div class=\"line\">829</div><div class=\"line\">830</div><div class=\"line\">831</div><div class=\"line\">832</div><div class=\"line\">833</div><div class=\"line\">834</div><div class=\"line\">835</div><div class=\"line\">836</div><div class=\"line\">837</div><div class=\"line\">838</div><div class=\"line\">839</div><div class=\"line\">840</div><div class=\"line\">841</div><div class=\"line\">842</div><div class=\"line\">843</div><div class=\"line\">844</div><div class=\"line\">845</div><div class=\"line\">846</div><div class=\"line\">847</div><div class=\"line\">848</div><div class=\"line\">849</div><div class=\"line\">850</div><div class=\"line\">851</div><div class=\"line\">852</div><div class=\"line\">853</div><div class=\"line\">854</div><div class=\"line\">855</div><div class=\"line\">856</div><div class=\"line\">857</div><div class=\"line\">858</div><div class=\"line\">859</div><div class=\"line\">860</div><div class=\"line\">861</div><div class=\"line\">862</div><div class=\"line\">863</div><div class=\"line\">864</div><div class=\"line\">865</div><div class=\"line\">866</div><div class=\"line\">867</div><div class=\"line\">868</div><div class=\"line\">869</div><div class=\"line\">870</div><div class=\"line\">871</div><div class=\"line\">872</div><div class=\"line\">873</div><div class=\"line\">874</div><div class=\"line\">875</div><div class=\"line\">876</div><div class=\"line\">877</div><div class=\"line\">878</div><div class=\"line\">879</div><div class=\"line\">880</div><div class=\"line\">881</div><div class=\"line\">882</div><div class=\"line\">883</div><div class=\"line\">884</div><div class=\"line\">885</div><div class=\"line\">886</div><div class=\"line\">887</div><div class=\"line\">888</div><div class=\"line\">889</div><div class=\"line\">890</div><div class=\"line\">891</div><div class=\"line\">892</div><div class=\"line\">893</div><div class=\"line\">894</div><div class=\"line\">895</div><div class=\"line\">896</div><div class=\"line\">897</div><div class=\"line\">898</div><div class=\"line\">899</div><div class=\"line\">900</div><div class=\"line\">901</div><div class=\"line\">902</div><div class=\"line\">903</div><div class=\"line\">904</div><div class=\"line\">905</div><div class=\"line\">906</div><div class=\"line\">907</div><div class=\"line\">908</div><div class=\"line\">909</div><div class=\"line\">910</div><div class=\"line\">911</div><div class=\"line\">912</div><div class=\"line\">913</div><div class=\"line\">914</div><div class=\"line\">915</div><div class=\"line\">916</div><div class=\"line\">917</div><div class=\"line\">918</div><div class=\"line\">919</div><div class=\"line\">920</div><div class=\"line\">921</div><div class=\"line\">922</div><div class=\"line\">923</div><div class=\"line\">924</div><div class=\"line\">925</div><div class=\"line\">926</div><div class=\"line\">927</div><div class=\"line\">928</div><div class=\"line\">929</div><div class=\"line\">930</div><div class=\"line\">931</div><div class=\"line\">932</div><div class=\"line\">933</div><div class=\"line\">934</div><div class=\"line\">935</div><div class=\"line\">936</div><div class=\"line\">937</div><div class=\"line\">938</div><div class=\"line\">939</div><div class=\"line\">940</div><div class=\"line\">941</div><div class=\"line\">942</div><div class=\"line\">943</div><div class=\"line\">944</div><div class=\"line\">945</div><div class=\"line\">946</div><div class=\"line\">947</div><div class=\"line\">948</div><div class=\"line\">949</div><div class=\"line\">950</div><div class=\"line\">951</div><div class=\"line\">952</div><div class=\"line\">953</div><div class=\"line\">954</div><div class=\"line\">955</div><div class=\"line\">956</div><div class=\"line\">957</div><div class=\"line\">958</div><div class=\"line\">959</div><div class=\"line\">960</div><div class=\"line\">961</div><div class=\"line\">962</div><div class=\"line\">963</div><div class=\"line\">964</div><div class=\"line\">965</div><div class=\"line\">966</div><div class=\"line\">967</div><div class=\"line\">968</div><div class=\"line\">969</div><div class=\"line\">970</div><div class=\"line\">971</div><div class=\"line\">972</div><div class=\"line\">973</div><div class=\"line\">974</div><div class=\"line\">975</div><div class=\"line\">976</div><div class=\"line\">977</div><div class=\"line\">978</div><div class=\"line\">979</div><div class=\"line\">980</div><div class=\"line\">981</div><div class=\"line\">982</div><div class=\"line\">983</div><div class=\"line\">984</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span></span></span></div><div class=\"line\"><span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\"><span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd \"</span>&gt;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 被继承的父项目的构件标识符 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span> /&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 被继承的父项目的全球唯一标识符 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span> /&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 被继承的父项目的版本 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span> /&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">relativePath</span> /&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span> 4.0.0 <span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span> asia.banseon <span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源码，二进制发布和WARs等。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span> banseon-maven2 <span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span> jar <span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span> 1.0-SNAPSHOT <span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目的名称, Maven产生的文档用 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> banseon-maven <span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目主页的URL, Maven产生的文档用 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span> http://www.baidu.com/banseon <span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span> A maven project to study maven. <span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 描述了这个项目构建环境中的前提条件。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">prerequisites</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 构建该项目或使用该插件所需要的Maven的最低版本 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">maven</span> /&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">prerequisites</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">issueManagement</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 问题管理系统（例如jira）的名字， --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">system</span>&gt;</span> jira <span class=\"tag\">&lt;/<span class=\"name\">system</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 该项目使用的问题管理系统的URL --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span> http://jira.baidu.com/banseon <span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">issueManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目持续集成信息 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">ciManagement</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 持续集成系统的名字，例如continuum --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">system</span> /&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url</span> /&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">notifiers</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">notifier</span>&gt;</span></div><div class=\"line\">        <span class=\"comment\">&lt;!-- 传送通知的途径 --&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">type</span> /&gt;</span></div><div class=\"line\">        <span class=\"comment\">&lt;!-- 发生错误时是否通知 --&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">sendOnError</span> /&gt;</span></div><div class=\"line\">        <span class=\"comment\">&lt;!-- 构建失败时是否通知 --&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">sendOnFailure</span> /&gt;</span></div><div class=\"line\">        <span class=\"comment\">&lt;!-- 构建成功时是否通知 --&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">sendOnSuccess</span> /&gt;</span></div><div class=\"line\">        <span class=\"comment\">&lt;!-- 发生警告时是否通知 --&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">sendOnWarning</span> /&gt;</span></div><div class=\"line\">        <span class=\"comment\">&lt;!-- 不赞成使用。通知发送到哪里 --&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">address</span> /&gt;</span></div><div class=\"line\">        <span class=\"comment\">&lt;!-- 扩展配置项 --&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">configuration</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">notifier</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">notifiers</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">ciManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">inceptionYear</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目相关邮件列表信息 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">mailingLists</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mailingList</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 邮件的名称 --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> Demo <span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">post</span>&gt;</span> banseon@126.com <span class=\"tag\">&lt;/<span class=\"name\">post</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">subscribe</span>&gt;</span> banseon@126.com <span class=\"tag\">&lt;/<span class=\"name\">subscribe</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">unsubscribe</span>&gt;</span> banseon@126.com <span class=\"tag\">&lt;/<span class=\"name\">unsubscribe</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 你可以浏览邮件信息的URL --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">archive</span>&gt;</span> http:/hi.baidu.com/banseon/demo/dev/ <span class=\"tag\">&lt;/<span class=\"name\">archive</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mailingList</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">mailingLists</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目开发者列表 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">developers</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 某个项目开发者的信息 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">developer</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- SCM里项目开发者的唯一标识符 --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span> HELLO WORLD <span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 项目开发者的全名 --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> banseon <span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 项目开发者的email --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">email</span>&gt;</span> banseon@126.com <span class=\"tag\">&lt;/<span class=\"name\">email</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 项目开发者的主页的URL --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">url</span> /&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">roles</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">role</span>&gt;</span> Project Manager <span class=\"tag\">&lt;/<span class=\"name\">role</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">role</span>&gt;</span> Architect <span class=\"tag\">&lt;/<span class=\"name\">role</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">roles</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 项目开发者所属组织 --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">organization</span>&gt;</span> demo <span class=\"tag\">&lt;/<span class=\"name\">organization</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 项目开发者所属组织的URL --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">organizationUrl</span>&gt;</span> http://hi.baidu.com/banseon <span class=\"tag\">&lt;/<span class=\"name\">organizationUrl</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 项目开发者属性，如即时消息如何处理等 --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dept</span>&gt;</span> No <span class=\"tag\">&lt;/<span class=\"name\">dept</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 项目开发者所在时区， -11到12范围内的整数。 --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">timezone</span>&gt;</span> -5 <span class=\"tag\">&lt;/<span class=\"name\">timezone</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">developer</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">developers</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目的其他贡献者列表 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">contributors</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 项目的其他贡献者。参见developers/developer元素 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">contributor</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">name</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">email</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">url</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">organization</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">organizationUrl</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">roles</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">timezone</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">properties</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">contributor</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">contributors</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">licenses</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">license</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- license用于法律上的名称 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> Apache 2 <span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 官方的license正文页面的URL --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span> http://www.baidu.com/banseon/LICENSE-2.0.txt <span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 项目分发的主要方式：</span></div><div class=\"line\">    repo，可以从Maven库下载</div><div class=\"line\">    manual， 用户必须手动下载和安装依赖 --&gt;</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">distribution</span>&gt;</span> repo <span class=\"tag\">&lt;/<span class=\"name\">distribution</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 关于license的补充信息 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">comments</span>&gt;</span> A business-friendly OSS license <span class=\"tag\">&lt;/<span class=\"name\">comments</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">license</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">licenses</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">scm</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">connection</span>&gt;</span> scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk) <span class=\"tag\">&lt;/<span class=\"name\">connection</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">developerConnection</span>&gt;</span> scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk <span class=\"tag\">&lt;/<span class=\"name\">developerConnection</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 当前代码的标签，在开发阶段默认为HEAD --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tag</span> /&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span> http://svn.baidu.com/banseon <span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">scm</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 描述项目所属组织的各种属性。Maven产生的文档用 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">organization</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 组织的全名 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> demo <span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 组织主页的URL --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span> http://www.baidu.com/banseon <span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">organization</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 构建项目需要的信息 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">sourceDirectory</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">scriptSourceDirectory</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">testSourceDirectory</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 被编译过的应用程序class文件存放的目录。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 被编译过的测试class文件存放的目录。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">testOutputDirectory</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 使用来自该项目的一系列构建扩展 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">extensions</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 描述使用到的构建扩展。 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">extension</span>&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 构建扩展的groupId --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span> /&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 构建扩展的artifactId --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span> /&gt;</span></div><div class=\"line\">      <span class=\"comment\">&lt;!-- 构建扩展的版本 --&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">extension</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">extensions</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">defaultGoal</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">resources</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 这个元素描述了项目相关或测试相关的所有资源路径 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$</span><span class=\"template-variable\">&#123;project.build.outputDirectory&#125;</span><span class=\"xml\"><span class=\"comment\">）。举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven/messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt;</span></span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">targetPath</span> /&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filtering</span> /&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 描述存放资源的目录，该路径相对POM路径 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">directory</span> /&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 包含的模式列表，例如**/*.xml. --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">includes</span> /&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 排除的模式列表，例如**/*.xml --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">excludes</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">resources</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">testResources</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">testResource</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">targetPath</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">filtering</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">directory</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">includes</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">excludes</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">testResource</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">testResources</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 构建产生的所有文件存放的目录 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">directory</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 产生的构件的文件名，默认值是$</span><span class=\"template-variable\">&#123;artifactId&#125;</span><span class=\"xml\"><span class=\"comment\">-$</span></span><span class=\"template-variable\">&#123;version&#125;</span><span class=\"xml\"><span class=\"comment\">。 --&gt;</span></span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">finalName</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 当filtering开关打开时，使用到的过滤器属性文件列表 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">filters</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">pluginManagement</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 使用的插件列表 。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- plugin元素包含描述插件所需要的信息。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 插件在仓库里的group ID --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 插件在仓库里的artifact ID --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 被使用的插件的版本（或版本范围） --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">extensions</span> /&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- execution元素包含了插件执行需要的信息 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">phase</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 配置的执行目标 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">goals</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 配置是否被传播到子POM --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">inherited</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 作为DOM对象的配置 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">configuration</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目引入插件所需要的额外依赖 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见dependencies/dependency元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 任何配置是否被传播到子项目 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">inherited</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 作为DOM对象的配置 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">configuration</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">pluginManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 使用的插件列表 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见build/pluginManagement/plugins/plugin元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">artifactId</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">version</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">extensions</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">phase</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">goals</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">inherited</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">configuration</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见dependencies/dependency元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">goals</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">inherited</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">configuration</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 在列的项目构建profile，如果被激活，会修改构建处理 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">profiles</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 根据环境参数或命令行参数激活某个构建处理 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">profile</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它</span></div><div class=\"line\"></div><div class=\"line\">  能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 --&gt;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">activation</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- profile默认是否激活的标志 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">activeByDefault</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">jdk</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">os</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 激活profile的操作系统的名字 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> Windows XP <span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 激活profile的操作系统所属家族(如 'windows') --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">family</span>&gt;</span> Windows <span class=\"tag\">&lt;/<span class=\"name\">family</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 激活profile的操作系统体系结构 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">arch</span>&gt;</span> x86 <span class=\"tag\">&lt;/<span class=\"name\">arch</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 激活profile的操作系统版本 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span> 5.1.2600 <span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">os</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 如果Maven检测到某一个属性（其值可以在POM中通过$</span><span class=\"template-variable\">&#123;名称&#125;</span><span class=\"xml\"><span class=\"comment\">引用），其拥有对应的名称和值，Profile就会被激活。如果值</span></span></div><div class=\"line\"></div><div class=\"line\">  字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 激活profile的属性的名称 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> mavenVersion <span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 激活profile的属性的值 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span> 2.0.3 <span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活</span></div><div class=\"line\"></div><div class=\"line\">  profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 如果指定的文件存在，则激活profile。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">exists</span>&gt;</span> /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ <span class=\"tag\">&lt;/<span class=\"name\">exists</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 如果指定的文件不存在，则激活profile。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">missing</span>&gt;</span> /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ <span class=\"tag\">&lt;/<span class=\"name\">missing</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">activation</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 构建项目所需要的信息。参见build元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">defaultGoal</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">resources</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">targetPath</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">filtering</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">directory</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">includes</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">excludes</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">resources</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">testResources</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">testResource</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">targetPath</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">filtering</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">directory</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">includes</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">excludes</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">testResource</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">testResources</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">directory</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">finalName</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">filters</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">pluginManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见build/pluginManagement/plugins/plugin元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">artifactId</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">version</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">extensions</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">phase</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">goals</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">inherited</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">configuration</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见dependencies/dependency元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">goals</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">inherited</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">configuration</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">pluginManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见build/pluginManagement/plugins/plugin元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">artifactId</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">version</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">extensions</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">phase</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">goals</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">inherited</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">configuration</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见dependencies/dependency元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">goals</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">inherited</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">configuration</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">modules</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 发现依赖和扩展的远程仓库列表。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">repositories</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见repositories/repository元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">repository</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">releases</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">enabled</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">updatePolicy</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">checksumPolicy</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">releases</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">snapshots</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">enabled</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">updatePolicy</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">checksumPolicy</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">snapshots</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">name</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">url</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">layout</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">repository</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">repositories</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">pluginRepositories</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">pluginRepository</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">releases</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">enabled</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">updatePolicy</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">checksumPolicy</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">releases</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">snapshots</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">enabled</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">updatePolicy</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">checksumPolicy</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">snapshots</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">name</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">url</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">layout</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">pluginRepository</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">pluginRepositories</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见dependencies/dependency元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 不赞成使用. 现在Maven忽略该元素. --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">reports</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">reporting</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">reporting</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见dependencyManagement元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见dependencies/dependency元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见distributionManagement元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">distributionManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">distributionManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见properties元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">properties</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">profile</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">profiles</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">modules</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 发现依赖和扩展的远程仓库列表。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">repositories</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 包含需要连接到远程仓库的信息 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">repository</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 如何处理远程仓库里发布版本的下载 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">releases</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">enabled</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">updatePolicy</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">checksumPolicy</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">releases</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">snapshots</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">enabled</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">updatePolicy</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">checksumPolicy</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">snapshots</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span> banseon-repository-proxy <span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 远程仓库名称 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> banseon-repository-proxy <span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 远程仓库URL，按protocol://hostname/path形式 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span> http://192.168.1.169:9999/repository/ <span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">layout</span>&gt;</span> default <span class=\"tag\">&lt;/<span class=\"name\">layout</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">repository</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">repositories</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">pluginRepositories</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">pluginRepository</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">pluginRepository</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">pluginRepositories</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 依赖的group ID --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span> org.apache.maven <span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 依赖的artifact ID --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span> maven-artifact <span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span> 3.8.1 <span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应，尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span> jar <span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">classifier</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">classifier</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。</span></div><div class=\"line\"></div><div class=\"line\">  - compile ：默认范围，用于编译</div><div class=\"line\"></div><div class=\"line\">  - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath</div><div class=\"line\"></div><div class=\"line\">  - runtime: 在执行时需要使用</div><div class=\"line\"></div><div class=\"line\">  - test: 用于test任务时使用</div><div class=\"line\"></div><div class=\"line\">  - system: 需要外在提供相应的元素。通过systemPath来取得</div><div class=\"line\"></div><div class=\"line\">  - systemPath: 仅用于范围为system。提供相应的路径</div><div class=\"line\"></div><div class=\"line\">  - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span> test <span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$</span><span class=\"template-variable\">&#123;java.home&#125;</span><span class=\"xml\"><span class=\"comment\">。 --&gt;</span></span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">systemPath</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">systemPath</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">exclusions</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">exclusion</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span> spring-core <span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span> org.springframework <span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">exclusion</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">exclusions</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">optional</span>&gt;</span> true <span class=\"tag\">&lt;/<span class=\"name\">optional</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 不赞成使用. 现在Maven忽略该元素. --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">reports</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">reports</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">reporting</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">excludeDefaults</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 所有产生的报表存放到哪里。默认值是$</span><span class=\"template-variable\">&#123;project.build.directory&#125;</span><span class=\"xml\"><span class=\"comment\">/site。 --&gt;</span></span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">outputDirectory</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 使用的报表插件和他们的配置。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- plugin元素包含描述报表插件需要的信息 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 报表插件在仓库里的group ID --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 报表插件在仓库里的artifact ID --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 被使用的报表插件的版本（或版本范围） --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 任何配置是否被传播到子项目 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">inherited</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 报表插件的配置 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">configuration</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">reportSets</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 表示报表的一个集合，以及产生该集合的配置 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">reportSet</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 报表集合的唯一标识符，POM继承时用到 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 产生报表集合时，被使用的报表的配置 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">configuration</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 配置是否被继承到子POMs --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">inherited</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 这个集合里使用到哪些报表 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">reports</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">reportSet</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">reportSets</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">reporting</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID匹配到这里的依赖，并使用这里的依赖信息。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 参见dependencies/dependency元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">distributionManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 部署项目产生的构件到远程仓库需要的信息 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">repository</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">uniqueVersion</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span> banseon-maven2 <span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> banseon maven2 <span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span> file://$<span class=\"template-variable\">&#123;basedir&#125;</span><span class=\"xml\">/target/deploy <span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">layout</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">repository</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">snapshotRepository</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">uniqueVersion</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span> banseon-maven2 <span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> Banseon-maven2 Snapshot Repository <span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span> scp://svn.baidu.com/banseon:/usr/local/maven-snapshot <span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">layout</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">snapshotRepository</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 部署项目的网站需要的信息 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">site</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span> banseon-site <span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 部署位置的名称 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> business api website <span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 部署位置的URL，按protocol://hostname/path形式 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web</div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">site</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">downloadUrl</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">relocation</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 构件新的group ID --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 构件新的artifact ID --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 构件新的版本号 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 显示给用户的，关于移动的额外信息，例如原因。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">message</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">relocation</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部署），verified（被核实时正确的和最终的）。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">status</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">distributionManagement</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。 --&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">properties</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></div></pre></td></tr></table></figure>"},{"title":"IntegerCache ByteCache CharacterCache LongCache ShortCache","date":"2018-08-30T03:25:56.000Z","_content":"new Integer(1) 与 Integer.valueOf(1) 的区别\n\n使用 Integer.valueOf(1) 可以使用系统缓存，既减少可能的内存占用，也省去了频繁创建对象的开销。\n\npublic static Integer valueOf(int i) {\nassert IntegerCache.high >= 127;\n if (i >= IntegerCache.low && i <= IntegerCache.high)\nreturn IntegerCache.cache[i + (-IntegerCache.low)];\n return new Integer(i);\n}\n在[IntegerCache.low, IntegerCache.high] 之前的数字都已被缓存。\n\n```\nprivate static class IntegerCache {\n    static final int low = -128;\n    static final int high;\n    static final Integer cache[];\n​\n    static {\n        // high value may be configured by property\n        int h = 127;\n        String integerCacheHighPropValue =\n            sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n        if (integerCacheHighPropValue != null) {\n            int i = parseInt(integerCacheHighPropValue);\n            i = Math.max(i, 127);\n            // Maximum array size is Integer.MAX_VALUE\n            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n        }\n        high = h;\n​\n        cache = new Integer[(high - low) + 1];\n        int j = low;\n        for(int k = 0; k < cache.length; k++)\n            cache[k] = new Integer(j++);\n    }\n​\n    private IntegerCache() {}\n}\n```\n默认区间是[-128, 127], 通过 VM 参数-XX:AutoBoxCacheMax=<size> 可以配置缓存的最大值.\nShort Long Byte Characte也都类似，范围有所不同\n类\n区间\n设置上限\nInteger\n[-128,127]\n-XX:AutoBoxCacheMax=<size>\nShort\n[-128,127]\n不可设置\nLong\n[-128,127]\n不可设置\nByte\n[-128,127]\n不可设置\nCharacter\n[0,127]\n不可设置","source":"_posts/30IntegerCache-ByteCache-CharacterCache-LongCache-ShortCache.md","raw":"---\ntitle: IntegerCache ByteCache CharacterCache LongCache ShortCache\ndate: 2018-08-30 11:25:56\ntags:\n---\nnew Integer(1) 与 Integer.valueOf(1) 的区别\n\n使用 Integer.valueOf(1) 可以使用系统缓存，既减少可能的内存占用，也省去了频繁创建对象的开销。\n\npublic static Integer valueOf(int i) {\nassert IntegerCache.high >= 127;\n if (i >= IntegerCache.low && i <= IntegerCache.high)\nreturn IntegerCache.cache[i + (-IntegerCache.low)];\n return new Integer(i);\n}\n在[IntegerCache.low, IntegerCache.high] 之前的数字都已被缓存。\n\n```\nprivate static class IntegerCache {\n    static final int low = -128;\n    static final int high;\n    static final Integer cache[];\n​\n    static {\n        // high value may be configured by property\n        int h = 127;\n        String integerCacheHighPropValue =\n            sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n        if (integerCacheHighPropValue != null) {\n            int i = parseInt(integerCacheHighPropValue);\n            i = Math.max(i, 127);\n            // Maximum array size is Integer.MAX_VALUE\n            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n        }\n        high = h;\n​\n        cache = new Integer[(high - low) + 1];\n        int j = low;\n        for(int k = 0; k < cache.length; k++)\n            cache[k] = new Integer(j++);\n    }\n​\n    private IntegerCache() {}\n}\n```\n默认区间是[-128, 127], 通过 VM 参数-XX:AutoBoxCacheMax=<size> 可以配置缓存的最大值.\nShort Long Byte Characte也都类似，范围有所不同\n类\n区间\n设置上限\nInteger\n[-128,127]\n-XX:AutoBoxCacheMax=<size>\nShort\n[-128,127]\n不可设置\nLong\n[-128,127]\n不可设置\nByte\n[-128,127]\n不可设置\nCharacter\n[0,127]\n不可设置","slug":"30IntegerCache-ByteCache-CharacterCache-LongCache-ShortCache","published":1,"updated":"2018-11-29T03:53:15.976Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tcal001ra7xwzr1gyko5","content":"<p>new Integer(1) 与 Integer.valueOf(1) 的区别</p>\n<p>使用 Integer.valueOf(1) 可以使用系统缓存，既减少可能的内存占用，也省去了频繁创建对象的开销。</p>\n<p>public static Integer valueOf(int i) {<br>assert IntegerCache.high &gt;= 127;<br> if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>return IntegerCache.cache[i + (-IntegerCache.low)];<br> return new Integer(i);<br>}<br>在[IntegerCache.low, IntegerCache.high] 之前的数字都已被缓存。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntegerCache</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> low = -<span class=\"number\">128</span>;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> high;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Integer cache[];</div><div class=\"line\">​</div><div class=\"line\">    <span class=\"keyword\">static</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// high value may be configured by property</span></div><div class=\"line\">        <span class=\"keyword\">int</span> h = <span class=\"number\">127</span>;</div><div class=\"line\">        String integerCacheHighPropValue =</div><div class=\"line\">            sun.misc.VM.getSavedProperty(<span class=\"string\">\"java.lang.Integer.IntegerCache.high\"</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span> (integerCacheHighPropValue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> i = parseInt(integerCacheHighPropValue);</div><div class=\"line\">            i = Math.max(i, <span class=\"number\">127</span>);</div><div class=\"line\">            <span class=\"comment\">// Maximum array size is Integer.MAX_VALUE</span></div><div class=\"line\">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class=\"number\">1</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        high = h;</div><div class=\"line\">​</div><div class=\"line\">        cache = <span class=\"keyword\">new</span> Integer[(high - low) + <span class=\"number\">1</span>];</div><div class=\"line\">        <span class=\"keyword\">int</span> j = low;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; cache.length; k++)</div><div class=\"line\">            cache[k] = <span class=\"keyword\">new</span> Integer(j++);</div><div class=\"line\">    &#125;</div><div class=\"line\">​</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">IntegerCache</span><span class=\"params\">()</span> </span>&#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>默认区间是[-128, 127], 通过 VM 参数-XX:AutoBoxCacheMax=<size> 可以配置缓存的最大值.<br>Short Long Byte Characte也都类似，范围有所不同<br>类<br>区间<br>设置上限<br>Integer<br>[-128,127]<br>-XX:AutoBoxCacheMax=<size><br>Short<br>[-128,127]<br>不可设置<br>Long<br>[-128,127]<br>不可设置<br>Byte<br>[-128,127]<br>不可设置<br>Character<br>[0,127]<br>不可设置</size></size></p>\n","excerpt":"","more":"<p>new Integer(1) 与 Integer.valueOf(1) 的区别</p>\n<p>使用 Integer.valueOf(1) 可以使用系统缓存，既减少可能的内存占用，也省去了频繁创建对象的开销。</p>\n<p>public static Integer valueOf(int i) {<br>assert IntegerCache.high &gt;= 127;<br> if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>return IntegerCache.cache[i + (-IntegerCache.low)];<br> return new Integer(i);<br>}<br>在[IntegerCache.low, IntegerCache.high] 之前的数字都已被缓存。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntegerCache</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> low = -<span class=\"number\">128</span>;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> high;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Integer cache[];</div><div class=\"line\">​</div><div class=\"line\">    <span class=\"keyword\">static</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// high value may be configured by property</span></div><div class=\"line\">        <span class=\"keyword\">int</span> h = <span class=\"number\">127</span>;</div><div class=\"line\">        String integerCacheHighPropValue =</div><div class=\"line\">            sun.misc.VM.getSavedProperty(<span class=\"string\">\"java.lang.Integer.IntegerCache.high\"</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span> (integerCacheHighPropValue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> i = parseInt(integerCacheHighPropValue);</div><div class=\"line\">            i = Math.max(i, <span class=\"number\">127</span>);</div><div class=\"line\">            <span class=\"comment\">// Maximum array size is Integer.MAX_VALUE</span></div><div class=\"line\">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class=\"number\">1</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        high = h;</div><div class=\"line\">​</div><div class=\"line\">        cache = <span class=\"keyword\">new</span> Integer[(high - low) + <span class=\"number\">1</span>];</div><div class=\"line\">        <span class=\"keyword\">int</span> j = low;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; cache.length; k++)</div><div class=\"line\">            cache[k] = <span class=\"keyword\">new</span> Integer(j++);</div><div class=\"line\">    &#125;</div><div class=\"line\">​</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">IntegerCache</span><span class=\"params\">()</span> </span>&#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>默认区间是[-128, 127], 通过 VM 参数-XX:AutoBoxCacheMax=<size> 可以配置缓存的最大值.<br>Short Long Byte Characte也都类似，范围有所不同<br>类<br>区间<br>设置上限<br>Integer<br>[-128,127]<br>-XX:AutoBoxCacheMax=<size><br>Short<br>[-128,127]<br>不可设置<br>Long<br>[-128,127]<br>不可设置<br>Byte<br>[-128,127]<br>不可设置<br>Character<br>[0,127]<br>不可设置</size></size></p>\n"},{"title":"java web会话管理","date":"2018-08-30T09:45:23.000Z","_content":"","source":"_posts/32java-web会话管理.md","raw":"---\ntitle: java web会话管理\ndate: 2018-08-30 17:45:23\ntags:\n---\n","slug":"32java-web会话管理","published":1,"updated":"2018-11-29T03:53:15.979Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tcan001va7xwb60fhcjf","content":"","excerpt":"","more":""},{"title":"git ignore 文件解析","date":"2018-08-30T09:42:04.000Z","_content":"在git中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改根目录中 .gitignore 文件的方法（如无，则需自己手工建立此文件）。这个文件每一行保存了一个匹配的规则.\n例如：\n```\n# 此为注释 – 将被 Git 忽略\n*.a       # 忽略所有 .a 结尾的文件\n!lib.a    # 但 lib.a 除外\n/TODO     # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO\nbuild/    # 忽略 build/ 目录下的所有文件\ndoc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt\n```\n\n规则很简单，不做过多解释，但是有时候在项目开发过程中，突然心血来潮想把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交：\n```\ngit rm -r --cached .\ngit add .\ngit commit -m 'update .gitignore'\n```\n\n新的项目需要配置一下,否则不会计入贡献\n```\n git config --global user.name \"MohnSnow\"\n git config --global user.email \"mengdexin_work@163.com\"\n```","source":"_posts/31git-ignore.md","raw":"---\ntitle: git ignore 文件解析\ndate: 2018-08-30 17:42:04\ntags:\n---\n在git中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改根目录中 .gitignore 文件的方法（如无，则需自己手工建立此文件）。这个文件每一行保存了一个匹配的规则.\n例如：\n```\n# 此为注释 – 将被 Git 忽略\n*.a       # 忽略所有 .a 结尾的文件\n!lib.a    # 但 lib.a 除外\n/TODO     # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO\nbuild/    # 忽略 build/ 目录下的所有文件\ndoc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt\n```\n\n规则很简单，不做过多解释，但是有时候在项目开发过程中，突然心血来潮想把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交：\n```\ngit rm -r --cached .\ngit add .\ngit commit -m 'update .gitignore'\n```\n\n新的项目需要配置一下,否则不会计入贡献\n```\n git config --global user.name \"MohnSnow\"\n git config --global user.email \"mengdexin_work@163.com\"\n```","slug":"31git-ignore","published":1,"updated":"2018-11-28T07:37:21.396Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tcan001xa7xwwf84qbc4","content":"<p>在git中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改根目录中 .gitignore 文件的方法（如无，则需自己手工建立此文件）。这个文件每一行保存了一个匹配的规则.<br>例如：<br><figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 此为注释 – 将被 Git 忽略</span></div><div class=\"line\">*.a       <span class=\"comment\"># 忽略所有 .a 结尾的文件</span></div><div class=\"line\">!<span class=\"class\"><span class=\"keyword\">lib</span>.<span class=\"title\">a</span>    <span class=\"comment\"># 但 lib.a 除外</span></span></div><div class=\"line\">/TODO     <span class=\"comment\"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span></div><div class=\"line\">build/    <span class=\"comment\"># 忽略 build/ 目录下的所有文件</span></div><div class=\"line\">doc/*.txt <span class=\"comment\"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span></div></pre></td></tr></table></figure></p>\n<p>规则很简单，不做过多解释，但是有时候在项目开发过程中，突然心血来潮想把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交：<br><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git rm -r --cached .</div><div class=\"line\">git <span class=\"keyword\">add</span><span class=\"bash\"> .</span></div><div class=\"line\">git commit -m <span class=\"string\">'update .gitignore'</span></div></pre></td></tr></table></figure></p>\n<p>新的项目需要配置一下,否则不会计入贡献<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config --global user<span class=\"selector-class\">.name</span> <span class=\"string\">\"MohnSnow\"</span></div><div class=\"line\">git config --global user<span class=\"selector-class\">.email</span> <span class=\"string\">\"mengdexin_work@163.com\"</span></div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>在git中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改根目录中 .gitignore 文件的方法（如无，则需自己手工建立此文件）。这个文件每一行保存了一个匹配的规则.<br>例如：<br><figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 此为注释 – 将被 Git 忽略</span></div><div class=\"line\">*.a       <span class=\"comment\"># 忽略所有 .a 结尾的文件</span></div><div class=\"line\">!<span class=\"class\"><span class=\"keyword\">lib</span>.<span class=\"title\">a</span>    <span class=\"comment\"># 但 lib.a 除外</span></span></div><div class=\"line\">/TODO     <span class=\"comment\"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span></div><div class=\"line\">build/    <span class=\"comment\"># 忽略 build/ 目录下的所有文件</span></div><div class=\"line\">doc/*.txt <span class=\"comment\"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span></div></pre></td></tr></table></figure></p>\n<p>规则很简单，不做过多解释，但是有时候在项目开发过程中，突然心血来潮想把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交：<br><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git rm -r --cached .</div><div class=\"line\">git <span class=\"keyword\">add</span><span class=\"bash\"> .</span></div><div class=\"line\">git commit -m <span class=\"string\">'update .gitignore'</span></div></pre></td></tr></table></figure></p>\n<p>新的项目需要配置一下,否则不会计入贡献<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config --global user<span class=\"selector-class\">.name</span> <span class=\"string\">\"MohnSnow\"</span></div><div class=\"line\">git config --global user<span class=\"selector-class\">.email</span> <span class=\"string\">\"mengdexin_work@163.com\"</span></div></pre></td></tr></table></figure></p>\n"},{"title":"Java面试题","date":"2017-11-16T06:49:51.000Z","_content":"\n# Java面试资源\n这里汇总整理了网络上的Java面试题，持续更新\n<!--more-->\n## 基本概念\n* 操作系统中 heap 和 stack 的区别\n* 什么是基于注解的切面实现\n* 什么是 对象/关系 映射集成模块\n* 什么是 Java 的反射机制\n* 什么是 ACID\n* BS与CS的联系与区别\n* Cookie 和 Session的区别\n* fail-fast 与 fail-safe 机制有什么区别\n* get 和 post请求的区别\n* Interface 与 abstract 类的区别\n* IOC的优点是什么\n* IO 和 NIO的区别，NIO优点\n* Java 8 / Java 7 为我们提供了什么新功能\n* 什么是竞态条件？ 举个例子说明。\n* JRE、JDK、JVM 及 JIT 之间有什么不同\n* MVC的各个部分都有那些技术来实现?如何实现?\n* RPC 通信和 RMI 区别\n* 什么是 Web Service（Web服务）\n* JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。\n* WEB容器主要有哪些功能? 并请列出一些常见的WEB容器名字。\n* 一个\".java\"源文件中是否可以包含多个类（不是内部类）？有什么限制\n* 简单说说你了解的类加载器。是否实现过类加载器\n* 解释一下什么叫AOP（面向切面编程）\n* 请简述 Servlet 的生命周期及其相关的方法\n* 请简述一下 Ajax 的原理及实现步骤\n* 简单描述Struts的主要功能\n* 什么是 N 层架构\n* 什么是CORBA？用途是什么\n* 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”\n* 什么是正则表达式？用途是什么？哪个包使用正则表达式来实现模式匹配\n* 什么是懒加载（Lazy Loading）\n* 什么是尾递归，为什么需要尾递归\n* 什么是控制反转（Inversion of Control）与依赖注入（Dependency Injection）\n\n## 关键字\n* finalize\n    * 什么是finalize()方法\n        * finalize()方法什么时候被调用\n        * 析构函数(finalization)的目的是什么\n        * final 和 finalize 的区别\n        * final\n    * final关键字有哪些用法\n        * final 与 static 关键字可以用于哪里？它们的作用是什么\n        * final, finally, finalize的区别\n        * final、finalize 和 finally 的不同之处？\n    * 能否在运行时向 static final 类型的赋值\n        * 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变\n        * 一个类被声明为final类型，表示了什么意思\n        * throws, throw, try, catch, finally分别代表什么意义\n* Java 有几种修饰符？分别用来修饰什么\n* volatile\n    * volatile 修饰符的有过什么实践\n    * volatile 变量是什么？volatile 变量和 atomic 变量有什么不同\n    * volatile 类型变量提供什么保证？能使得一个非原子操作变成原子操作吗\n    * 能创建 volatile 数组吗？\n* transient变量有什么特点\n* super什么时候使用\n* public static void 写成 static public void会怎样\n* 说明一下public static void main(String args[])这段声明里每个关键字的作用\n* 请说出作用域public, private, protected, 以及不写时的区别\n* sizeof 是Java 的关键字吗\n* static\n     * static class 与 non static class的区别\n     * static 关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法\n     * 静态类型有什么特点\n     * main() 方法为什么必须是静态的？能不能声明 main() 方法为非静态\n     * 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用\n     * 静态变量在什么时候加载？编译期还是运行期？静态代码块加载的时机呢\n     * 成员方法是否可以访问静态变量？为什么静态方法不能访问成员变量\n* switch\n     * switch 语句中的表达式可以是什么类型数据\n     * switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上\n* while 循环和 do 循环有什么不同\n\n## 操作符\n* &操作符和&&操作符有什么区别?\n* a = a + b 与 a += b 的区别？\n* 逻辑操作符 (&,|,^)与条件操作符(&&,||)的区别\n* 3\\*0.1 == 0.3 将会返回什么？true 还是 false？\n* float f=3.4; 是否正确？\n* short s1 = 1; s1 = s1 + 1;有什么错?\n\n## 数据结构\n* 基础类型(Primitives)\n    * 基础类型(Primitives)与封装类型(Wrappers)的区别在哪里\n    * 简述九种基本数据类型的大小，以及他们的封装类\n    * int 和 Integer 哪个会占用更多的内存？ int 和 Integer 有什么区别？parseInt()函数在什么时候使用到\n    * float和double的默认值是多少\n    * 如何去小数四舍五入保留小数点后两位\n    * char 型变量中能不能存贮一个中文汉字，为什么\n* 类型转换\n    * 怎样将 bytes 转换为 long 类型\n    * 怎么将 byte 转换为 String\n    * 如何将数值型字符转换为数字\n    * 我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象\n    * 能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗\n    * 类型向下转换是什么\n* 数组\n   * 如何权衡是使用无序的数组还是有序的数组\n   * 怎么判断数组是 null 还是为空\n   * 怎么打印数组？ 怎样打印数组中的重复元素\n   * Array 和 ArrayList有什么区别？什么时候应该使用Array而不是ArrayList\n   * 数组和链表数据结构描述，各自的时间复杂度\n   * 数组有没有length()这个方法? String有没有length()这个方法\n* 队列\n   * 队列和栈是什么，列出它们的区别\n   * BlockingQueue是什么\n   * 简述 ConcurrentLinkedQueue LinkedBlockingQueue 的用处和不同之处。\n* ArrayList、Vector、LinkedList的存储性能和特性\n* String\n* StringBuffer\n    * ByteBuffer 与 StringBuffer有什么区别\n* HashMap\n    * HashMap的工作原理是什么\n    * 内部的数据结构是什么\n    * HashMap 的 table的容量如何确定？loadFactor 是什么？ 该容量如何变化？这种变化会带来什么问题？\n    * HashMap 实现的数据结构是什么？如何实现\n    * HashMap 和 HashTable、ConcurrentHashMap 的区别\n    * HashMap的遍历方式及效率\n    * HashMap、LinkedMap、TreeMap的区别\n    * 如何决定选用HashMap还是TreeMap\n    * 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办\n    * HashMap 是线程安全的吗？并发下使用的 Map 是什么，它们内部原理分别是什么，比如存储方式、 hashcode、扩容、 默认容量等\n* HashSet\n    * HashSet和TreeSet有什么区别\n    * HashSet 内部是如何工作的\n    * WeakHashMap 是怎么工作的？\n* Set\n    * Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢？是用 == 还是 equals()？ 它们有何区别?\n    * TreeMap：TreeMap 是采用什么树实现的？TreeMap、HashMap、LindedHashMap的区别。TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？\n    * TreeSet：一个已经构建好的 TreeSet，怎么完成倒排序。\n    * EnumSet 是什么\n* Hash算法\n    * Hashcode 的作用\n    * 简述一致性 Hash 算法\n    * 有没有可能 两个不相等的对象有相同的 hashcode？当两个对象 hashcode 相同怎么办？如何获取值对象\n    * 为什么在重写 equals 方法的时候需要重写 hashCode 方法？equals与 hashCode 的异同点在哪里\n    * a.hashCode() 有什么用？与 a.equals(b) 有什么关系\n    * hashCode() 和 equals() 方法的重要性体现在什么地方\n    * Object：Object有哪些公用方法？Object类hashcode,equals 设计原则？ sun为什么这么设计？Object类的概述\n    * 如何在父类中为子类自动完成所有的 hashcode 和 equals 实现？这么做有何优劣。\n    * 可以在 hashcode() 中使用随机数字吗？\n* LinkedHashMap\n    * LinkedHashMap 和 PriorityQueue 的区别是什么\n* List\n    * List, Set, Map三个接口，存取元素时各有什么特点\n    * List, Set, Map 是否继承自 Collection 接口\n    * 遍历一个 List 有哪些不同的方式\n    * LinkedList\n        * LinkedList 是单向链表还是双向链表\n        * LinkedList 与 ArrayList 有什么区别\n        * 描述下 Java 中集合（Collections），接口（Interfaces），实现（Implementations）的概念。LinkedList 与 ArrayList 的区别是什么？\n        * 插入数据时，ArrayList, LinkedList, Vector谁速度较快？\n    * ArrayList\n        * ArrayList 和 HashMap 的默认大小是多数\n        * ArrayList 和 LinkedList 的区别，什么时候用 ArrayList？\n        * ArrayList 和 Set 的区别？\n        * ArrayList, LinkedList, Vector的区别\n        * ArrayList是如何实现的，ArrayList 和 LinkedList 的区别\n        * ArrayList如何实现扩容\n        * Array 和 ArrayList 有何区别？什么时候更适合用Array\n        * 说出ArraList,Vector, LinkedList的存储性能和特性\n* Map\n    * Map, Set, List, Queue, Stack\n    * Map 接口提供了哪些不同的集合视图\n    * 为什么 Map 接口不继承 Collection 接口\n* Collections\n    * 介绍Java中的Collection FrameWork。集合类框架的基本接口有哪些\n    * Collections类是什么？Collection 和 Collections的区别？Collection、Map的实现\n    * 集合类框架的最佳实践有哪些\n    * 为什么 Collection 不从 Cloneable 和 Serializable 接口继承\n    * 说出几点 Java 中使用 Collections 的最佳实践？\n    * Collections 中 遗留类 (HashTable、Vector) 和 现有类的区别\n*  什么是 B+树，B-树，列出实际的使用场景。\n\n## 接口\n* Comparator 与 Comparable 接口是干什么的？列出它们的区别\n\n## 对象\n* 拷贝(clone)\n    * 如何实现对象克隆\n    * 深拷贝和浅拷贝区别\n    * 深拷贝和浅拷贝如何实现激活机制\n    * 写clone()方法时，通常都有一行代码，是什么\n* 比较\n    * 在比较对象时，\"==\" 运算符和 equals 运算有何区别\n    * 如果要重写一个对象的equals方法，还要考虑什么\n    * 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对\n* 构造器\n    * 构造器链是什么\n    * 创建对象时构造器的调用顺序\n* 不可变对象\n    * 什么是不可变象（immutable object）\n    * 为什么 Java 中的 String 是不可变的（Immutable）\n    * 如何构建不可变的类结构？关键点在哪里\n    * 能创建一个包含可变对象的不可变对象吗\n* 如何对一组对象进行排序\n\n## 方法\n* 构造器（constructor）是否可被重写（override）\n* 方法可以同时即是 static 又是 synchronized 的吗\n* abstract 的 method是否可同时是 static，是否可同时是 native，是否可同时是synchronized\n* Java支持哪种参数传递类型\n* 一个对象被当作参数传递到一个方法，是值传递还是引用传递\n* 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递\n* 我们能否重载main()方法\n* 如果main方法被声明为private会怎样\n\n## GC\n* 概念\n    * GC是什么？为什么要有GC\n    * 什么时候会导致垃圾回收\n    * GC是怎么样运行的\n    * 新老以及永久区是什么\n    * GC 有几种方式？怎么配置\n    * 什么时候一个对象会被GC？ 如何判断一个对象是否存活\n    * System.gc()  Runtime.gc()会做什么事情？  能保证 GC 执行吗\n    * 垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？\n    * Minor GC 、Major GC、Young GC 与 Full GC分别在什么时候发生\n    * 垃圾回收算法的实现原理\n    * 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？\n    * 垃圾回收的最佳做法是什么\n* GC收集器有哪些\n     * 垃圾回收器的基本原理是什么？\n     * 串行(serial)收集器和吞吐量(throughput)收集器的区别是什么\n    * Serial 与 Parallel GC之间的不同之处\n    * CMS 收集器 与 G1 收集器的特点与区别\n    * CMS垃圾回收器的工作过程\n    * JVM 中一次完整的 GC 流程是怎样的？ 对象如何晋升到老年代\n    * 吞吐量优先和响应优先的垃圾收集器选择\n* GC策略\n     * 举个实际的场景，选择一个GC策略\n     * JVM的永久代中会发生垃圾回收吗\n* 收集方法\n    * 标记清除、标记整理、复制算法的原理与特点？分别用在什么地方\n    * 如果让你优化收集方法，有什么思路\n\n## JVM\n* 参数\n    * 说说你知道的几种主要的jvm 参数\n    * -XX:+UseCompressedOops 有什么作用\n* 类加载器(ClassLoader)\n    * Java 类加载器都有哪些\n    * JVM如何加载字节码文件\n* 内存管理\n    * JVM内存分哪几个区，每个区的作用是什么\n    * 一个对象从创建到销毁都是怎么在这些部分里存活和转移的\n    *  解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法\n    * JVM中哪个参数是用来控制线程的栈堆栈小\n    *  简述内存分配与回收策略\n    *  简述重排序，内存屏障，happen-before，主内存，工作内存\n    * Java中存在内存泄漏问题吗？请举例说明\n    * 简述 Java 中软引用（SoftReferenc）、弱引用（WeakReference）和虚引用\n    * 内存映射缓存区是什么\n* jstack，jstat，jmap，jconsole怎么用\n* 32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？32 位和 64 位的 JVM，int 类型变量的长度是多数？\n* 怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位\n* JVM自身会维护缓存吗？是不是在堆中进行对象分配，操作系统的堆还是JVM自己管理堆\n* 什么情况下会发生栈内存溢出\n* 双亲委派模型是什么\n\n## 多线程\n* 基本概念\n    * 什么是线程\n    * 多线程的优点\n    * 多线程的几种实现方式\n        * 用 Runnable 还是 Thread\n    * 什么是线程安全\n        * Vector, SimpleDateFormat 是线程安全类吗\n        * 什么 Java 原型不是线程安全的\n        * 哪些集合类是线程安全的\n    * 多线程中的忙循环是什么\n    * 如何创建一个线程\n    * 编写多线程程序有几种实现方式\n    * 什么是线程局部变量\n    * 线程和进程有什么区别？进程间如何通讯，线程间如何通讯\n    * 什么是多线程环境下的伪共享（false sharing）\n    * 同步和异步有何异同，在什么情况下分别使用他们？举例说明\n* Current\n    * ConcurrentHashMap 和 Hashtable的区别\n    * ArrayBlockingQueue, CountDownLatch的用法\n    * ConcurrentHashMap的并发度是什么\n* CyclicBarrier 和 CountDownLatch有什么不同？各自的内部原理和用法是什么\n* Semaphore的用法\n* Thread\n    * 启动一个线程是调用 run() 还是 start() 方法？start() 和 run() 方法有什么区别\n    * 调用start()方法时会执行run()方法，为什么不能直接调用run()方法\n    * sleep() 方法和对象的 wait() 方法都可以让线程暂停执行，它们有什么区别\n    * yield方法有什么作用？sleep() 方法和 yield() 方法有什么区别\n    * Java 中如何停止一个线程\n    * stop() 和 suspend() 方法为何不推荐使用\n    * 如何在两个线程间共享数据\n    * 如何强制启动一个线程\n    * 如何让正在运行的线程暂停一段时间\n    * 什么是线程组，为什么在Java中不推荐使用\n    * 你是如何调用  wait（方法的）？使用 if 块还是循环？为什么\n* 生命周期\n    * 有哪些不同的线程生命周期\n    * 线程状态，BLOCKED 和 WAITING 有什么区别\n    * 画一个线程的生命周期状态图\n* ThreadLocal 用途是什么，原理是什么，用的时候要注意什么\n* ThreadPool\n   * 线程池是什么？为什么要使用它\n   * 如何创建一个Java线程池\n    * ThreadPool用法与优势\n    * 提交任务时，线程池队列已满时会发会生什么\n    * newCache 和 newFixed 有什么区别？简述原理。构造函数的各个参数的含义是什么，比如 coreSize, maxsize 等\n    * 线程池的实现策略\n    * 线程池的关闭方式有几种，各自的区别是什么\n    * 线程池中submit() 和 execute()方法有什么区别？\n* 线程调度\n    * Java中用到的线程调度算法是什么\n    * 什么是多线程中的上下文切换\n    * 你对线程优先级的理解是什么\n    * 什么是线程调度器 (Thread Scheduler) 和时间分片 (Time Slicing)\n* 线程同步\n    * 请说出你所知的线程同步的方法\n    * synchronized 的原理是什么\n    * synchronized 和 ReentrantLock 有什么不同\n    * 什么场景下可以使用 volatile 替换 synchronized\n    * 有T1，T2，T3三个线程，怎么确保它们按顺序执行？怎样保证T2在T1执行完后执行，T3在T2执行完后执行\n    * 同步块内的线程抛出异常会发生什么\n    * 当一个线程进入一个对象的 synchronized 方法A 之后，其它线程是否可进入此对象的 synchronized 方法B\n    * 使用 synchronized 修饰静态方法和非静态方法有什么区别\n    * 如何从给定集合那里创建一个 synchronized 的集合\n* 锁\n    * Java Concurrency API 中 的 Lock 接口是什么？对比同步它有什么优势\n    * Lock 与 Synchronized 的区别？Lock 接口比 synchronized 块的优势是什么\n    * ReadWriteLock是什么？\n    * 锁机制有什么用\n    * 什么是乐观锁（Optimistic Locking）？如何实现乐观锁？如何避免ABA问题\n    * 解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁\n    * 什么时候应该使用可重入锁\n    * 简述锁的等级方法锁、对象锁、类锁\n    * Java中活锁和死锁有什么区别？\n    * 什么是死锁(Deadlock)？导致线程死锁的原因？如何确保 N 个线程可以访问 N 个资源同时又不导致死锁\n    * 死锁与活锁的区别，死锁与饥饿的区别\n    * 怎么检测一个线程是否拥有锁\n    * 如何实现分布式锁\n    * 有哪些无锁数据结构，他们实现的原理是什么\n    * 读写锁可以用于什么应用场景\n* Executors类是什么？ Executor和Executors的区别\n* 什么是Java线程转储(Thread Dump)，如何得到它\n* 如何在Java中获取线程堆栈\n* 说出 3 条在 Java 中使用线程的最佳实践\n* 在线程中你怎么处理不可捕捉异常\n* 实际项目中使用多线程举例。你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的\n* 请说出与线程同步以及线程调度相关的方法\n* 程序中有3个 socket，需要多少个线程来处理\n* 假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有 10 个线程同时调用它，如何做到\n* 如何在 Windows 和 Linux 上查找哪个线程使用的 CPU 时间最长\n* 如何确保 main() 方法所在的线程是 Java 程序最后结束的线程\n* 非常多个线程（可能是不同机器），相互之间需要等待协调才能完成某种工作，问怎么设计这种协调方案\n* 你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它\n\n## 异常\n* 基本概念\n    * Error 和 Exception有什么区别\n        * UnsupportedOperationException是什么\n        * NullPointerException 和 ArrayIndexOutOfBoundException 之间有什么相同之处\n    * 什么是受检查的异常，什么是运行时异常\n    * 运行时异常与一般异常有何异同\n    * 简述一个你最常见到的runtime exception(运行时异常)\n* finally\n    * finally关键词在异常处理中如何使用\n        * 如果执行finally代码块之前方法返回了结果，或者JVM退出了，finally块中的代码还会执行吗\n        * try里有return，finally还执行么？那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后\n        * 在什么情况下，finally语句不会执行\n* throw 和 throws 有什么区别？\n* OOM你遇到过哪些情况？你是怎么搞定的？\n* SOF你遇到过哪些情况？\n* 既然我们可以用RuntimeException来处理错误，那么你认为为什么Java中还存在检查型异常\n* 当自己创建异常类的时候应该注意什么\n* 导致空指针异常的原因\n* 异常处理 handle or declare 原则应该如何理解\n* 怎么利用 JUnit 来测试一个方法的异常\n* catch块里别不写代码有什么问题\n* 你曾经自定义实现过异常吗？怎么写的\n* 什么是 异常链\n* 在try块中可以抛出异常吗\n\n## JDBC\n* 通过 JDBC 连接数据库有哪几种方式\n* 阐述 JDBC 操作数据库的基本步骤\n* JDBC 中如何进行事务处理\n* 什么是 JdbcTemplate\n* 什么是 DAO 模块\n* 使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能\n* 列出 5 个应该遵循的 JDBC 最佳实践\n\n## IO\n* File\n    * File类型中定义了什么方法来创建一级目录\n        * File类型中定义了什么方法来判断一个文件是否存在\n* 流\n    * 为了提高读写性能，可以采用什么流\n    * Java中有几种类型的流\n    * JDK 为每种类型的流提供了一些抽象类以供继承，分别是哪些类\n    * 对文本文件操作用什么I/O流\n    * 对各种基本数据类型和String类型的读写，采用什么流\n    * 能指定字符编码的 I/O 流类型是什么\n* 序列化\n    * 什么是序列化？如何实现 Java 序列化及注意事项\n    * Serializable 与 Externalizable 的区别\n* Socket\n    * socket 选项 TCP NO DELAY 是指什么\n    * Socket 工作在 TCP/IP 协议栈是哪一层\n    * TCP、UDP 区别及 Java 实现方式\n* 说几点 IO 的最佳实践\n* 直接缓冲区与非直接缓冲器有什么区别？\n* 怎么读写 ByteBuffer？ByteBuffer 中的字节序是什么\n* 当用System.in.read(buffer)从键盘输入一行n个字符后，存储在缓冲区buffer中的字节数是多少\n* 如何使用扫描器类（Scanner Class）令牌化\n\n## 面向对象编程（OOP）\n* 解释下多态性（polymorphism），封装性（encapsulation），内聚（cohesion）以及耦合（coupling）\n* 多态的实现原理\n* 封装、继承和多态是什么\n* 对象封装的原则是什么?\n* 类\n    * 获得一个类的类对象有哪些方式\n    * 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？\n    * 说出几条 Java 中方法重载的最佳实践\n* 抽象类\n    * 抽象类和接口的区别\n    * 抽象类中是否可以有静态的main方法\n    * 抽象类是否可实现(implements)接口\n    * 抽象类是否可继承具体类(concrete class)\n* 匿名类（Anonymous Inner Class）\n    * 匿名内部类是否可以继承其它类？是否可以实现接口\n* 内部类\n    * 内部类分为几种\n    * 内部类可以引用它的包含类（外部类）的成员吗\n    * 请说一下 Java 中为什么要引入内部类？还有匿名内部类\n* 继承\n    * 继承（Inheritance）与聚合（Aggregation）的区别在哪里\n    * 继承和组合之间有什么不同\n    * 为什么类只能单继承，接口可以多继承\n    * 存在两个类，B 继承 A，C 继承 B，能将 B 转换为 C 么？如 C = (C) B\n    * 如果类 a 继承类 b，实现接口c，而类 b 和接口 c 中定义了同名变量，请问会出现什么问题\n* 接口\n    * 接口是什么\n    * 接口是否可继承接口\n    * 为什么要使用接口而不是直接使用具体类？接口有什么优点\n\n## 泛型\n* 泛型的存在是用来解决什么问题\n* 泛型的常用特点\n* List<String>能否转为List<Object>\n\n## 工具类\n* 日历\n    * Calendar Class的用途\n    * 如何在Java中获取日历类的实例\n    * 解释一些日历类中的重要方法\n     * GregorianCalendar 类是什么\n     * SimpleTimeZone 类是什么\n     * Locale类是什么\n     * 如何格式化日期对象\n     * 如何添加小时(hour)到一个日期对象(Date Objects)\n     * 如何将字符串 YYYYMMDD 转换为日期\n* Math\n    * Math.round()什么作用？Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？\n* XML\n    * XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？DOM 和 SAX 解析器有什么不同？\n    * Java解析XML的方式\n    * 用 jdom 解析 xml 文件时如何解决中文问题？如何解析\n    * 你在项目中用到了 XML 技术的哪些方面？如何实现\n\n## 动态代理\n* 描述动态代理的几种实现方式，分别说出相应的优缺点\n\n## 设计模式\n* 什么是设计模式（Design Patterns）？你用过哪种设计模式？用在什么场合\n* 你知道哪些商业级设计模式？\n* 哪些设计模式可以增加系统的可扩展性\n* 单例模式\n    * 除了单例模式，你在生产环境中还用过什么设计模式？\n    * 写 Singleton 单例模式\n    * 单例模式的双检锁是什么\n    * 如何创建线程安全的 Singleton\n    * 什么是类的单例模式\n    * 写出三种单例模式实现\n* 适配器模式\n    * 适配器模式是什么？什么时候使用\n    * 适配器模式和代理模式之前有什么不同\n    * 适配器模式和装饰器模式有什么区别\n* 什么时候使用享元模式\n* 什么时候使用组合模式\n* 什么时候使用访问者模式\n* 什么是模板方法模式\n* 请给出1个符合开闭原则的设计模式的例子\n\n## 开放问题\n* 用一句话概括 Web 编程的特点\n* Google是如何在一秒内把搜索结果返回给用户\n* 哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入\n* 树（二叉或其他）形成许多普通数据结构的基础。请描述一些这样的数据结构以及何时可以使用它们\n* 某一项功能如何设计\n* 线上系统突然变得异常缓慢，你如何查找问题\n* 什么样的项目不适合用框架\n* 新浪微博是如何实现把微博推给订阅者\n* 简要介绍下从浏览器输入 URL 开始到获取到请求界面之后 Java Web 应用中发生了什么\n* 请你谈谈SSH整合\n* 高并发下，如何做到安全的修改同一行数据\n* 12306网站的订票系统如何实现，如何保证不会票不被超卖\n* 网站性能优化如何优化的\n* 聊了下曾经参与设计的服务器架构\n* 请思考一个方案，实现分布式环境下的 countDownLatch\n* 请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存\n* 在你的职业生涯中，算得上最困难的技术挑战是什么\n* 如何写一篇设计文档，目录是什么\n* 大写的O是什么？举几个例子\n* 编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用\n* 解释一下网络应用的模式及其特点\n* 设计一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新\n* 说出数据连接池的工作机制是什么\n* 怎么获取一个文件中单词出现的最高频率\n* 描述一下你最常用的编程风格\n* 如果有机会重新设计你们的产品，你会怎么做\n* 如何搭建一个高可用系统\n* 如何启动时不需输入用户名与密码\n* 如何在基于Java的Web项目中实现文件上传和下载\n* 如何实现一个秒杀系统，保证只有几位用户能买到某件商品。\n* 如何实现负载均衡，有哪些算法可以实现\n* 如何设计一个购物车？想想淘宝的购物车如何实现的\n* 如何设计一套高并发支付方案，架构如何设计\n* 如何设计建立和保持 100w 的长连接\n* 如何避免浏览器缓存。\n* 如何防止缓存雪崩\n* 如果AB两个系统互相依赖，如何解除依\n* 如果有人恶意创建非法连接，怎么解决\n* 如果有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能\n* 如果系统要使用超大整数（超过long长度范围），请你设计一个数据结构来存储这种超大型数字以及设计一种算法来实现超大整数加法运算）\n* 如果要设计一个图形系统，请你设计基本的图形元件(Point,Line,Rectangle,Triangle)的简单实现\n* 如果让你实现一个并发安全的链表，你会怎么做\n* 应用服务器与WEB 服务器的区别？应用服务器怎么监控性能，各种方式的区别？你使用过的应用服务器优化技术有哪些\n* 大型网站在架构上应当考虑哪些问题\n* 有没有处理过线上问题？出现内存泄露，CPU利用率标高，应用无响应时如何处理的\n* 最近看什么书，印象最深刻的是什么\n* 描述下常用的重构技巧\n* 你使用什么版本管理工具？分支（Branch）与标签（Tag）之间的区别在哪里\n* 你有了解过存在哪些反模式（Anti-Patterns）吗\n* 你用过的网站前端优化的技术有哪些\n* 如何分析Thread dump\n* 你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念\n* 你是如何处理内存泄露或者栈溢出问题的\n* 你们线上应用的 JVM 参数有哪些\n* 怎么提升系统的QPS和吞吐量\n\n## 知识面\n* 解释什么是 MESI 协议(缓存一致性)\n* 谈谈 reactor 模型\n* Java 9 带来了怎样的新功能\n* Java 与 C++ 对比，C++ 或 Java 中的异常处理机制的简单原理和应用\n* 简单讲讲 Tomcat 结构，以及其类加载器流程\n* 虚拟内存是什么\n* 阐述下 SOLID 原则\n* 请简要讲一下你对测试驱动开发（TDD）的认识\n* CDN实现原理\n* Maven 和 ANT 有什么区别\n* UML中有哪些常用的图\n* Linux\n    * Linux 下 IO 模型有几种，各自的含义是什么。\n    * Linux 系统下你关注过哪些内核参数，说说你知道的\n    * Linux 下用一行命令查看文件的最后五行\n    * 平时用到哪些 Linux 命令\n    * 用一行命令输出正在运行的 Java 进程\n    * 使用什么命令来确定是否有 Tomcat 实例运行在机器上\n* 什么是 N+1 难题\n* 什么是 paxos 算法\n* 什么是 restful，讲讲你理解的 restful\n* 什么是 zab 协议\n* 什么是领域模型(domain model)？贫血模型(anaemic domain model) 和充血模型(rich domain model)有什么区别\n* 什么是领域驱动开发（Domain Driven Development）\n* 介绍一下了解的 Java 领域的 Web Service 框架\n* Web Server、Web Container 与 Application Server 的区别是什么\n* 微服务（MicroServices）与巨石型应用（Monolithic Applications）之间的区别在哪里\n* 描述 Cookie 和 Session 的作用，区别和各自的应用范围，Session工作原理\n* 你常用的持续集成（Continuous Integration）、静态代码分析（Static Code Analysis）工具有哪些\n* 简述下数据库正则化（Normalizations）\n* KISS,DRY,YAGNI 等原则是什么含义\n* 分布式事务的原理，优缺点，如何使用分布式事务？\n* 布式集群下如何做到唯一序列号\n* 网络\n    * HTTPS 的加密方式是什么，讲讲整个加密解密流程\n    * HTTPS和HTTP的区别\n    * HTTP连接池实现原理\n    * HTTP集群方案\n    * Nginx、lighttpd、Apache三大主流 Web服务器的区别\n* 是否看过框架的一些代码\n* 持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些\n* 数值提升是什么\n* 你能解释一下里氏替换原则吗\n* 你是如何测试一个应用的？知道哪些测试框架\n* 传输层常见编程协议有哪些？并说出各自的特点\n\n## 编程题\n### 计算加班费\n加班10小时以下加班费是时薪的1.5倍。加班10小时或以上，按4元/时算。提示：（一个月工作26天，一天正常工作8小时）\n*  计算1000月薪，加班9小时的加班费\n* 计算2500月薪，加班11小时的加班费\n* 计算1000月薪，加班15小时的加班费\n\n### 卖东西\n一家商场有红苹果和青苹果出售。（红苹果5元/个，青苹果4元/个）。\n* 模拟一个进货。红苹果跟青苹果各进200个。\n* 模拟一个出售。红苹果跟青苹果各买出10个。每卖出一个苹果需要进行统计。\n\n提示：一个苹果是一个单独的实体。\n\n### 日期提取\n有这样一个时间字符串：2008-8-8 20:08:08 ， 请编写能够匹配它的正则表达式，并编写Java代码将日期后面的时分秒提取出来，即：20:08:08\n\n### 线程\n* 8设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。\n* 用Java写一个多线程程序，如写四个线程，二个加1，二个对一个变量减一，输出\n* wait-notify 写一段代码来解决生产者-消费者问题\n\n### 数字\n* 判断101-200之间有多少个素数，并输出所有素数\n* 用最有效率的方法算出2乘以17等于多少\n* 有 1 亿个数字，其中有 2 个是重复的，快速找到它，时间和空间要最优\n* 2 亿个随机生成的无序整数,找出中间大小的值\n* 10 亿个数字里里面找最小的 10 个\n* 1到1亿的自然数，求所有数的拆分后的数字之和，如286 拆分成2、8、6，如1到11拆分后的数字之和 => 1 + ... + 9 + 1 + 0 + 1 + 1\n* 一个数如果恰好等于它的因子之和，这个数就称为 “完数 “。例如6=1＋2＋3.编程   找出1000以内的所有完数\n* 一个数组中所有的元素都出现了三次，只有一个元素出现了一次找到这个元素\n* 一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在   第10次落地时，共经过多少米？第10次反弹多高？\n* 求100－1000内质数的和\n* 求1到100的和的平均数\n* 求s=a+a+aaa+aaaa+aa…a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加有键盘控制。 求出1到100的和\n* 算出1到40的质数，放进数组里\n    *  显示放组里的数\n    *  找出第[5]个数\n    *  删除第[9]个数，再显示删除后的第[9]个\n* 有 3n+1 个数字，其中 3n 个中是重复的，只有 1 个是不重复的，怎么找出来。\n* 有一组数1.1.2.3.5.8.13.21.34。写出程序随便输入一个数就能给出和前一组数字同规律的头5个数\n* 计算指定数字的阶乘\n* 开发 Fizz Buzz\n* 给定一个包含 N 个整数的数组，找出丢失的整数\n* 一个排好序的数组，找出两数之和为m的所有组合\n* 将一个正整数分解质因数。例如：输入90,打印出90=2\\*3\\*3\\*5。\n* 打印出所有的 “水仙花数 “，所谓 “水仙花数 “是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个 “水仙花数 “，因为153=1的三次方＋5的三次方＋3的三次方\n* 原地交换两个变量的值\n* 找出4字节整数的中位数\n* 找到整数的平方根\n* 实现斐波那契\n\n### 网络\n* 用Java Socket编程，读服务器几个字符，再写入本地显示\n\n## 反射\n* 反射机制提供了什么功能？\n* 反射是如何实现的\n* 哪里用到反射机制\n* 反射中 Class.forName 和 ClassLoader 区别\n* 反射创建类实例的三种方式是什么\n* 如何通过反射调用对象的方法\n* 如何通过反射获取和设置对象私有字段的值\n* 反射机制的优缺点\n\n### 数据库\n* 写一段 JDBC 连Oracle的程序,并实现数据查询\n\n### 算法\n* 50个人围坐一圈，当数到三或者三的倍数出圈，问剩下的人是谁，原来的位置是多少\n* 实现一个电梯模拟器用\n* 写一个冒泡排序\n* 写一个折半查找\n* 随机产生20个不能重复的字符并排序\n* 写一个函数，传入 2 个有序的整数数组，返回一个有序的整数数组\n* 写一段代码在遍历 ArrayList 时移除一个元素\n* 古典问题：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第四个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少\n* 约瑟芬环游戏\n\n### 正则\n* 请编写一段匹配IP地址的正则表达式\n* 写出一个正则表达式来判断一个字符串是否是一个数字\n\n### 字符串\n* 写一个方法，入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。\n* 写一个程序找出所有字符串的组合，并检查它们是否是回文串\n* 写一个字符串反转函数，输入abcde转换成edcba代码\n* 小游戏，倒转句子中的单词\n* 将GB2312编码的字符串转换为ISO-8859-1编码的字符串\n* 请写一段代码来计算给定文本内字符“A”的个数。分别用迭代和递归两种方式\n* 编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串。 但是要保证汉字不被截半个，如“我ABC”4，应该截为“我AB”，输入“我ABC汉DEF”，6，应该输出为“我ABC”而不是“我ABC+汉的半个”\n* 给定 2 个包含单词列表（每行一个）的文件，编程列出交集\n* 打印出一个字符串的所有排列\n* 将一个键盘输入的数字转化成中文输出(例如：输入1234567，输出:一百二拾三万四千五百六拾七)\n* 在Web应用开发过程中经常遇到输出某种编码的字符，如从 GBK 到 ISO8859-1等，如何输出一个某种编码的字符串\n\n## 日期\n* 计算两个日期之间的差距\n\n## 其他\n* mysql表数据压缩","source":"_posts/26Java面试题.md","raw":"---\ntitle: Java面试题\ndate: 2017-11-16 14:49:51\ntags:\n---\n\n# Java面试资源\n这里汇总整理了网络上的Java面试题，持续更新\n<!--more-->\n## 基本概念\n* 操作系统中 heap 和 stack 的区别\n* 什么是基于注解的切面实现\n* 什么是 对象/关系 映射集成模块\n* 什么是 Java 的反射机制\n* 什么是 ACID\n* BS与CS的联系与区别\n* Cookie 和 Session的区别\n* fail-fast 与 fail-safe 机制有什么区别\n* get 和 post请求的区别\n* Interface 与 abstract 类的区别\n* IOC的优点是什么\n* IO 和 NIO的区别，NIO优点\n* Java 8 / Java 7 为我们提供了什么新功能\n* 什么是竞态条件？ 举个例子说明。\n* JRE、JDK、JVM 及 JIT 之间有什么不同\n* MVC的各个部分都有那些技术来实现?如何实现?\n* RPC 通信和 RMI 区别\n* 什么是 Web Service（Web服务）\n* JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。\n* WEB容器主要有哪些功能? 并请列出一些常见的WEB容器名字。\n* 一个\".java\"源文件中是否可以包含多个类（不是内部类）？有什么限制\n* 简单说说你了解的类加载器。是否实现过类加载器\n* 解释一下什么叫AOP（面向切面编程）\n* 请简述 Servlet 的生命周期及其相关的方法\n* 请简述一下 Ajax 的原理及实现步骤\n* 简单描述Struts的主要功能\n* 什么是 N 层架构\n* 什么是CORBA？用途是什么\n* 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”\n* 什么是正则表达式？用途是什么？哪个包使用正则表达式来实现模式匹配\n* 什么是懒加载（Lazy Loading）\n* 什么是尾递归，为什么需要尾递归\n* 什么是控制反转（Inversion of Control）与依赖注入（Dependency Injection）\n\n## 关键字\n* finalize\n    * 什么是finalize()方法\n        * finalize()方法什么时候被调用\n        * 析构函数(finalization)的目的是什么\n        * final 和 finalize 的区别\n        * final\n    * final关键字有哪些用法\n        * final 与 static 关键字可以用于哪里？它们的作用是什么\n        * final, finally, finalize的区别\n        * final、finalize 和 finally 的不同之处？\n    * 能否在运行时向 static final 类型的赋值\n        * 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变\n        * 一个类被声明为final类型，表示了什么意思\n        * throws, throw, try, catch, finally分别代表什么意义\n* Java 有几种修饰符？分别用来修饰什么\n* volatile\n    * volatile 修饰符的有过什么实践\n    * volatile 变量是什么？volatile 变量和 atomic 变量有什么不同\n    * volatile 类型变量提供什么保证？能使得一个非原子操作变成原子操作吗\n    * 能创建 volatile 数组吗？\n* transient变量有什么特点\n* super什么时候使用\n* public static void 写成 static public void会怎样\n* 说明一下public static void main(String args[])这段声明里每个关键字的作用\n* 请说出作用域public, private, protected, 以及不写时的区别\n* sizeof 是Java 的关键字吗\n* static\n     * static class 与 non static class的区别\n     * static 关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法\n     * 静态类型有什么特点\n     * main() 方法为什么必须是静态的？能不能声明 main() 方法为非静态\n     * 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用\n     * 静态变量在什么时候加载？编译期还是运行期？静态代码块加载的时机呢\n     * 成员方法是否可以访问静态变量？为什么静态方法不能访问成员变量\n* switch\n     * switch 语句中的表达式可以是什么类型数据\n     * switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上\n* while 循环和 do 循环有什么不同\n\n## 操作符\n* &操作符和&&操作符有什么区别?\n* a = a + b 与 a += b 的区别？\n* 逻辑操作符 (&,|,^)与条件操作符(&&,||)的区别\n* 3\\*0.1 == 0.3 将会返回什么？true 还是 false？\n* float f=3.4; 是否正确？\n* short s1 = 1; s1 = s1 + 1;有什么错?\n\n## 数据结构\n* 基础类型(Primitives)\n    * 基础类型(Primitives)与封装类型(Wrappers)的区别在哪里\n    * 简述九种基本数据类型的大小，以及他们的封装类\n    * int 和 Integer 哪个会占用更多的内存？ int 和 Integer 有什么区别？parseInt()函数在什么时候使用到\n    * float和double的默认值是多少\n    * 如何去小数四舍五入保留小数点后两位\n    * char 型变量中能不能存贮一个中文汉字，为什么\n* 类型转换\n    * 怎样将 bytes 转换为 long 类型\n    * 怎么将 byte 转换为 String\n    * 如何将数值型字符转换为数字\n    * 我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象\n    * 能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗\n    * 类型向下转换是什么\n* 数组\n   * 如何权衡是使用无序的数组还是有序的数组\n   * 怎么判断数组是 null 还是为空\n   * 怎么打印数组？ 怎样打印数组中的重复元素\n   * Array 和 ArrayList有什么区别？什么时候应该使用Array而不是ArrayList\n   * 数组和链表数据结构描述，各自的时间复杂度\n   * 数组有没有length()这个方法? String有没有length()这个方法\n* 队列\n   * 队列和栈是什么，列出它们的区别\n   * BlockingQueue是什么\n   * 简述 ConcurrentLinkedQueue LinkedBlockingQueue 的用处和不同之处。\n* ArrayList、Vector、LinkedList的存储性能和特性\n* String\n* StringBuffer\n    * ByteBuffer 与 StringBuffer有什么区别\n* HashMap\n    * HashMap的工作原理是什么\n    * 内部的数据结构是什么\n    * HashMap 的 table的容量如何确定？loadFactor 是什么？ 该容量如何变化？这种变化会带来什么问题？\n    * HashMap 实现的数据结构是什么？如何实现\n    * HashMap 和 HashTable、ConcurrentHashMap 的区别\n    * HashMap的遍历方式及效率\n    * HashMap、LinkedMap、TreeMap的区别\n    * 如何决定选用HashMap还是TreeMap\n    * 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办\n    * HashMap 是线程安全的吗？并发下使用的 Map 是什么，它们内部原理分别是什么，比如存储方式、 hashcode、扩容、 默认容量等\n* HashSet\n    * HashSet和TreeSet有什么区别\n    * HashSet 内部是如何工作的\n    * WeakHashMap 是怎么工作的？\n* Set\n    * Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢？是用 == 还是 equals()？ 它们有何区别?\n    * TreeMap：TreeMap 是采用什么树实现的？TreeMap、HashMap、LindedHashMap的区别。TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？\n    * TreeSet：一个已经构建好的 TreeSet，怎么完成倒排序。\n    * EnumSet 是什么\n* Hash算法\n    * Hashcode 的作用\n    * 简述一致性 Hash 算法\n    * 有没有可能 两个不相等的对象有相同的 hashcode？当两个对象 hashcode 相同怎么办？如何获取值对象\n    * 为什么在重写 equals 方法的时候需要重写 hashCode 方法？equals与 hashCode 的异同点在哪里\n    * a.hashCode() 有什么用？与 a.equals(b) 有什么关系\n    * hashCode() 和 equals() 方法的重要性体现在什么地方\n    * Object：Object有哪些公用方法？Object类hashcode,equals 设计原则？ sun为什么这么设计？Object类的概述\n    * 如何在父类中为子类自动完成所有的 hashcode 和 equals 实现？这么做有何优劣。\n    * 可以在 hashcode() 中使用随机数字吗？\n* LinkedHashMap\n    * LinkedHashMap 和 PriorityQueue 的区别是什么\n* List\n    * List, Set, Map三个接口，存取元素时各有什么特点\n    * List, Set, Map 是否继承自 Collection 接口\n    * 遍历一个 List 有哪些不同的方式\n    * LinkedList\n        * LinkedList 是单向链表还是双向链表\n        * LinkedList 与 ArrayList 有什么区别\n        * 描述下 Java 中集合（Collections），接口（Interfaces），实现（Implementations）的概念。LinkedList 与 ArrayList 的区别是什么？\n        * 插入数据时，ArrayList, LinkedList, Vector谁速度较快？\n    * ArrayList\n        * ArrayList 和 HashMap 的默认大小是多数\n        * ArrayList 和 LinkedList 的区别，什么时候用 ArrayList？\n        * ArrayList 和 Set 的区别？\n        * ArrayList, LinkedList, Vector的区别\n        * ArrayList是如何实现的，ArrayList 和 LinkedList 的区别\n        * ArrayList如何实现扩容\n        * Array 和 ArrayList 有何区别？什么时候更适合用Array\n        * 说出ArraList,Vector, LinkedList的存储性能和特性\n* Map\n    * Map, Set, List, Queue, Stack\n    * Map 接口提供了哪些不同的集合视图\n    * 为什么 Map 接口不继承 Collection 接口\n* Collections\n    * 介绍Java中的Collection FrameWork。集合类框架的基本接口有哪些\n    * Collections类是什么？Collection 和 Collections的区别？Collection、Map的实现\n    * 集合类框架的最佳实践有哪些\n    * 为什么 Collection 不从 Cloneable 和 Serializable 接口继承\n    * 说出几点 Java 中使用 Collections 的最佳实践？\n    * Collections 中 遗留类 (HashTable、Vector) 和 现有类的区别\n*  什么是 B+树，B-树，列出实际的使用场景。\n\n## 接口\n* Comparator 与 Comparable 接口是干什么的？列出它们的区别\n\n## 对象\n* 拷贝(clone)\n    * 如何实现对象克隆\n    * 深拷贝和浅拷贝区别\n    * 深拷贝和浅拷贝如何实现激活机制\n    * 写clone()方法时，通常都有一行代码，是什么\n* 比较\n    * 在比较对象时，\"==\" 运算符和 equals 运算有何区别\n    * 如果要重写一个对象的equals方法，还要考虑什么\n    * 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对\n* 构造器\n    * 构造器链是什么\n    * 创建对象时构造器的调用顺序\n* 不可变对象\n    * 什么是不可变象（immutable object）\n    * 为什么 Java 中的 String 是不可变的（Immutable）\n    * 如何构建不可变的类结构？关键点在哪里\n    * 能创建一个包含可变对象的不可变对象吗\n* 如何对一组对象进行排序\n\n## 方法\n* 构造器（constructor）是否可被重写（override）\n* 方法可以同时即是 static 又是 synchronized 的吗\n* abstract 的 method是否可同时是 static，是否可同时是 native，是否可同时是synchronized\n* Java支持哪种参数传递类型\n* 一个对象被当作参数传递到一个方法，是值传递还是引用传递\n* 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递\n* 我们能否重载main()方法\n* 如果main方法被声明为private会怎样\n\n## GC\n* 概念\n    * GC是什么？为什么要有GC\n    * 什么时候会导致垃圾回收\n    * GC是怎么样运行的\n    * 新老以及永久区是什么\n    * GC 有几种方式？怎么配置\n    * 什么时候一个对象会被GC？ 如何判断一个对象是否存活\n    * System.gc()  Runtime.gc()会做什么事情？  能保证 GC 执行吗\n    * 垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？\n    * Minor GC 、Major GC、Young GC 与 Full GC分别在什么时候发生\n    * 垃圾回收算法的实现原理\n    * 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？\n    * 垃圾回收的最佳做法是什么\n* GC收集器有哪些\n     * 垃圾回收器的基本原理是什么？\n     * 串行(serial)收集器和吞吐量(throughput)收集器的区别是什么\n    * Serial 与 Parallel GC之间的不同之处\n    * CMS 收集器 与 G1 收集器的特点与区别\n    * CMS垃圾回收器的工作过程\n    * JVM 中一次完整的 GC 流程是怎样的？ 对象如何晋升到老年代\n    * 吞吐量优先和响应优先的垃圾收集器选择\n* GC策略\n     * 举个实际的场景，选择一个GC策略\n     * JVM的永久代中会发生垃圾回收吗\n* 收集方法\n    * 标记清除、标记整理、复制算法的原理与特点？分别用在什么地方\n    * 如果让你优化收集方法，有什么思路\n\n## JVM\n* 参数\n    * 说说你知道的几种主要的jvm 参数\n    * -XX:+UseCompressedOops 有什么作用\n* 类加载器(ClassLoader)\n    * Java 类加载器都有哪些\n    * JVM如何加载字节码文件\n* 内存管理\n    * JVM内存分哪几个区，每个区的作用是什么\n    * 一个对象从创建到销毁都是怎么在这些部分里存活和转移的\n    *  解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法\n    * JVM中哪个参数是用来控制线程的栈堆栈小\n    *  简述内存分配与回收策略\n    *  简述重排序，内存屏障，happen-before，主内存，工作内存\n    * Java中存在内存泄漏问题吗？请举例说明\n    * 简述 Java 中软引用（SoftReferenc）、弱引用（WeakReference）和虚引用\n    * 内存映射缓存区是什么\n* jstack，jstat，jmap，jconsole怎么用\n* 32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？32 位和 64 位的 JVM，int 类型变量的长度是多数？\n* 怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位\n* JVM自身会维护缓存吗？是不是在堆中进行对象分配，操作系统的堆还是JVM自己管理堆\n* 什么情况下会发生栈内存溢出\n* 双亲委派模型是什么\n\n## 多线程\n* 基本概念\n    * 什么是线程\n    * 多线程的优点\n    * 多线程的几种实现方式\n        * 用 Runnable 还是 Thread\n    * 什么是线程安全\n        * Vector, SimpleDateFormat 是线程安全类吗\n        * 什么 Java 原型不是线程安全的\n        * 哪些集合类是线程安全的\n    * 多线程中的忙循环是什么\n    * 如何创建一个线程\n    * 编写多线程程序有几种实现方式\n    * 什么是线程局部变量\n    * 线程和进程有什么区别？进程间如何通讯，线程间如何通讯\n    * 什么是多线程环境下的伪共享（false sharing）\n    * 同步和异步有何异同，在什么情况下分别使用他们？举例说明\n* Current\n    * ConcurrentHashMap 和 Hashtable的区别\n    * ArrayBlockingQueue, CountDownLatch的用法\n    * ConcurrentHashMap的并发度是什么\n* CyclicBarrier 和 CountDownLatch有什么不同？各自的内部原理和用法是什么\n* Semaphore的用法\n* Thread\n    * 启动一个线程是调用 run() 还是 start() 方法？start() 和 run() 方法有什么区别\n    * 调用start()方法时会执行run()方法，为什么不能直接调用run()方法\n    * sleep() 方法和对象的 wait() 方法都可以让线程暂停执行，它们有什么区别\n    * yield方法有什么作用？sleep() 方法和 yield() 方法有什么区别\n    * Java 中如何停止一个线程\n    * stop() 和 suspend() 方法为何不推荐使用\n    * 如何在两个线程间共享数据\n    * 如何强制启动一个线程\n    * 如何让正在运行的线程暂停一段时间\n    * 什么是线程组，为什么在Java中不推荐使用\n    * 你是如何调用  wait（方法的）？使用 if 块还是循环？为什么\n* 生命周期\n    * 有哪些不同的线程生命周期\n    * 线程状态，BLOCKED 和 WAITING 有什么区别\n    * 画一个线程的生命周期状态图\n* ThreadLocal 用途是什么，原理是什么，用的时候要注意什么\n* ThreadPool\n   * 线程池是什么？为什么要使用它\n   * 如何创建一个Java线程池\n    * ThreadPool用法与优势\n    * 提交任务时，线程池队列已满时会发会生什么\n    * newCache 和 newFixed 有什么区别？简述原理。构造函数的各个参数的含义是什么，比如 coreSize, maxsize 等\n    * 线程池的实现策略\n    * 线程池的关闭方式有几种，各自的区别是什么\n    * 线程池中submit() 和 execute()方法有什么区别？\n* 线程调度\n    * Java中用到的线程调度算法是什么\n    * 什么是多线程中的上下文切换\n    * 你对线程优先级的理解是什么\n    * 什么是线程调度器 (Thread Scheduler) 和时间分片 (Time Slicing)\n* 线程同步\n    * 请说出你所知的线程同步的方法\n    * synchronized 的原理是什么\n    * synchronized 和 ReentrantLock 有什么不同\n    * 什么场景下可以使用 volatile 替换 synchronized\n    * 有T1，T2，T3三个线程，怎么确保它们按顺序执行？怎样保证T2在T1执行完后执行，T3在T2执行完后执行\n    * 同步块内的线程抛出异常会发生什么\n    * 当一个线程进入一个对象的 synchronized 方法A 之后，其它线程是否可进入此对象的 synchronized 方法B\n    * 使用 synchronized 修饰静态方法和非静态方法有什么区别\n    * 如何从给定集合那里创建一个 synchronized 的集合\n* 锁\n    * Java Concurrency API 中 的 Lock 接口是什么？对比同步它有什么优势\n    * Lock 与 Synchronized 的区别？Lock 接口比 synchronized 块的优势是什么\n    * ReadWriteLock是什么？\n    * 锁机制有什么用\n    * 什么是乐观锁（Optimistic Locking）？如何实现乐观锁？如何避免ABA问题\n    * 解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁\n    * 什么时候应该使用可重入锁\n    * 简述锁的等级方法锁、对象锁、类锁\n    * Java中活锁和死锁有什么区别？\n    * 什么是死锁(Deadlock)？导致线程死锁的原因？如何确保 N 个线程可以访问 N 个资源同时又不导致死锁\n    * 死锁与活锁的区别，死锁与饥饿的区别\n    * 怎么检测一个线程是否拥有锁\n    * 如何实现分布式锁\n    * 有哪些无锁数据结构，他们实现的原理是什么\n    * 读写锁可以用于什么应用场景\n* Executors类是什么？ Executor和Executors的区别\n* 什么是Java线程转储(Thread Dump)，如何得到它\n* 如何在Java中获取线程堆栈\n* 说出 3 条在 Java 中使用线程的最佳实践\n* 在线程中你怎么处理不可捕捉异常\n* 实际项目中使用多线程举例。你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的\n* 请说出与线程同步以及线程调度相关的方法\n* 程序中有3个 socket，需要多少个线程来处理\n* 假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有 10 个线程同时调用它，如何做到\n* 如何在 Windows 和 Linux 上查找哪个线程使用的 CPU 时间最长\n* 如何确保 main() 方法所在的线程是 Java 程序最后结束的线程\n* 非常多个线程（可能是不同机器），相互之间需要等待协调才能完成某种工作，问怎么设计这种协调方案\n* 你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它\n\n## 异常\n* 基本概念\n    * Error 和 Exception有什么区别\n        * UnsupportedOperationException是什么\n        * NullPointerException 和 ArrayIndexOutOfBoundException 之间有什么相同之处\n    * 什么是受检查的异常，什么是运行时异常\n    * 运行时异常与一般异常有何异同\n    * 简述一个你最常见到的runtime exception(运行时异常)\n* finally\n    * finally关键词在异常处理中如何使用\n        * 如果执行finally代码块之前方法返回了结果，或者JVM退出了，finally块中的代码还会执行吗\n        * try里有return，finally还执行么？那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后\n        * 在什么情况下，finally语句不会执行\n* throw 和 throws 有什么区别？\n* OOM你遇到过哪些情况？你是怎么搞定的？\n* SOF你遇到过哪些情况？\n* 既然我们可以用RuntimeException来处理错误，那么你认为为什么Java中还存在检查型异常\n* 当自己创建异常类的时候应该注意什么\n* 导致空指针异常的原因\n* 异常处理 handle or declare 原则应该如何理解\n* 怎么利用 JUnit 来测试一个方法的异常\n* catch块里别不写代码有什么问题\n* 你曾经自定义实现过异常吗？怎么写的\n* 什么是 异常链\n* 在try块中可以抛出异常吗\n\n## JDBC\n* 通过 JDBC 连接数据库有哪几种方式\n* 阐述 JDBC 操作数据库的基本步骤\n* JDBC 中如何进行事务处理\n* 什么是 JdbcTemplate\n* 什么是 DAO 模块\n* 使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能\n* 列出 5 个应该遵循的 JDBC 最佳实践\n\n## IO\n* File\n    * File类型中定义了什么方法来创建一级目录\n        * File类型中定义了什么方法来判断一个文件是否存在\n* 流\n    * 为了提高读写性能，可以采用什么流\n    * Java中有几种类型的流\n    * JDK 为每种类型的流提供了一些抽象类以供继承，分别是哪些类\n    * 对文本文件操作用什么I/O流\n    * 对各种基本数据类型和String类型的读写，采用什么流\n    * 能指定字符编码的 I/O 流类型是什么\n* 序列化\n    * 什么是序列化？如何实现 Java 序列化及注意事项\n    * Serializable 与 Externalizable 的区别\n* Socket\n    * socket 选项 TCP NO DELAY 是指什么\n    * Socket 工作在 TCP/IP 协议栈是哪一层\n    * TCP、UDP 区别及 Java 实现方式\n* 说几点 IO 的最佳实践\n* 直接缓冲区与非直接缓冲器有什么区别？\n* 怎么读写 ByteBuffer？ByteBuffer 中的字节序是什么\n* 当用System.in.read(buffer)从键盘输入一行n个字符后，存储在缓冲区buffer中的字节数是多少\n* 如何使用扫描器类（Scanner Class）令牌化\n\n## 面向对象编程（OOP）\n* 解释下多态性（polymorphism），封装性（encapsulation），内聚（cohesion）以及耦合（coupling）\n* 多态的实现原理\n* 封装、继承和多态是什么\n* 对象封装的原则是什么?\n* 类\n    * 获得一个类的类对象有哪些方式\n    * 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？\n    * 说出几条 Java 中方法重载的最佳实践\n* 抽象类\n    * 抽象类和接口的区别\n    * 抽象类中是否可以有静态的main方法\n    * 抽象类是否可实现(implements)接口\n    * 抽象类是否可继承具体类(concrete class)\n* 匿名类（Anonymous Inner Class）\n    * 匿名内部类是否可以继承其它类？是否可以实现接口\n* 内部类\n    * 内部类分为几种\n    * 内部类可以引用它的包含类（外部类）的成员吗\n    * 请说一下 Java 中为什么要引入内部类？还有匿名内部类\n* 继承\n    * 继承（Inheritance）与聚合（Aggregation）的区别在哪里\n    * 继承和组合之间有什么不同\n    * 为什么类只能单继承，接口可以多继承\n    * 存在两个类，B 继承 A，C 继承 B，能将 B 转换为 C 么？如 C = (C) B\n    * 如果类 a 继承类 b，实现接口c，而类 b 和接口 c 中定义了同名变量，请问会出现什么问题\n* 接口\n    * 接口是什么\n    * 接口是否可继承接口\n    * 为什么要使用接口而不是直接使用具体类？接口有什么优点\n\n## 泛型\n* 泛型的存在是用来解决什么问题\n* 泛型的常用特点\n* List<String>能否转为List<Object>\n\n## 工具类\n* 日历\n    * Calendar Class的用途\n    * 如何在Java中获取日历类的实例\n    * 解释一些日历类中的重要方法\n     * GregorianCalendar 类是什么\n     * SimpleTimeZone 类是什么\n     * Locale类是什么\n     * 如何格式化日期对象\n     * 如何添加小时(hour)到一个日期对象(Date Objects)\n     * 如何将字符串 YYYYMMDD 转换为日期\n* Math\n    * Math.round()什么作用？Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？\n* XML\n    * XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？DOM 和 SAX 解析器有什么不同？\n    * Java解析XML的方式\n    * 用 jdom 解析 xml 文件时如何解决中文问题？如何解析\n    * 你在项目中用到了 XML 技术的哪些方面？如何实现\n\n## 动态代理\n* 描述动态代理的几种实现方式，分别说出相应的优缺点\n\n## 设计模式\n* 什么是设计模式（Design Patterns）？你用过哪种设计模式？用在什么场合\n* 你知道哪些商业级设计模式？\n* 哪些设计模式可以增加系统的可扩展性\n* 单例模式\n    * 除了单例模式，你在生产环境中还用过什么设计模式？\n    * 写 Singleton 单例模式\n    * 单例模式的双检锁是什么\n    * 如何创建线程安全的 Singleton\n    * 什么是类的单例模式\n    * 写出三种单例模式实现\n* 适配器模式\n    * 适配器模式是什么？什么时候使用\n    * 适配器模式和代理模式之前有什么不同\n    * 适配器模式和装饰器模式有什么区别\n* 什么时候使用享元模式\n* 什么时候使用组合模式\n* 什么时候使用访问者模式\n* 什么是模板方法模式\n* 请给出1个符合开闭原则的设计模式的例子\n\n## 开放问题\n* 用一句话概括 Web 编程的特点\n* Google是如何在一秒内把搜索结果返回给用户\n* 哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入\n* 树（二叉或其他）形成许多普通数据结构的基础。请描述一些这样的数据结构以及何时可以使用它们\n* 某一项功能如何设计\n* 线上系统突然变得异常缓慢，你如何查找问题\n* 什么样的项目不适合用框架\n* 新浪微博是如何实现把微博推给订阅者\n* 简要介绍下从浏览器输入 URL 开始到获取到请求界面之后 Java Web 应用中发生了什么\n* 请你谈谈SSH整合\n* 高并发下，如何做到安全的修改同一行数据\n* 12306网站的订票系统如何实现，如何保证不会票不被超卖\n* 网站性能优化如何优化的\n* 聊了下曾经参与设计的服务器架构\n* 请思考一个方案，实现分布式环境下的 countDownLatch\n* 请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存\n* 在你的职业生涯中，算得上最困难的技术挑战是什么\n* 如何写一篇设计文档，目录是什么\n* 大写的O是什么？举几个例子\n* 编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用\n* 解释一下网络应用的模式及其特点\n* 设计一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新\n* 说出数据连接池的工作机制是什么\n* 怎么获取一个文件中单词出现的最高频率\n* 描述一下你最常用的编程风格\n* 如果有机会重新设计你们的产品，你会怎么做\n* 如何搭建一个高可用系统\n* 如何启动时不需输入用户名与密码\n* 如何在基于Java的Web项目中实现文件上传和下载\n* 如何实现一个秒杀系统，保证只有几位用户能买到某件商品。\n* 如何实现负载均衡，有哪些算法可以实现\n* 如何设计一个购物车？想想淘宝的购物车如何实现的\n* 如何设计一套高并发支付方案，架构如何设计\n* 如何设计建立和保持 100w 的长连接\n* 如何避免浏览器缓存。\n* 如何防止缓存雪崩\n* 如果AB两个系统互相依赖，如何解除依\n* 如果有人恶意创建非法连接，怎么解决\n* 如果有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能\n* 如果系统要使用超大整数（超过long长度范围），请你设计一个数据结构来存储这种超大型数字以及设计一种算法来实现超大整数加法运算）\n* 如果要设计一个图形系统，请你设计基本的图形元件(Point,Line,Rectangle,Triangle)的简单实现\n* 如果让你实现一个并发安全的链表，你会怎么做\n* 应用服务器与WEB 服务器的区别？应用服务器怎么监控性能，各种方式的区别？你使用过的应用服务器优化技术有哪些\n* 大型网站在架构上应当考虑哪些问题\n* 有没有处理过线上问题？出现内存泄露，CPU利用率标高，应用无响应时如何处理的\n* 最近看什么书，印象最深刻的是什么\n* 描述下常用的重构技巧\n* 你使用什么版本管理工具？分支（Branch）与标签（Tag）之间的区别在哪里\n* 你有了解过存在哪些反模式（Anti-Patterns）吗\n* 你用过的网站前端优化的技术有哪些\n* 如何分析Thread dump\n* 你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念\n* 你是如何处理内存泄露或者栈溢出问题的\n* 你们线上应用的 JVM 参数有哪些\n* 怎么提升系统的QPS和吞吐量\n\n## 知识面\n* 解释什么是 MESI 协议(缓存一致性)\n* 谈谈 reactor 模型\n* Java 9 带来了怎样的新功能\n* Java 与 C++ 对比，C++ 或 Java 中的异常处理机制的简单原理和应用\n* 简单讲讲 Tomcat 结构，以及其类加载器流程\n* 虚拟内存是什么\n* 阐述下 SOLID 原则\n* 请简要讲一下你对测试驱动开发（TDD）的认识\n* CDN实现原理\n* Maven 和 ANT 有什么区别\n* UML中有哪些常用的图\n* Linux\n    * Linux 下 IO 模型有几种，各自的含义是什么。\n    * Linux 系统下你关注过哪些内核参数，说说你知道的\n    * Linux 下用一行命令查看文件的最后五行\n    * 平时用到哪些 Linux 命令\n    * 用一行命令输出正在运行的 Java 进程\n    * 使用什么命令来确定是否有 Tomcat 实例运行在机器上\n* 什么是 N+1 难题\n* 什么是 paxos 算法\n* 什么是 restful，讲讲你理解的 restful\n* 什么是 zab 协议\n* 什么是领域模型(domain model)？贫血模型(anaemic domain model) 和充血模型(rich domain model)有什么区别\n* 什么是领域驱动开发（Domain Driven Development）\n* 介绍一下了解的 Java 领域的 Web Service 框架\n* Web Server、Web Container 与 Application Server 的区别是什么\n* 微服务（MicroServices）与巨石型应用（Monolithic Applications）之间的区别在哪里\n* 描述 Cookie 和 Session 的作用，区别和各自的应用范围，Session工作原理\n* 你常用的持续集成（Continuous Integration）、静态代码分析（Static Code Analysis）工具有哪些\n* 简述下数据库正则化（Normalizations）\n* KISS,DRY,YAGNI 等原则是什么含义\n* 分布式事务的原理，优缺点，如何使用分布式事务？\n* 布式集群下如何做到唯一序列号\n* 网络\n    * HTTPS 的加密方式是什么，讲讲整个加密解密流程\n    * HTTPS和HTTP的区别\n    * HTTP连接池实现原理\n    * HTTP集群方案\n    * Nginx、lighttpd、Apache三大主流 Web服务器的区别\n* 是否看过框架的一些代码\n* 持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些\n* 数值提升是什么\n* 你能解释一下里氏替换原则吗\n* 你是如何测试一个应用的？知道哪些测试框架\n* 传输层常见编程协议有哪些？并说出各自的特点\n\n## 编程题\n### 计算加班费\n加班10小时以下加班费是时薪的1.5倍。加班10小时或以上，按4元/时算。提示：（一个月工作26天，一天正常工作8小时）\n*  计算1000月薪，加班9小时的加班费\n* 计算2500月薪，加班11小时的加班费\n* 计算1000月薪，加班15小时的加班费\n\n### 卖东西\n一家商场有红苹果和青苹果出售。（红苹果5元/个，青苹果4元/个）。\n* 模拟一个进货。红苹果跟青苹果各进200个。\n* 模拟一个出售。红苹果跟青苹果各买出10个。每卖出一个苹果需要进行统计。\n\n提示：一个苹果是一个单独的实体。\n\n### 日期提取\n有这样一个时间字符串：2008-8-8 20:08:08 ， 请编写能够匹配它的正则表达式，并编写Java代码将日期后面的时分秒提取出来，即：20:08:08\n\n### 线程\n* 8设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。\n* 用Java写一个多线程程序，如写四个线程，二个加1，二个对一个变量减一，输出\n* wait-notify 写一段代码来解决生产者-消费者问题\n\n### 数字\n* 判断101-200之间有多少个素数，并输出所有素数\n* 用最有效率的方法算出2乘以17等于多少\n* 有 1 亿个数字，其中有 2 个是重复的，快速找到它，时间和空间要最优\n* 2 亿个随机生成的无序整数,找出中间大小的值\n* 10 亿个数字里里面找最小的 10 个\n* 1到1亿的自然数，求所有数的拆分后的数字之和，如286 拆分成2、8、6，如1到11拆分后的数字之和 => 1 + ... + 9 + 1 + 0 + 1 + 1\n* 一个数如果恰好等于它的因子之和，这个数就称为 “完数 “。例如6=1＋2＋3.编程   找出1000以内的所有完数\n* 一个数组中所有的元素都出现了三次，只有一个元素出现了一次找到这个元素\n* 一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在   第10次落地时，共经过多少米？第10次反弹多高？\n* 求100－1000内质数的和\n* 求1到100的和的平均数\n* 求s=a+a+aaa+aaaa+aa…a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加有键盘控制。 求出1到100的和\n* 算出1到40的质数，放进数组里\n    *  显示放组里的数\n    *  找出第[5]个数\n    *  删除第[9]个数，再显示删除后的第[9]个\n* 有 3n+1 个数字，其中 3n 个中是重复的，只有 1 个是不重复的，怎么找出来。\n* 有一组数1.1.2.3.5.8.13.21.34。写出程序随便输入一个数就能给出和前一组数字同规律的头5个数\n* 计算指定数字的阶乘\n* 开发 Fizz Buzz\n* 给定一个包含 N 个整数的数组，找出丢失的整数\n* 一个排好序的数组，找出两数之和为m的所有组合\n* 将一个正整数分解质因数。例如：输入90,打印出90=2\\*3\\*3\\*5。\n* 打印出所有的 “水仙花数 “，所谓 “水仙花数 “是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个 “水仙花数 “，因为153=1的三次方＋5的三次方＋3的三次方\n* 原地交换两个变量的值\n* 找出4字节整数的中位数\n* 找到整数的平方根\n* 实现斐波那契\n\n### 网络\n* 用Java Socket编程，读服务器几个字符，再写入本地显示\n\n## 反射\n* 反射机制提供了什么功能？\n* 反射是如何实现的\n* 哪里用到反射机制\n* 反射中 Class.forName 和 ClassLoader 区别\n* 反射创建类实例的三种方式是什么\n* 如何通过反射调用对象的方法\n* 如何通过反射获取和设置对象私有字段的值\n* 反射机制的优缺点\n\n### 数据库\n* 写一段 JDBC 连Oracle的程序,并实现数据查询\n\n### 算法\n* 50个人围坐一圈，当数到三或者三的倍数出圈，问剩下的人是谁，原来的位置是多少\n* 实现一个电梯模拟器用\n* 写一个冒泡排序\n* 写一个折半查找\n* 随机产生20个不能重复的字符并排序\n* 写一个函数，传入 2 个有序的整数数组，返回一个有序的整数数组\n* 写一段代码在遍历 ArrayList 时移除一个元素\n* 古典问题：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第四个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少\n* 约瑟芬环游戏\n\n### 正则\n* 请编写一段匹配IP地址的正则表达式\n* 写出一个正则表达式来判断一个字符串是否是一个数字\n\n### 字符串\n* 写一个方法，入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。\n* 写一个程序找出所有字符串的组合，并检查它们是否是回文串\n* 写一个字符串反转函数，输入abcde转换成edcba代码\n* 小游戏，倒转句子中的单词\n* 将GB2312编码的字符串转换为ISO-8859-1编码的字符串\n* 请写一段代码来计算给定文本内字符“A”的个数。分别用迭代和递归两种方式\n* 编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串。 但是要保证汉字不被截半个，如“我ABC”4，应该截为“我AB”，输入“我ABC汉DEF”，6，应该输出为“我ABC”而不是“我ABC+汉的半个”\n* 给定 2 个包含单词列表（每行一个）的文件，编程列出交集\n* 打印出一个字符串的所有排列\n* 将一个键盘输入的数字转化成中文输出(例如：输入1234567，输出:一百二拾三万四千五百六拾七)\n* 在Web应用开发过程中经常遇到输出某种编码的字符，如从 GBK 到 ISO8859-1等，如何输出一个某种编码的字符串\n\n## 日期\n* 计算两个日期之间的差距\n\n## 其他\n* mysql表数据压缩","slug":"26Java面试题","published":1,"updated":"2018-12-13T09:16:57.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tcap0020a7xwqv6156dz","content":"<h1 id=\"Java面试资源\"><a href=\"#Java面试资源\" class=\"headerlink\" title=\"Java面试资源\"></a>Java面试资源</h1><p>这里汇总整理了网络上的Java面试题，持续更新<br><a id=\"more\"></a></p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><ul>\n<li>操作系统中 heap 和 stack 的区别</li>\n<li>什么是基于注解的切面实现</li>\n<li>什么是 对象/关系 映射集成模块</li>\n<li>什么是 Java 的反射机制</li>\n<li>什么是 ACID</li>\n<li>BS与CS的联系与区别</li>\n<li>Cookie 和 Session的区别</li>\n<li>fail-fast 与 fail-safe 机制有什么区别</li>\n<li>get 和 post请求的区别</li>\n<li>Interface 与 abstract 类的区别</li>\n<li>IOC的优点是什么</li>\n<li>IO 和 NIO的区别，NIO优点</li>\n<li>Java 8 / Java 7 为我们提供了什么新功能</li>\n<li>什么是竞态条件？ 举个例子说明。</li>\n<li>JRE、JDK、JVM 及 JIT 之间有什么不同</li>\n<li>MVC的各个部分都有那些技术来实现?如何实现?</li>\n<li>RPC 通信和 RMI 区别</li>\n<li>什么是 Web Service（Web服务）</li>\n<li>JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。</li>\n<li>WEB容器主要有哪些功能? 并请列出一些常见的WEB容器名字。</li>\n<li>一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制</li>\n<li>简单说说你了解的类加载器。是否实现过类加载器</li>\n<li>解释一下什么叫AOP（面向切面编程）</li>\n<li>请简述 Servlet 的生命周期及其相关的方法</li>\n<li>请简述一下 Ajax 的原理及实现步骤</li>\n<li>简单描述Struts的主要功能</li>\n<li>什么是 N 层架构</li>\n<li>什么是CORBA？用途是什么</li>\n<li>什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”</li>\n<li>什么是正则表达式？用途是什么？哪个包使用正则表达式来实现模式匹配</li>\n<li>什么是懒加载（Lazy Loading）</li>\n<li>什么是尾递归，为什么需要尾递归</li>\n<li>什么是控制反转（Inversion of Control）与依赖注入（Dependency Injection）</li>\n</ul>\n<h2 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h2><ul>\n<li>finalize<ul>\n<li>什么是finalize()方法<ul>\n<li>finalize()方法什么时候被调用</li>\n<li>析构函数(finalization)的目的是什么</li>\n<li>final 和 finalize 的区别</li>\n<li>final</li>\n</ul>\n</li>\n<li>final关键字有哪些用法<ul>\n<li>final 与 static 关键字可以用于哪里？它们的作用是什么</li>\n<li>final, finally, finalize的区别</li>\n<li>final、finalize 和 finally 的不同之处？</li>\n</ul>\n</li>\n<li>能否在运行时向 static final 类型的赋值<ul>\n<li>使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变</li>\n<li>一个类被声明为final类型，表示了什么意思</li>\n<li>throws, throw, try, catch, finally分别代表什么意义</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Java 有几种修饰符？分别用来修饰什么</li>\n<li>volatile<ul>\n<li>volatile 修饰符的有过什么实践</li>\n<li>volatile 变量是什么？volatile 变量和 atomic 变量有什么不同</li>\n<li>volatile 类型变量提供什么保证？能使得一个非原子操作变成原子操作吗</li>\n<li>能创建 volatile 数组吗？</li>\n</ul>\n</li>\n<li>transient变量有什么特点</li>\n<li>super什么时候使用</li>\n<li>public static void 写成 static public void会怎样</li>\n<li>说明一下public static void main(String args[])这段声明里每个关键字的作用</li>\n<li>请说出作用域public, private, protected, 以及不写时的区别</li>\n<li>sizeof 是Java 的关键字吗</li>\n<li>static<ul>\n<li>static class 与 non static class的区别</li>\n<li>static 关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法</li>\n<li>静态类型有什么特点</li>\n<li>main() 方法为什么必须是静态的？能不能声明 main() 方法为非静态</li>\n<li>是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用</li>\n<li>静态变量在什么时候加载？编译期还是运行期？静态代码块加载的时机呢</li>\n<li>成员方法是否可以访问静态变量？为什么静态方法不能访问成员变量</li>\n</ul>\n</li>\n<li>switch<ul>\n<li>switch 语句中的表达式可以是什么类型数据</li>\n<li>switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上</li>\n</ul>\n</li>\n<li>while 循环和 do 循环有什么不同</li>\n</ul>\n<h2 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h2><ul>\n<li>&amp;操作符和&amp;&amp;操作符有什么区别?</li>\n<li>a = a + b 与 a += b 的区别？</li>\n<li>逻辑操作符 (&amp;,|,^)与条件操作符(&amp;&amp;,||)的区别</li>\n<li>3*0.1 == 0.3 将会返回什么？true 还是 false？</li>\n<li>float f=3.4; 是否正确？</li>\n<li>short s1 = 1; s1 = s1 + 1;有什么错?</li>\n</ul>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><ul>\n<li>基础类型(Primitives)<ul>\n<li>基础类型(Primitives)与封装类型(Wrappers)的区别在哪里</li>\n<li>简述九种基本数据类型的大小，以及他们的封装类</li>\n<li>int 和 Integer 哪个会占用更多的内存？ int 和 Integer 有什么区别？parseInt()函数在什么时候使用到</li>\n<li>float和double的默认值是多少</li>\n<li>如何去小数四舍五入保留小数点后两位</li>\n<li>char 型变量中能不能存贮一个中文汉字，为什么</li>\n</ul>\n</li>\n<li>类型转换<ul>\n<li>怎样将 bytes 转换为 long 类型</li>\n<li>怎么将 byte 转换为 String</li>\n<li>如何将数值型字符转换为数字</li>\n<li>我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象</li>\n<li>能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗</li>\n<li>类型向下转换是什么</li>\n</ul>\n</li>\n<li>数组<ul>\n<li>如何权衡是使用无序的数组还是有序的数组</li>\n<li>怎么判断数组是 null 还是为空</li>\n<li>怎么打印数组？ 怎样打印数组中的重复元素</li>\n<li>Array 和 ArrayList有什么区别？什么时候应该使用Array而不是ArrayList</li>\n<li>数组和链表数据结构描述，各自的时间复杂度</li>\n<li>数组有没有length()这个方法? String有没有length()这个方法</li>\n</ul>\n</li>\n<li>队列<ul>\n<li>队列和栈是什么，列出它们的区别</li>\n<li>BlockingQueue是什么</li>\n<li>简述 ConcurrentLinkedQueue LinkedBlockingQueue 的用处和不同之处。</li>\n</ul>\n</li>\n<li>ArrayList、Vector、LinkedList的存储性能和特性</li>\n<li>String</li>\n<li>StringBuffer<ul>\n<li>ByteBuffer 与 StringBuffer有什么区别</li>\n</ul>\n</li>\n<li>HashMap<ul>\n<li>HashMap的工作原理是什么</li>\n<li>内部的数据结构是什么</li>\n<li>HashMap 的 table的容量如何确定？loadFactor 是什么？ 该容量如何变化？这种变化会带来什么问题？</li>\n<li>HashMap 实现的数据结构是什么？如何实现</li>\n<li>HashMap 和 HashTable、ConcurrentHashMap 的区别</li>\n<li>HashMap的遍历方式及效率</li>\n<li>HashMap、LinkedMap、TreeMap的区别</li>\n<li>如何决定选用HashMap还是TreeMap</li>\n<li>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办</li>\n<li>HashMap 是线程安全的吗？并发下使用的 Map 是什么，它们内部原理分别是什么，比如存储方式、 hashcode、扩容、 默认容量等</li>\n</ul>\n</li>\n<li>HashSet<ul>\n<li>HashSet和TreeSet有什么区别</li>\n<li>HashSet 内部是如何工作的</li>\n<li>WeakHashMap 是怎么工作的？</li>\n</ul>\n</li>\n<li>Set<ul>\n<li>Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢？是用 == 还是 equals()？ 它们有何区别?</li>\n<li>TreeMap：TreeMap 是采用什么树实现的？TreeMap、HashMap、LindedHashMap的区别。TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</li>\n<li>TreeSet：一个已经构建好的 TreeSet，怎么完成倒排序。</li>\n<li>EnumSet 是什么</li>\n</ul>\n</li>\n<li>Hash算法<ul>\n<li>Hashcode 的作用</li>\n<li>简述一致性 Hash 算法</li>\n<li>有没有可能 两个不相等的对象有相同的 hashcode？当两个对象 hashcode 相同怎么办？如何获取值对象</li>\n<li>为什么在重写 equals 方法的时候需要重写 hashCode 方法？equals与 hashCode 的异同点在哪里</li>\n<li>a.hashCode() 有什么用？与 a.equals(b) 有什么关系</li>\n<li>hashCode() 和 equals() 方法的重要性体现在什么地方</li>\n<li>Object：Object有哪些公用方法？Object类hashcode,equals 设计原则？ sun为什么这么设计？Object类的概述</li>\n<li>如何在父类中为子类自动完成所有的 hashcode 和 equals 实现？这么做有何优劣。</li>\n<li>可以在 hashcode() 中使用随机数字吗？</li>\n</ul>\n</li>\n<li>LinkedHashMap<ul>\n<li>LinkedHashMap 和 PriorityQueue 的区别是什么</li>\n</ul>\n</li>\n<li>List<ul>\n<li>List, Set, Map三个接口，存取元素时各有什么特点</li>\n<li>List, Set, Map 是否继承自 Collection 接口</li>\n<li>遍历一个 List 有哪些不同的方式</li>\n<li>LinkedList<ul>\n<li>LinkedList 是单向链表还是双向链表</li>\n<li>LinkedList 与 ArrayList 有什么区别</li>\n<li>描述下 Java 中集合（Collections），接口（Interfaces），实现（Implementations）的概念。LinkedList 与 ArrayList 的区别是什么？</li>\n<li>插入数据时，ArrayList, LinkedList, Vector谁速度较快？</li>\n</ul>\n</li>\n<li>ArrayList<ul>\n<li>ArrayList 和 HashMap 的默认大小是多数</li>\n<li>ArrayList 和 LinkedList 的区别，什么时候用 ArrayList？</li>\n<li>ArrayList 和 Set 的区别？</li>\n<li>ArrayList, LinkedList, Vector的区别</li>\n<li>ArrayList是如何实现的，ArrayList 和 LinkedList 的区别</li>\n<li>ArrayList如何实现扩容</li>\n<li>Array 和 ArrayList 有何区别？什么时候更适合用Array</li>\n<li>说出ArraList,Vector, LinkedList的存储性能和特性</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Map<ul>\n<li>Map, Set, List, Queue, Stack</li>\n<li>Map 接口提供了哪些不同的集合视图</li>\n<li>为什么 Map 接口不继承 Collection 接口</li>\n</ul>\n</li>\n<li>Collections<ul>\n<li>介绍Java中的Collection FrameWork。集合类框架的基本接口有哪些</li>\n<li>Collections类是什么？Collection 和 Collections的区别？Collection、Map的实现</li>\n<li>集合类框架的最佳实践有哪些</li>\n<li>为什么 Collection 不从 Cloneable 和 Serializable 接口继承</li>\n<li>说出几点 Java 中使用 Collections 的最佳实践？</li>\n<li>Collections 中 遗留类 (HashTable、Vector) 和 现有类的区别</li>\n</ul>\n</li>\n<li>什么是 B+树，B-树，列出实际的使用场景。</li>\n</ul>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><ul>\n<li>Comparator 与 Comparable 接口是干什么的？列出它们的区别</li>\n</ul>\n<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><ul>\n<li>拷贝(clone)<ul>\n<li>如何实现对象克隆</li>\n<li>深拷贝和浅拷贝区别</li>\n<li>深拷贝和浅拷贝如何实现激活机制</li>\n<li>写clone()方法时，通常都有一行代码，是什么</li>\n</ul>\n</li>\n<li>比较<ul>\n<li>在比较对象时，”==” 运算符和 equals 运算有何区别</li>\n<li>如果要重写一个对象的equals方法，还要考虑什么</li>\n<li>两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对</li>\n</ul>\n</li>\n<li>构造器<ul>\n<li>构造器链是什么</li>\n<li>创建对象时构造器的调用顺序</li>\n</ul>\n</li>\n<li>不可变对象<ul>\n<li>什么是不可变象（immutable object）</li>\n<li>为什么 Java 中的 String 是不可变的（Immutable）</li>\n<li>如何构建不可变的类结构？关键点在哪里</li>\n<li>能创建一个包含可变对象的不可变对象吗</li>\n</ul>\n</li>\n<li>如何对一组对象进行排序</li>\n</ul>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><ul>\n<li>构造器（constructor）是否可被重写（override）</li>\n<li>方法可以同时即是 static 又是 synchronized 的吗</li>\n<li>abstract 的 method是否可同时是 static，是否可同时是 native，是否可同时是synchronized</li>\n<li>Java支持哪种参数传递类型</li>\n<li>一个对象被当作参数传递到一个方法，是值传递还是引用传递</li>\n<li>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</li>\n<li>我们能否重载main()方法</li>\n<li>如果main方法被声明为private会怎样</li>\n</ul>\n<h2 id=\"GC\"><a href=\"#GC\" class=\"headerlink\" title=\"GC\"></a>GC</h2><ul>\n<li>概念<ul>\n<li>GC是什么？为什么要有GC</li>\n<li>什么时候会导致垃圾回收</li>\n<li>GC是怎么样运行的</li>\n<li>新老以及永久区是什么</li>\n<li>GC 有几种方式？怎么配置</li>\n<li>什么时候一个对象会被GC？ 如何判断一个对象是否存活</li>\n<li>System.gc()  Runtime.gc()会做什么事情？  能保证 GC 执行吗</li>\n<li>垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</li>\n<li>Minor GC 、Major GC、Young GC 与 Full GC分别在什么时候发生</li>\n<li>垃圾回收算法的实现原理</li>\n<li>如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？</li>\n<li>垃圾回收的最佳做法是什么</li>\n</ul>\n</li>\n<li>GC收集器有哪些<ul>\n<li>垃圾回收器的基本原理是什么？</li>\n<li>串行(serial)收集器和吞吐量(throughput)收集器的区别是什么<ul>\n<li>Serial 与 Parallel GC之间的不同之处</li>\n<li>CMS 收集器 与 G1 收集器的特点与区别</li>\n<li>CMS垃圾回收器的工作过程</li>\n<li>JVM 中一次完整的 GC 流程是怎样的？ 对象如何晋升到老年代</li>\n<li>吞吐量优先和响应优先的垃圾收集器选择</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>GC策略<ul>\n<li>举个实际的场景，选择一个GC策略</li>\n<li>JVM的永久代中会发生垃圾回收吗</li>\n</ul>\n</li>\n<li>收集方法<ul>\n<li>标记清除、标记整理、复制算法的原理与特点？分别用在什么地方</li>\n<li>如果让你优化收集方法，有什么思路</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h2><ul>\n<li>参数<ul>\n<li>说说你知道的几种主要的jvm 参数</li>\n<li>-XX:+UseCompressedOops 有什么作用</li>\n</ul>\n</li>\n<li>类加载器(ClassLoader)<ul>\n<li>Java 类加载器都有哪些</li>\n<li>JVM如何加载字节码文件</li>\n</ul>\n</li>\n<li>内存管理<ul>\n<li>JVM内存分哪几个区，每个区的作用是什么</li>\n<li>一个对象从创建到销毁都是怎么在这些部分里存活和转移的</li>\n<li>解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法</li>\n<li>JVM中哪个参数是用来控制线程的栈堆栈小</li>\n<li>简述内存分配与回收策略</li>\n<li>简述重排序，内存屏障，happen-before，主内存，工作内存</li>\n<li>Java中存在内存泄漏问题吗？请举例说明</li>\n<li>简述 Java 中软引用（SoftReferenc）、弱引用（WeakReference）和虚引用</li>\n<li>内存映射缓存区是什么</li>\n</ul>\n</li>\n<li>jstack，jstat，jmap，jconsole怎么用</li>\n<li>32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？32 位和 64 位的 JVM，int 类型变量的长度是多数？</li>\n<li>怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位</li>\n<li>JVM自身会维护缓存吗？是不是在堆中进行对象分配，操作系统的堆还是JVM自己管理堆</li>\n<li>什么情况下会发生栈内存溢出</li>\n<li>双亲委派模型是什么</li>\n</ul>\n<h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h2><ul>\n<li>基本概念<ul>\n<li>什么是线程</li>\n<li>多线程的优点</li>\n<li>多线程的几种实现方式<ul>\n<li>用 Runnable 还是 Thread</li>\n</ul>\n</li>\n<li>什么是线程安全<ul>\n<li>Vector, SimpleDateFormat 是线程安全类吗</li>\n<li>什么 Java 原型不是线程安全的</li>\n<li>哪些集合类是线程安全的</li>\n</ul>\n</li>\n<li>多线程中的忙循环是什么</li>\n<li>如何创建一个线程</li>\n<li>编写多线程程序有几种实现方式</li>\n<li>什么是线程局部变量</li>\n<li>线程和进程有什么区别？进程间如何通讯，线程间如何通讯</li>\n<li>什么是多线程环境下的伪共享（false sharing）</li>\n<li>同步和异步有何异同，在什么情况下分别使用他们？举例说明</li>\n</ul>\n</li>\n<li>Current<ul>\n<li>ConcurrentHashMap 和 Hashtable的区别</li>\n<li>ArrayBlockingQueue, CountDownLatch的用法</li>\n<li>ConcurrentHashMap的并发度是什么</li>\n</ul>\n</li>\n<li>CyclicBarrier 和 CountDownLatch有什么不同？各自的内部原理和用法是什么</li>\n<li>Semaphore的用法</li>\n<li>Thread<ul>\n<li>启动一个线程是调用 run() 还是 start() 方法？start() 和 run() 方法有什么区别</li>\n<li>调用start()方法时会执行run()方法，为什么不能直接调用run()方法</li>\n<li>sleep() 方法和对象的 wait() 方法都可以让线程暂停执行，它们有什么区别</li>\n<li>yield方法有什么作用？sleep() 方法和 yield() 方法有什么区别</li>\n<li>Java 中如何停止一个线程</li>\n<li>stop() 和 suspend() 方法为何不推荐使用</li>\n<li>如何在两个线程间共享数据</li>\n<li>如何强制启动一个线程</li>\n<li>如何让正在运行的线程暂停一段时间</li>\n<li>什么是线程组，为什么在Java中不推荐使用</li>\n<li>你是如何调用  wait（方法的）？使用 if 块还是循环？为什么</li>\n</ul>\n</li>\n<li>生命周期<ul>\n<li>有哪些不同的线程生命周期</li>\n<li>线程状态，BLOCKED 和 WAITING 有什么区别</li>\n<li>画一个线程的生命周期状态图</li>\n</ul>\n</li>\n<li>ThreadLocal 用途是什么，原理是什么，用的时候要注意什么</li>\n<li>ThreadPool<ul>\n<li>线程池是什么？为什么要使用它</li>\n<li>如何创建一个Java线程池<ul>\n<li>ThreadPool用法与优势</li>\n<li>提交任务时，线程池队列已满时会发会生什么</li>\n<li>newCache 和 newFixed 有什么区别？简述原理。构造函数的各个参数的含义是什么，比如 coreSize, maxsize 等</li>\n<li>线程池的实现策略</li>\n<li>线程池的关闭方式有几种，各自的区别是什么</li>\n<li>线程池中submit() 和 execute()方法有什么区别？</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>线程调度<ul>\n<li>Java中用到的线程调度算法是什么</li>\n<li>什么是多线程中的上下文切换</li>\n<li>你对线程优先级的理解是什么</li>\n<li>什么是线程调度器 (Thread Scheduler) 和时间分片 (Time Slicing)</li>\n</ul>\n</li>\n<li>线程同步<ul>\n<li>请说出你所知的线程同步的方法</li>\n<li>synchronized 的原理是什么</li>\n<li>synchronized 和 ReentrantLock 有什么不同</li>\n<li>什么场景下可以使用 volatile 替换 synchronized</li>\n<li>有T1，T2，T3三个线程，怎么确保它们按顺序执行？怎样保证T2在T1执行完后执行，T3在T2执行完后执行</li>\n<li>同步块内的线程抛出异常会发生什么</li>\n<li>当一个线程进入一个对象的 synchronized 方法A 之后，其它线程是否可进入此对象的 synchronized 方法B</li>\n<li>使用 synchronized 修饰静态方法和非静态方法有什么区别</li>\n<li>如何从给定集合那里创建一个 synchronized 的集合</li>\n</ul>\n</li>\n<li>锁<ul>\n<li>Java Concurrency API 中 的 Lock 接口是什么？对比同步它有什么优势</li>\n<li>Lock 与 Synchronized 的区别？Lock 接口比 synchronized 块的优势是什么</li>\n<li>ReadWriteLock是什么？</li>\n<li>锁机制有什么用</li>\n<li>什么是乐观锁（Optimistic Locking）？如何实现乐观锁？如何避免ABA问题</li>\n<li>解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁</li>\n<li>什么时候应该使用可重入锁</li>\n<li>简述锁的等级方法锁、对象锁、类锁</li>\n<li>Java中活锁和死锁有什么区别？</li>\n<li>什么是死锁(Deadlock)？导致线程死锁的原因？如何确保 N 个线程可以访问 N 个资源同时又不导致死锁</li>\n<li>死锁与活锁的区别，死锁与饥饿的区别</li>\n<li>怎么检测一个线程是否拥有锁</li>\n<li>如何实现分布式锁</li>\n<li>有哪些无锁数据结构，他们实现的原理是什么</li>\n<li>读写锁可以用于什么应用场景</li>\n</ul>\n</li>\n<li>Executors类是什么？ Executor和Executors的区别</li>\n<li>什么是Java线程转储(Thread Dump)，如何得到它</li>\n<li>如何在Java中获取线程堆栈</li>\n<li>说出 3 条在 Java 中使用线程的最佳实践</li>\n<li>在线程中你怎么处理不可捕捉异常</li>\n<li>实际项目中使用多线程举例。你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的</li>\n<li>请说出与线程同步以及线程调度相关的方法</li>\n<li>程序中有3个 socket，需要多少个线程来处理</li>\n<li>假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有 10 个线程同时调用它，如何做到</li>\n<li>如何在 Windows 和 Linux 上查找哪个线程使用的 CPU 时间最长</li>\n<li>如何确保 main() 方法所在的线程是 Java 程序最后结束的线程</li>\n<li>非常多个线程（可能是不同机器），相互之间需要等待协调才能完成某种工作，问怎么设计这种协调方案</li>\n<li>你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它</li>\n</ul>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><ul>\n<li>基本概念<ul>\n<li>Error 和 Exception有什么区别<ul>\n<li>UnsupportedOperationException是什么</li>\n<li>NullPointerException 和 ArrayIndexOutOfBoundException 之间有什么相同之处</li>\n</ul>\n</li>\n<li>什么是受检查的异常，什么是运行时异常</li>\n<li>运行时异常与一般异常有何异同</li>\n<li>简述一个你最常见到的runtime exception(运行时异常)</li>\n</ul>\n</li>\n<li>finally<ul>\n<li>finally关键词在异常处理中如何使用<ul>\n<li>如果执行finally代码块之前方法返回了结果，或者JVM退出了，finally块中的代码还会执行吗</li>\n<li>try里有return，finally还执行么？那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后</li>\n<li>在什么情况下，finally语句不会执行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>throw 和 throws 有什么区别？</li>\n<li>OOM你遇到过哪些情况？你是怎么搞定的？</li>\n<li>SOF你遇到过哪些情况？</li>\n<li>既然我们可以用RuntimeException来处理错误，那么你认为为什么Java中还存在检查型异常</li>\n<li>当自己创建异常类的时候应该注意什么</li>\n<li>导致空指针异常的原因</li>\n<li>异常处理 handle or declare 原则应该如何理解</li>\n<li>怎么利用 JUnit 来测试一个方法的异常</li>\n<li>catch块里别不写代码有什么问题</li>\n<li>你曾经自定义实现过异常吗？怎么写的</li>\n<li>什么是 异常链</li>\n<li>在try块中可以抛出异常吗</li>\n</ul>\n<h2 id=\"JDBC\"><a href=\"#JDBC\" class=\"headerlink\" title=\"JDBC\"></a>JDBC</h2><ul>\n<li>通过 JDBC 连接数据库有哪几种方式</li>\n<li>阐述 JDBC 操作数据库的基本步骤</li>\n<li>JDBC 中如何进行事务处理</li>\n<li>什么是 JdbcTemplate</li>\n<li>什么是 DAO 模块</li>\n<li>使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能</li>\n<li>列出 5 个应该遵循的 JDBC 最佳实践</li>\n</ul>\n<h2 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h2><ul>\n<li>File<ul>\n<li>File类型中定义了什么方法来创建一级目录<ul>\n<li>File类型中定义了什么方法来判断一个文件是否存在</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>流<ul>\n<li>为了提高读写性能，可以采用什么流</li>\n<li>Java中有几种类型的流</li>\n<li>JDK 为每种类型的流提供了一些抽象类以供继承，分别是哪些类</li>\n<li>对文本文件操作用什么I/O流</li>\n<li>对各种基本数据类型和String类型的读写，采用什么流</li>\n<li>能指定字符编码的 I/O 流类型是什么</li>\n</ul>\n</li>\n<li>序列化<ul>\n<li>什么是序列化？如何实现 Java 序列化及注意事项</li>\n<li>Serializable 与 Externalizable 的区别</li>\n</ul>\n</li>\n<li>Socket<ul>\n<li>socket 选项 TCP NO DELAY 是指什么</li>\n<li>Socket 工作在 TCP/IP 协议栈是哪一层</li>\n<li>TCP、UDP 区别及 Java 实现方式</li>\n</ul>\n</li>\n<li>说几点 IO 的最佳实践</li>\n<li>直接缓冲区与非直接缓冲器有什么区别？</li>\n<li>怎么读写 ByteBuffer？ByteBuffer 中的字节序是什么</li>\n<li>当用System.in.read(buffer)从键盘输入一行n个字符后，存储在缓冲区buffer中的字节数是多少</li>\n<li>如何使用扫描器类（Scanner Class）令牌化</li>\n</ul>\n<h2 id=\"面向对象编程（OOP）\"><a href=\"#面向对象编程（OOP）\" class=\"headerlink\" title=\"面向对象编程（OOP）\"></a>面向对象编程（OOP）</h2><ul>\n<li>解释下多态性（polymorphism），封装性（encapsulation），内聚（cohesion）以及耦合（coupling）</li>\n<li>多态的实现原理</li>\n<li>封装、继承和多态是什么</li>\n<li>对象封装的原则是什么?</li>\n<li>类<ul>\n<li>获得一个类的类对象有哪些方式</li>\n<li>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</li>\n<li>说出几条 Java 中方法重载的最佳实践</li>\n</ul>\n</li>\n<li>抽象类<ul>\n<li>抽象类和接口的区别</li>\n<li>抽象类中是否可以有静态的main方法</li>\n<li>抽象类是否可实现(implements)接口</li>\n<li>抽象类是否可继承具体类(concrete class)</li>\n</ul>\n</li>\n<li>匿名类（Anonymous Inner Class）<ul>\n<li>匿名内部类是否可以继承其它类？是否可以实现接口</li>\n</ul>\n</li>\n<li>内部类<ul>\n<li>内部类分为几种</li>\n<li>内部类可以引用它的包含类（外部类）的成员吗</li>\n<li>请说一下 Java 中为什么要引入内部类？还有匿名内部类</li>\n</ul>\n</li>\n<li>继承<ul>\n<li>继承（Inheritance）与聚合（Aggregation）的区别在哪里</li>\n<li>继承和组合之间有什么不同</li>\n<li>为什么类只能单继承，接口可以多继承</li>\n<li>存在两个类，B 继承 A，C 继承 B，能将 B 转换为 C 么？如 C = (C) B</li>\n<li>如果类 a 继承类 b，实现接口c，而类 b 和接口 c 中定义了同名变量，请问会出现什么问题</li>\n</ul>\n</li>\n<li>接口<ul>\n<li>接口是什么</li>\n<li>接口是否可继承接口</li>\n<li>为什么要使用接口而不是直接使用具体类？接口有什么优点</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><ul>\n<li>泛型的存在是用来解决什么问题</li>\n<li>泛型的常用特点</li>\n<li>List<string>能否转为List<object></object></string></li>\n</ul>\n<h2 id=\"工具类\"><a href=\"#工具类\" class=\"headerlink\" title=\"工具类\"></a>工具类</h2><ul>\n<li>日历<ul>\n<li>Calendar Class的用途</li>\n<li>如何在Java中获取日历类的实例</li>\n<li>解释一些日历类中的重要方法<ul>\n<li>GregorianCalendar 类是什么</li>\n<li>SimpleTimeZone 类是什么</li>\n<li>Locale类是什么</li>\n<li>如何格式化日期对象</li>\n<li>如何添加小时(hour)到一个日期对象(Date Objects)</li>\n<li>如何将字符串 YYYYMMDD 转换为日期</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Math<ul>\n<li>Math.round()什么作用？Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？</li>\n</ul>\n</li>\n<li>XML<ul>\n<li>XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？DOM 和 SAX 解析器有什么不同？</li>\n<li>Java解析XML的方式</li>\n<li>用 jdom 解析 xml 文件时如何解决中文问题？如何解析</li>\n<li>你在项目中用到了 XML 技术的哪些方面？如何实现</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h2><ul>\n<li>描述动态代理的几种实现方式，分别说出相应的优缺点</li>\n</ul>\n<h2 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h2><ul>\n<li>什么是设计模式（Design Patterns）？你用过哪种设计模式？用在什么场合</li>\n<li>你知道哪些商业级设计模式？</li>\n<li>哪些设计模式可以增加系统的可扩展性</li>\n<li>单例模式<ul>\n<li>除了单例模式，你在生产环境中还用过什么设计模式？</li>\n<li>写 Singleton 单例模式</li>\n<li>单例模式的双检锁是什么</li>\n<li>如何创建线程安全的 Singleton</li>\n<li>什么是类的单例模式</li>\n<li>写出三种单例模式实现</li>\n</ul>\n</li>\n<li>适配器模式<ul>\n<li>适配器模式是什么？什么时候使用</li>\n<li>适配器模式和代理模式之前有什么不同</li>\n<li>适配器模式和装饰器模式有什么区别</li>\n</ul>\n</li>\n<li>什么时候使用享元模式</li>\n<li>什么时候使用组合模式</li>\n<li>什么时候使用访问者模式</li>\n<li>什么是模板方法模式</li>\n<li>请给出1个符合开闭原则的设计模式的例子</li>\n</ul>\n<h2 id=\"开放问题\"><a href=\"#开放问题\" class=\"headerlink\" title=\"开放问题\"></a>开放问题</h2><ul>\n<li>用一句话概括 Web 编程的特点</li>\n<li>Google是如何在一秒内把搜索结果返回给用户</li>\n<li>哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入</li>\n<li>树（二叉或其他）形成许多普通数据结构的基础。请描述一些这样的数据结构以及何时可以使用它们</li>\n<li>某一项功能如何设计</li>\n<li>线上系统突然变得异常缓慢，你如何查找问题</li>\n<li>什么样的项目不适合用框架</li>\n<li>新浪微博是如何实现把微博推给订阅者</li>\n<li>简要介绍下从浏览器输入 URL 开始到获取到请求界面之后 Java Web 应用中发生了什么</li>\n<li>请你谈谈SSH整合</li>\n<li>高并发下，如何做到安全的修改同一行数据</li>\n<li>12306网站的订票系统如何实现，如何保证不会票不被超卖</li>\n<li>网站性能优化如何优化的</li>\n<li>聊了下曾经参与设计的服务器架构</li>\n<li>请思考一个方案，实现分布式环境下的 countDownLatch</li>\n<li>请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存</li>\n<li>在你的职业生涯中，算得上最困难的技术挑战是什么</li>\n<li>如何写一篇设计文档，目录是什么</li>\n<li>大写的O是什么？举几个例子</li>\n<li>编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用</li>\n<li>解释一下网络应用的模式及其特点</li>\n<li>设计一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新</li>\n<li>说出数据连接池的工作机制是什么</li>\n<li>怎么获取一个文件中单词出现的最高频率</li>\n<li>描述一下你最常用的编程风格</li>\n<li>如果有机会重新设计你们的产品，你会怎么做</li>\n<li>如何搭建一个高可用系统</li>\n<li>如何启动时不需输入用户名与密码</li>\n<li>如何在基于Java的Web项目中实现文件上传和下载</li>\n<li>如何实现一个秒杀系统，保证只有几位用户能买到某件商品。</li>\n<li>如何实现负载均衡，有哪些算法可以实现</li>\n<li>如何设计一个购物车？想想淘宝的购物车如何实现的</li>\n<li>如何设计一套高并发支付方案，架构如何设计</li>\n<li>如何设计建立和保持 100w 的长连接</li>\n<li>如何避免浏览器缓存。</li>\n<li>如何防止缓存雪崩</li>\n<li>如果AB两个系统互相依赖，如何解除依</li>\n<li>如果有人恶意创建非法连接，怎么解决</li>\n<li>如果有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能</li>\n<li>如果系统要使用超大整数（超过long长度范围），请你设计一个数据结构来存储这种超大型数字以及设计一种算法来实现超大整数加法运算）</li>\n<li>如果要设计一个图形系统，请你设计基本的图形元件(Point,Line,Rectangle,Triangle)的简单实现</li>\n<li>如果让你实现一个并发安全的链表，你会怎么做</li>\n<li>应用服务器与WEB 服务器的区别？应用服务器怎么监控性能，各种方式的区别？你使用过的应用服务器优化技术有哪些</li>\n<li>大型网站在架构上应当考虑哪些问题</li>\n<li>有没有处理过线上问题？出现内存泄露，CPU利用率标高，应用无响应时如何处理的</li>\n<li>最近看什么书，印象最深刻的是什么</li>\n<li>描述下常用的重构技巧</li>\n<li>你使用什么版本管理工具？分支（Branch）与标签（Tag）之间的区别在哪里</li>\n<li>你有了解过存在哪些反模式（Anti-Patterns）吗</li>\n<li>你用过的网站前端优化的技术有哪些</li>\n<li>如何分析Thread dump</li>\n<li>你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念</li>\n<li>你是如何处理内存泄露或者栈溢出问题的</li>\n<li>你们线上应用的 JVM 参数有哪些</li>\n<li>怎么提升系统的QPS和吞吐量</li>\n</ul>\n<h2 id=\"知识面\"><a href=\"#知识面\" class=\"headerlink\" title=\"知识面\"></a>知识面</h2><ul>\n<li>解释什么是 MESI 协议(缓存一致性)</li>\n<li>谈谈 reactor 模型</li>\n<li>Java 9 带来了怎样的新功能</li>\n<li>Java 与 C++ 对比，C++ 或 Java 中的异常处理机制的简单原理和应用</li>\n<li>简单讲讲 Tomcat 结构，以及其类加载器流程</li>\n<li>虚拟内存是什么</li>\n<li>阐述下 SOLID 原则</li>\n<li>请简要讲一下你对测试驱动开发（TDD）的认识</li>\n<li>CDN实现原理</li>\n<li>Maven 和 ANT 有什么区别</li>\n<li>UML中有哪些常用的图</li>\n<li>Linux<ul>\n<li>Linux 下 IO 模型有几种，各自的含义是什么。</li>\n<li>Linux 系统下你关注过哪些内核参数，说说你知道的</li>\n<li>Linux 下用一行命令查看文件的最后五行</li>\n<li>平时用到哪些 Linux 命令</li>\n<li>用一行命令输出正在运行的 Java 进程</li>\n<li>使用什么命令来确定是否有 Tomcat 实例运行在机器上</li>\n</ul>\n</li>\n<li>什么是 N+1 难题</li>\n<li>什么是 paxos 算法</li>\n<li>什么是 restful，讲讲你理解的 restful</li>\n<li>什么是 zab 协议</li>\n<li>什么是领域模型(domain model)？贫血模型(anaemic domain model) 和充血模型(rich domain model)有什么区别</li>\n<li>什么是领域驱动开发（Domain Driven Development）</li>\n<li>介绍一下了解的 Java 领域的 Web Service 框架</li>\n<li>Web Server、Web Container 与 Application Server 的区别是什么</li>\n<li>微服务（MicroServices）与巨石型应用（Monolithic Applications）之间的区别在哪里</li>\n<li>描述 Cookie 和 Session 的作用，区别和各自的应用范围，Session工作原理</li>\n<li>你常用的持续集成（Continuous Integration）、静态代码分析（Static Code Analysis）工具有哪些</li>\n<li>简述下数据库正则化（Normalizations）</li>\n<li>KISS,DRY,YAGNI 等原则是什么含义</li>\n<li>分布式事务的原理，优缺点，如何使用分布式事务？</li>\n<li>布式集群下如何做到唯一序列号</li>\n<li>网络<ul>\n<li>HTTPS 的加密方式是什么，讲讲整个加密解密流程</li>\n<li>HTTPS和HTTP的区别</li>\n<li>HTTP连接池实现原理</li>\n<li>HTTP集群方案</li>\n<li>Nginx、lighttpd、Apache三大主流 Web服务器的区别</li>\n</ul>\n</li>\n<li>是否看过框架的一些代码</li>\n<li>持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些</li>\n<li>数值提升是什么</li>\n<li>你能解释一下里氏替换原则吗</li>\n<li>你是如何测试一个应用的？知道哪些测试框架</li>\n<li>传输层常见编程协议有哪些？并说出各自的特点</li>\n</ul>\n<h2 id=\"编程题\"><a href=\"#编程题\" class=\"headerlink\" title=\"编程题\"></a>编程题</h2><h3 id=\"计算加班费\"><a href=\"#计算加班费\" class=\"headerlink\" title=\"计算加班费\"></a>计算加班费</h3><p>加班10小时以下加班费是时薪的1.5倍。加班10小时或以上，按4元/时算。提示：（一个月工作26天，一天正常工作8小时）</p>\n<ul>\n<li>计算1000月薪，加班9小时的加班费</li>\n<li>计算2500月薪，加班11小时的加班费</li>\n<li>计算1000月薪，加班15小时的加班费</li>\n</ul>\n<h3 id=\"卖东西\"><a href=\"#卖东西\" class=\"headerlink\" title=\"卖东西\"></a>卖东西</h3><p>一家商场有红苹果和青苹果出售。（红苹果5元/个，青苹果4元/个）。</p>\n<ul>\n<li>模拟一个进货。红苹果跟青苹果各进200个。</li>\n<li>模拟一个出售。红苹果跟青苹果各买出10个。每卖出一个苹果需要进行统计。</li>\n</ul>\n<p>提示：一个苹果是一个单独的实体。</p>\n<h3 id=\"日期提取\"><a href=\"#日期提取\" class=\"headerlink\" title=\"日期提取\"></a>日期提取</h3><p>有这样一个时间字符串：2008-8-8 20:08:08 ， 请编写能够匹配它的正则表达式，并编写Java代码将日期后面的时分秒提取出来，即：20:08:08</p>\n<h3 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h3><ul>\n<li>8设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。</li>\n<li>用Java写一个多线程程序，如写四个线程，二个加1，二个对一个变量减一，输出</li>\n<li>wait-notify 写一段代码来解决生产者-消费者问题</li>\n</ul>\n<h3 id=\"数字\"><a href=\"#数字\" class=\"headerlink\" title=\"数字\"></a>数字</h3><ul>\n<li>判断101-200之间有多少个素数，并输出所有素数</li>\n<li>用最有效率的方法算出2乘以17等于多少</li>\n<li>有 1 亿个数字，其中有 2 个是重复的，快速找到它，时间和空间要最优</li>\n<li>2 亿个随机生成的无序整数,找出中间大小的值</li>\n<li>10 亿个数字里里面找最小的 10 个</li>\n<li>1到1亿的自然数，求所有数的拆分后的数字之和，如286 拆分成2、8、6，如1到11拆分后的数字之和 =&gt; 1 + … + 9 + 1 + 0 + 1 + 1</li>\n<li>一个数如果恰好等于它的因子之和，这个数就称为 “完数 “。例如6=1＋2＋3.编程   找出1000以内的所有完数</li>\n<li>一个数组中所有的元素都出现了三次，只有一个元素出现了一次找到这个元素</li>\n<li>一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在   第10次落地时，共经过多少米？第10次反弹多高？</li>\n<li>求100－1000内质数的和</li>\n<li>求1到100的和的平均数</li>\n<li>求s=a+a+aaa+aaaa+aa…a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加有键盘控制。 求出1到100的和</li>\n<li>算出1到40的质数，放进数组里<ul>\n<li>显示放组里的数</li>\n<li>找出第[5]个数</li>\n<li>删除第[9]个数，再显示删除后的第[9]个</li>\n</ul>\n</li>\n<li>有 3n+1 个数字，其中 3n 个中是重复的，只有 1 个是不重复的，怎么找出来。</li>\n<li>有一组数1.1.2.3.5.8.13.21.34。写出程序随便输入一个数就能给出和前一组数字同规律的头5个数</li>\n<li>计算指定数字的阶乘</li>\n<li>开发 Fizz Buzz</li>\n<li>给定一个包含 N 个整数的数组，找出丢失的整数</li>\n<li>一个排好序的数组，找出两数之和为m的所有组合</li>\n<li>将一个正整数分解质因数。例如：输入90,打印出90=2*3*3*5。</li>\n<li>打印出所有的 “水仙花数 “，所谓 “水仙花数 “是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个 “水仙花数 “，因为153=1的三次方＋5的三次方＋3的三次方</li>\n<li>原地交换两个变量的值</li>\n<li>找出4字节整数的中位数</li>\n<li>找到整数的平方根</li>\n<li>实现斐波那契</li>\n</ul>\n<h3 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h3><ul>\n<li>用Java Socket编程，读服务器几个字符，再写入本地显示</li>\n</ul>\n<h2 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h2><ul>\n<li>反射机制提供了什么功能？</li>\n<li>反射是如何实现的</li>\n<li>哪里用到反射机制</li>\n<li>反射中 Class.forName 和 ClassLoader 区别</li>\n<li>反射创建类实例的三种方式是什么</li>\n<li>如何通过反射调用对象的方法</li>\n<li>如何通过反射获取和设置对象私有字段的值</li>\n<li>反射机制的优缺点</li>\n</ul>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><ul>\n<li>写一段 JDBC 连Oracle的程序,并实现数据查询</li>\n</ul>\n<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><ul>\n<li>50个人围坐一圈，当数到三或者三的倍数出圈，问剩下的人是谁，原来的位置是多少</li>\n<li>实现一个电梯模拟器用</li>\n<li>写一个冒泡排序</li>\n<li>写一个折半查找</li>\n<li>随机产生20个不能重复的字符并排序</li>\n<li>写一个函数，传入 2 个有序的整数数组，返回一个有序的整数数组</li>\n<li>写一段代码在遍历 ArrayList 时移除一个元素</li>\n<li>古典问题：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第四个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少</li>\n<li>约瑟芬环游戏</li>\n</ul>\n<h3 id=\"正则\"><a href=\"#正则\" class=\"headerlink\" title=\"正则\"></a>正则</h3><ul>\n<li>请编写一段匹配IP地址的正则表达式</li>\n<li>写出一个正则表达式来判断一个字符串是否是一个数字</li>\n</ul>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><ul>\n<li>写一个方法，入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。</li>\n<li>写一个程序找出所有字符串的组合，并检查它们是否是回文串</li>\n<li>写一个字符串反转函数，输入abcde转换成edcba代码</li>\n<li>小游戏，倒转句子中的单词</li>\n<li>将GB2312编码的字符串转换为ISO-8859-1编码的字符串</li>\n<li>请写一段代码来计算给定文本内字符“A”的个数。分别用迭代和递归两种方式</li>\n<li>编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串。 但是要保证汉字不被截半个，如“我ABC”4，应该截为“我AB”，输入“我ABC汉DEF”，6，应该输出为“我ABC”而不是“我ABC+汉的半个”</li>\n<li>给定 2 个包含单词列表（每行一个）的文件，编程列出交集</li>\n<li>打印出一个字符串的所有排列</li>\n<li>将一个键盘输入的数字转化成中文输出(例如：输入1234567，输出:一百二拾三万四千五百六拾七)</li>\n<li>在Web应用开发过程中经常遇到输出某种编码的字符，如从 GBK 到 ISO8859-1等，如何输出一个某种编码的字符串</li>\n</ul>\n<h2 id=\"日期\"><a href=\"#日期\" class=\"headerlink\" title=\"日期\"></a>日期</h2><ul>\n<li>计算两个日期之间的差距</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li>mysql表数据压缩</li>\n</ul>\n","excerpt":"<h1 id=\"Java面试资源\"><a href=\"#Java面试资源\" class=\"headerlink\" title=\"Java面试资源\"></a>Java面试资源</h1><p>这里汇总整理了网络上的Java面试题，持续更新<br></p>","more":"<p></p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><ul>\n<li>操作系统中 heap 和 stack 的区别</li>\n<li>什么是基于注解的切面实现</li>\n<li>什么是 对象/关系 映射集成模块</li>\n<li>什么是 Java 的反射机制</li>\n<li>什么是 ACID</li>\n<li>BS与CS的联系与区别</li>\n<li>Cookie 和 Session的区别</li>\n<li>fail-fast 与 fail-safe 机制有什么区别</li>\n<li>get 和 post请求的区别</li>\n<li>Interface 与 abstract 类的区别</li>\n<li>IOC的优点是什么</li>\n<li>IO 和 NIO的区别，NIO优点</li>\n<li>Java 8 / Java 7 为我们提供了什么新功能</li>\n<li>什么是竞态条件？ 举个例子说明。</li>\n<li>JRE、JDK、JVM 及 JIT 之间有什么不同</li>\n<li>MVC的各个部分都有那些技术来实现?如何实现?</li>\n<li>RPC 通信和 RMI 区别</li>\n<li>什么是 Web Service（Web服务）</li>\n<li>JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。</li>\n<li>WEB容器主要有哪些功能? 并请列出一些常见的WEB容器名字。</li>\n<li>一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制</li>\n<li>简单说说你了解的类加载器。是否实现过类加载器</li>\n<li>解释一下什么叫AOP（面向切面编程）</li>\n<li>请简述 Servlet 的生命周期及其相关的方法</li>\n<li>请简述一下 Ajax 的原理及实现步骤</li>\n<li>简单描述Struts的主要功能</li>\n<li>什么是 N 层架构</li>\n<li>什么是CORBA？用途是什么</li>\n<li>什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”</li>\n<li>什么是正则表达式？用途是什么？哪个包使用正则表达式来实现模式匹配</li>\n<li>什么是懒加载（Lazy Loading）</li>\n<li>什么是尾递归，为什么需要尾递归</li>\n<li>什么是控制反转（Inversion of Control）与依赖注入（Dependency Injection）</li>\n</ul>\n<h2 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h2><ul>\n<li>finalize<ul>\n<li>什么是finalize()方法<ul>\n<li>finalize()方法什么时候被调用</li>\n<li>析构函数(finalization)的目的是什么</li>\n<li>final 和 finalize 的区别</li>\n<li>final</li>\n</ul>\n</li>\n<li>final关键字有哪些用法<ul>\n<li>final 与 static 关键字可以用于哪里？它们的作用是什么</li>\n<li>final, finally, finalize的区别</li>\n<li>final、finalize 和 finally 的不同之处？</li>\n</ul>\n</li>\n<li>能否在运行时向 static final 类型的赋值<ul>\n<li>使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变</li>\n<li>一个类被声明为final类型，表示了什么意思</li>\n<li>throws, throw, try, catch, finally分别代表什么意义</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Java 有几种修饰符？分别用来修饰什么</li>\n<li>volatile<ul>\n<li>volatile 修饰符的有过什么实践</li>\n<li>volatile 变量是什么？volatile 变量和 atomic 变量有什么不同</li>\n<li>volatile 类型变量提供什么保证？能使得一个非原子操作变成原子操作吗</li>\n<li>能创建 volatile 数组吗？</li>\n</ul>\n</li>\n<li>transient变量有什么特点</li>\n<li>super什么时候使用</li>\n<li>public static void 写成 static public void会怎样</li>\n<li>说明一下public static void main(String args[])这段声明里每个关键字的作用</li>\n<li>请说出作用域public, private, protected, 以及不写时的区别</li>\n<li>sizeof 是Java 的关键字吗</li>\n<li>static<ul>\n<li>static class 与 non static class的区别</li>\n<li>static 关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法</li>\n<li>静态类型有什么特点</li>\n<li>main() 方法为什么必须是静态的？能不能声明 main() 方法为非静态</li>\n<li>是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用</li>\n<li>静态变量在什么时候加载？编译期还是运行期？静态代码块加载的时机呢</li>\n<li>成员方法是否可以访问静态变量？为什么静态方法不能访问成员变量</li>\n</ul>\n</li>\n<li>switch<ul>\n<li>switch 语句中的表达式可以是什么类型数据</li>\n<li>switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上</li>\n</ul>\n</li>\n<li>while 循环和 do 循环有什么不同</li>\n</ul>\n<h2 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h2><ul>\n<li>&amp;操作符和&amp;&amp;操作符有什么区别?</li>\n<li>a = a + b 与 a += b 的区别？</li>\n<li>逻辑操作符 (&amp;,|,^)与条件操作符(&amp;&amp;,||)的区别</li>\n<li>3*0.1 == 0.3 将会返回什么？true 还是 false？</li>\n<li>float f=3.4; 是否正确？</li>\n<li>short s1 = 1; s1 = s1 + 1;有什么错?</li>\n</ul>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><ul>\n<li>基础类型(Primitives)<ul>\n<li>基础类型(Primitives)与封装类型(Wrappers)的区别在哪里</li>\n<li>简述九种基本数据类型的大小，以及他们的封装类</li>\n<li>int 和 Integer 哪个会占用更多的内存？ int 和 Integer 有什么区别？parseInt()函数在什么时候使用到</li>\n<li>float和double的默认值是多少</li>\n<li>如何去小数四舍五入保留小数点后两位</li>\n<li>char 型变量中能不能存贮一个中文汉字，为什么</li>\n</ul>\n</li>\n<li>类型转换<ul>\n<li>怎样将 bytes 转换为 long 类型</li>\n<li>怎么将 byte 转换为 String</li>\n<li>如何将数值型字符转换为数字</li>\n<li>我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象</li>\n<li>能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗</li>\n<li>类型向下转换是什么</li>\n</ul>\n</li>\n<li>数组<ul>\n<li>如何权衡是使用无序的数组还是有序的数组</li>\n<li>怎么判断数组是 null 还是为空</li>\n<li>怎么打印数组？ 怎样打印数组中的重复元素</li>\n<li>Array 和 ArrayList有什么区别？什么时候应该使用Array而不是ArrayList</li>\n<li>数组和链表数据结构描述，各自的时间复杂度</li>\n<li>数组有没有length()这个方法? String有没有length()这个方法</li>\n</ul>\n</li>\n<li>队列<ul>\n<li>队列和栈是什么，列出它们的区别</li>\n<li>BlockingQueue是什么</li>\n<li>简述 ConcurrentLinkedQueue LinkedBlockingQueue 的用处和不同之处。</li>\n</ul>\n</li>\n<li>ArrayList、Vector、LinkedList的存储性能和特性</li>\n<li>String</li>\n<li>StringBuffer<ul>\n<li>ByteBuffer 与 StringBuffer有什么区别</li>\n</ul>\n</li>\n<li>HashMap<ul>\n<li>HashMap的工作原理是什么</li>\n<li>内部的数据结构是什么</li>\n<li>HashMap 的 table的容量如何确定？loadFactor 是什么？ 该容量如何变化？这种变化会带来什么问题？</li>\n<li>HashMap 实现的数据结构是什么？如何实现</li>\n<li>HashMap 和 HashTable、ConcurrentHashMap 的区别</li>\n<li>HashMap的遍历方式及效率</li>\n<li>HashMap、LinkedMap、TreeMap的区别</li>\n<li>如何决定选用HashMap还是TreeMap</li>\n<li>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办</li>\n<li>HashMap 是线程安全的吗？并发下使用的 Map 是什么，它们内部原理分别是什么，比如存储方式、 hashcode、扩容、 默认容量等</li>\n</ul>\n</li>\n<li>HashSet<ul>\n<li>HashSet和TreeSet有什么区别</li>\n<li>HashSet 内部是如何工作的</li>\n<li>WeakHashMap 是怎么工作的？</li>\n</ul>\n</li>\n<li>Set<ul>\n<li>Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢？是用 == 还是 equals()？ 它们有何区别?</li>\n<li>TreeMap：TreeMap 是采用什么树实现的？TreeMap、HashMap、LindedHashMap的区别。TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</li>\n<li>TreeSet：一个已经构建好的 TreeSet，怎么完成倒排序。</li>\n<li>EnumSet 是什么</li>\n</ul>\n</li>\n<li>Hash算法<ul>\n<li>Hashcode 的作用</li>\n<li>简述一致性 Hash 算法</li>\n<li>有没有可能 两个不相等的对象有相同的 hashcode？当两个对象 hashcode 相同怎么办？如何获取值对象</li>\n<li>为什么在重写 equals 方法的时候需要重写 hashCode 方法？equals与 hashCode 的异同点在哪里</li>\n<li>a.hashCode() 有什么用？与 a.equals(b) 有什么关系</li>\n<li>hashCode() 和 equals() 方法的重要性体现在什么地方</li>\n<li>Object：Object有哪些公用方法？Object类hashcode,equals 设计原则？ sun为什么这么设计？Object类的概述</li>\n<li>如何在父类中为子类自动完成所有的 hashcode 和 equals 实现？这么做有何优劣。</li>\n<li>可以在 hashcode() 中使用随机数字吗？</li>\n</ul>\n</li>\n<li>LinkedHashMap<ul>\n<li>LinkedHashMap 和 PriorityQueue 的区别是什么</li>\n</ul>\n</li>\n<li>List<ul>\n<li>List, Set, Map三个接口，存取元素时各有什么特点</li>\n<li>List, Set, Map 是否继承自 Collection 接口</li>\n<li>遍历一个 List 有哪些不同的方式</li>\n<li>LinkedList<ul>\n<li>LinkedList 是单向链表还是双向链表</li>\n<li>LinkedList 与 ArrayList 有什么区别</li>\n<li>描述下 Java 中集合（Collections），接口（Interfaces），实现（Implementations）的概念。LinkedList 与 ArrayList 的区别是什么？</li>\n<li>插入数据时，ArrayList, LinkedList, Vector谁速度较快？</li>\n</ul>\n</li>\n<li>ArrayList<ul>\n<li>ArrayList 和 HashMap 的默认大小是多数</li>\n<li>ArrayList 和 LinkedList 的区别，什么时候用 ArrayList？</li>\n<li>ArrayList 和 Set 的区别？</li>\n<li>ArrayList, LinkedList, Vector的区别</li>\n<li>ArrayList是如何实现的，ArrayList 和 LinkedList 的区别</li>\n<li>ArrayList如何实现扩容</li>\n<li>Array 和 ArrayList 有何区别？什么时候更适合用Array</li>\n<li>说出ArraList,Vector, LinkedList的存储性能和特性</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Map<ul>\n<li>Map, Set, List, Queue, Stack</li>\n<li>Map 接口提供了哪些不同的集合视图</li>\n<li>为什么 Map 接口不继承 Collection 接口</li>\n</ul>\n</li>\n<li>Collections<ul>\n<li>介绍Java中的Collection FrameWork。集合类框架的基本接口有哪些</li>\n<li>Collections类是什么？Collection 和 Collections的区别？Collection、Map的实现</li>\n<li>集合类框架的最佳实践有哪些</li>\n<li>为什么 Collection 不从 Cloneable 和 Serializable 接口继承</li>\n<li>说出几点 Java 中使用 Collections 的最佳实践？</li>\n<li>Collections 中 遗留类 (HashTable、Vector) 和 现有类的区别</li>\n</ul>\n</li>\n<li>什么是 B+树，B-树，列出实际的使用场景。</li>\n</ul>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><ul>\n<li>Comparator 与 Comparable 接口是干什么的？列出它们的区别</li>\n</ul>\n<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><ul>\n<li>拷贝(clone)<ul>\n<li>如何实现对象克隆</li>\n<li>深拷贝和浅拷贝区别</li>\n<li>深拷贝和浅拷贝如何实现激活机制</li>\n<li>写clone()方法时，通常都有一行代码，是什么</li>\n</ul>\n</li>\n<li>比较<ul>\n<li>在比较对象时，”==” 运算符和 equals 运算有何区别</li>\n<li>如果要重写一个对象的equals方法，还要考虑什么</li>\n<li>两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对</li>\n</ul>\n</li>\n<li>构造器<ul>\n<li>构造器链是什么</li>\n<li>创建对象时构造器的调用顺序</li>\n</ul>\n</li>\n<li>不可变对象<ul>\n<li>什么是不可变象（immutable object）</li>\n<li>为什么 Java 中的 String 是不可变的（Immutable）</li>\n<li>如何构建不可变的类结构？关键点在哪里</li>\n<li>能创建一个包含可变对象的不可变对象吗</li>\n</ul>\n</li>\n<li>如何对一组对象进行排序</li>\n</ul>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><ul>\n<li>构造器（constructor）是否可被重写（override）</li>\n<li>方法可以同时即是 static 又是 synchronized 的吗</li>\n<li>abstract 的 method是否可同时是 static，是否可同时是 native，是否可同时是synchronized</li>\n<li>Java支持哪种参数传递类型</li>\n<li>一个对象被当作参数传递到一个方法，是值传递还是引用传递</li>\n<li>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</li>\n<li>我们能否重载main()方法</li>\n<li>如果main方法被声明为private会怎样</li>\n</ul>\n<h2 id=\"GC\"><a href=\"#GC\" class=\"headerlink\" title=\"GC\"></a>GC</h2><ul>\n<li>概念<ul>\n<li>GC是什么？为什么要有GC</li>\n<li>什么时候会导致垃圾回收</li>\n<li>GC是怎么样运行的</li>\n<li>新老以及永久区是什么</li>\n<li>GC 有几种方式？怎么配置</li>\n<li>什么时候一个对象会被GC？ 如何判断一个对象是否存活</li>\n<li>System.gc()  Runtime.gc()会做什么事情？  能保证 GC 执行吗</li>\n<li>垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</li>\n<li>Minor GC 、Major GC、Young GC 与 Full GC分别在什么时候发生</li>\n<li>垃圾回收算法的实现原理</li>\n<li>如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？</li>\n<li>垃圾回收的最佳做法是什么</li>\n</ul>\n</li>\n<li>GC收集器有哪些<ul>\n<li>垃圾回收器的基本原理是什么？</li>\n<li>串行(serial)收集器和吞吐量(throughput)收集器的区别是什么<ul>\n<li>Serial 与 Parallel GC之间的不同之处</li>\n<li>CMS 收集器 与 G1 收集器的特点与区别</li>\n<li>CMS垃圾回收器的工作过程</li>\n<li>JVM 中一次完整的 GC 流程是怎样的？ 对象如何晋升到老年代</li>\n<li>吞吐量优先和响应优先的垃圾收集器选择</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>GC策略<ul>\n<li>举个实际的场景，选择一个GC策略</li>\n<li>JVM的永久代中会发生垃圾回收吗</li>\n</ul>\n</li>\n<li>收集方法<ul>\n<li>标记清除、标记整理、复制算法的原理与特点？分别用在什么地方</li>\n<li>如果让你优化收集方法，有什么思路</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h2><ul>\n<li>参数<ul>\n<li>说说你知道的几种主要的jvm 参数</li>\n<li>-XX:+UseCompressedOops 有什么作用</li>\n</ul>\n</li>\n<li>类加载器(ClassLoader)<ul>\n<li>Java 类加载器都有哪些</li>\n<li>JVM如何加载字节码文件</li>\n</ul>\n</li>\n<li>内存管理<ul>\n<li>JVM内存分哪几个区，每个区的作用是什么</li>\n<li>一个对象从创建到销毁都是怎么在这些部分里存活和转移的</li>\n<li>解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法</li>\n<li>JVM中哪个参数是用来控制线程的栈堆栈小</li>\n<li>简述内存分配与回收策略</li>\n<li>简述重排序，内存屏障，happen-before，主内存，工作内存</li>\n<li>Java中存在内存泄漏问题吗？请举例说明</li>\n<li>简述 Java 中软引用（SoftReferenc）、弱引用（WeakReference）和虚引用</li>\n<li>内存映射缓存区是什么</li>\n</ul>\n</li>\n<li>jstack，jstat，jmap，jconsole怎么用</li>\n<li>32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？32 位和 64 位的 JVM，int 类型变量的长度是多数？</li>\n<li>怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位</li>\n<li>JVM自身会维护缓存吗？是不是在堆中进行对象分配，操作系统的堆还是JVM自己管理堆</li>\n<li>什么情况下会发生栈内存溢出</li>\n<li>双亲委派模型是什么</li>\n</ul>\n<h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h2><ul>\n<li>基本概念<ul>\n<li>什么是线程</li>\n<li>多线程的优点</li>\n<li>多线程的几种实现方式<ul>\n<li>用 Runnable 还是 Thread</li>\n</ul>\n</li>\n<li>什么是线程安全<ul>\n<li>Vector, SimpleDateFormat 是线程安全类吗</li>\n<li>什么 Java 原型不是线程安全的</li>\n<li>哪些集合类是线程安全的</li>\n</ul>\n</li>\n<li>多线程中的忙循环是什么</li>\n<li>如何创建一个线程</li>\n<li>编写多线程程序有几种实现方式</li>\n<li>什么是线程局部变量</li>\n<li>线程和进程有什么区别？进程间如何通讯，线程间如何通讯</li>\n<li>什么是多线程环境下的伪共享（false sharing）</li>\n<li>同步和异步有何异同，在什么情况下分别使用他们？举例说明</li>\n</ul>\n</li>\n<li>Current<ul>\n<li>ConcurrentHashMap 和 Hashtable的区别</li>\n<li>ArrayBlockingQueue, CountDownLatch的用法</li>\n<li>ConcurrentHashMap的并发度是什么</li>\n</ul>\n</li>\n<li>CyclicBarrier 和 CountDownLatch有什么不同？各自的内部原理和用法是什么</li>\n<li>Semaphore的用法</li>\n<li>Thread<ul>\n<li>启动一个线程是调用 run() 还是 start() 方法？start() 和 run() 方法有什么区别</li>\n<li>调用start()方法时会执行run()方法，为什么不能直接调用run()方法</li>\n<li>sleep() 方法和对象的 wait() 方法都可以让线程暂停执行，它们有什么区别</li>\n<li>yield方法有什么作用？sleep() 方法和 yield() 方法有什么区别</li>\n<li>Java 中如何停止一个线程</li>\n<li>stop() 和 suspend() 方法为何不推荐使用</li>\n<li>如何在两个线程间共享数据</li>\n<li>如何强制启动一个线程</li>\n<li>如何让正在运行的线程暂停一段时间</li>\n<li>什么是线程组，为什么在Java中不推荐使用</li>\n<li>你是如何调用  wait（方法的）？使用 if 块还是循环？为什么</li>\n</ul>\n</li>\n<li>生命周期<ul>\n<li>有哪些不同的线程生命周期</li>\n<li>线程状态，BLOCKED 和 WAITING 有什么区别</li>\n<li>画一个线程的生命周期状态图</li>\n</ul>\n</li>\n<li>ThreadLocal 用途是什么，原理是什么，用的时候要注意什么</li>\n<li>ThreadPool<ul>\n<li>线程池是什么？为什么要使用它</li>\n<li>如何创建一个Java线程池<ul>\n<li>ThreadPool用法与优势</li>\n<li>提交任务时，线程池队列已满时会发会生什么</li>\n<li>newCache 和 newFixed 有什么区别？简述原理。构造函数的各个参数的含义是什么，比如 coreSize, maxsize 等</li>\n<li>线程池的实现策略</li>\n<li>线程池的关闭方式有几种，各自的区别是什么</li>\n<li>线程池中submit() 和 execute()方法有什么区别？</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>线程调度<ul>\n<li>Java中用到的线程调度算法是什么</li>\n<li>什么是多线程中的上下文切换</li>\n<li>你对线程优先级的理解是什么</li>\n<li>什么是线程调度器 (Thread Scheduler) 和时间分片 (Time Slicing)</li>\n</ul>\n</li>\n<li>线程同步<ul>\n<li>请说出你所知的线程同步的方法</li>\n<li>synchronized 的原理是什么</li>\n<li>synchronized 和 ReentrantLock 有什么不同</li>\n<li>什么场景下可以使用 volatile 替换 synchronized</li>\n<li>有T1，T2，T3三个线程，怎么确保它们按顺序执行？怎样保证T2在T1执行完后执行，T3在T2执行完后执行</li>\n<li>同步块内的线程抛出异常会发生什么</li>\n<li>当一个线程进入一个对象的 synchronized 方法A 之后，其它线程是否可进入此对象的 synchronized 方法B</li>\n<li>使用 synchronized 修饰静态方法和非静态方法有什么区别</li>\n<li>如何从给定集合那里创建一个 synchronized 的集合</li>\n</ul>\n</li>\n<li>锁<ul>\n<li>Java Concurrency API 中 的 Lock 接口是什么？对比同步它有什么优势</li>\n<li>Lock 与 Synchronized 的区别？Lock 接口比 synchronized 块的优势是什么</li>\n<li>ReadWriteLock是什么？</li>\n<li>锁机制有什么用</li>\n<li>什么是乐观锁（Optimistic Locking）？如何实现乐观锁？如何避免ABA问题</li>\n<li>解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁</li>\n<li>什么时候应该使用可重入锁</li>\n<li>简述锁的等级方法锁、对象锁、类锁</li>\n<li>Java中活锁和死锁有什么区别？</li>\n<li>什么是死锁(Deadlock)？导致线程死锁的原因？如何确保 N 个线程可以访问 N 个资源同时又不导致死锁</li>\n<li>死锁与活锁的区别，死锁与饥饿的区别</li>\n<li>怎么检测一个线程是否拥有锁</li>\n<li>如何实现分布式锁</li>\n<li>有哪些无锁数据结构，他们实现的原理是什么</li>\n<li>读写锁可以用于什么应用场景</li>\n</ul>\n</li>\n<li>Executors类是什么？ Executor和Executors的区别</li>\n<li>什么是Java线程转储(Thread Dump)，如何得到它</li>\n<li>如何在Java中获取线程堆栈</li>\n<li>说出 3 条在 Java 中使用线程的最佳实践</li>\n<li>在线程中你怎么处理不可捕捉异常</li>\n<li>实际项目中使用多线程举例。你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的</li>\n<li>请说出与线程同步以及线程调度相关的方法</li>\n<li>程序中有3个 socket，需要多少个线程来处理</li>\n<li>假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有 10 个线程同时调用它，如何做到</li>\n<li>如何在 Windows 和 Linux 上查找哪个线程使用的 CPU 时间最长</li>\n<li>如何确保 main() 方法所在的线程是 Java 程序最后结束的线程</li>\n<li>非常多个线程（可能是不同机器），相互之间需要等待协调才能完成某种工作，问怎么设计这种协调方案</li>\n<li>你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它</li>\n</ul>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><ul>\n<li>基本概念<ul>\n<li>Error 和 Exception有什么区别<ul>\n<li>UnsupportedOperationException是什么</li>\n<li>NullPointerException 和 ArrayIndexOutOfBoundException 之间有什么相同之处</li>\n</ul>\n</li>\n<li>什么是受检查的异常，什么是运行时异常</li>\n<li>运行时异常与一般异常有何异同</li>\n<li>简述一个你最常见到的runtime exception(运行时异常)</li>\n</ul>\n</li>\n<li>finally<ul>\n<li>finally关键词在异常处理中如何使用<ul>\n<li>如果执行finally代码块之前方法返回了结果，或者JVM退出了，finally块中的代码还会执行吗</li>\n<li>try里有return，finally还执行么？那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后</li>\n<li>在什么情况下，finally语句不会执行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>throw 和 throws 有什么区别？</li>\n<li>OOM你遇到过哪些情况？你是怎么搞定的？</li>\n<li>SOF你遇到过哪些情况？</li>\n<li>既然我们可以用RuntimeException来处理错误，那么你认为为什么Java中还存在检查型异常</li>\n<li>当自己创建异常类的时候应该注意什么</li>\n<li>导致空指针异常的原因</li>\n<li>异常处理 handle or declare 原则应该如何理解</li>\n<li>怎么利用 JUnit 来测试一个方法的异常</li>\n<li>catch块里别不写代码有什么问题</li>\n<li>你曾经自定义实现过异常吗？怎么写的</li>\n<li>什么是 异常链</li>\n<li>在try块中可以抛出异常吗</li>\n</ul>\n<h2 id=\"JDBC\"><a href=\"#JDBC\" class=\"headerlink\" title=\"JDBC\"></a>JDBC</h2><ul>\n<li>通过 JDBC 连接数据库有哪几种方式</li>\n<li>阐述 JDBC 操作数据库的基本步骤</li>\n<li>JDBC 中如何进行事务处理</li>\n<li>什么是 JdbcTemplate</li>\n<li>什么是 DAO 模块</li>\n<li>使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能</li>\n<li>列出 5 个应该遵循的 JDBC 最佳实践</li>\n</ul>\n<h2 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h2><ul>\n<li>File<ul>\n<li>File类型中定义了什么方法来创建一级目录<ul>\n<li>File类型中定义了什么方法来判断一个文件是否存在</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>流<ul>\n<li>为了提高读写性能，可以采用什么流</li>\n<li>Java中有几种类型的流</li>\n<li>JDK 为每种类型的流提供了一些抽象类以供继承，分别是哪些类</li>\n<li>对文本文件操作用什么I/O流</li>\n<li>对各种基本数据类型和String类型的读写，采用什么流</li>\n<li>能指定字符编码的 I/O 流类型是什么</li>\n</ul>\n</li>\n<li>序列化<ul>\n<li>什么是序列化？如何实现 Java 序列化及注意事项</li>\n<li>Serializable 与 Externalizable 的区别</li>\n</ul>\n</li>\n<li>Socket<ul>\n<li>socket 选项 TCP NO DELAY 是指什么</li>\n<li>Socket 工作在 TCP/IP 协议栈是哪一层</li>\n<li>TCP、UDP 区别及 Java 实现方式</li>\n</ul>\n</li>\n<li>说几点 IO 的最佳实践</li>\n<li>直接缓冲区与非直接缓冲器有什么区别？</li>\n<li>怎么读写 ByteBuffer？ByteBuffer 中的字节序是什么</li>\n<li>当用System.in.read(buffer)从键盘输入一行n个字符后，存储在缓冲区buffer中的字节数是多少</li>\n<li>如何使用扫描器类（Scanner Class）令牌化</li>\n</ul>\n<h2 id=\"面向对象编程（OOP）\"><a href=\"#面向对象编程（OOP）\" class=\"headerlink\" title=\"面向对象编程（OOP）\"></a>面向对象编程（OOP）</h2><ul>\n<li>解释下多态性（polymorphism），封装性（encapsulation），内聚（cohesion）以及耦合（coupling）</li>\n<li>多态的实现原理</li>\n<li>封装、继承和多态是什么</li>\n<li>对象封装的原则是什么?</li>\n<li>类<ul>\n<li>获得一个类的类对象有哪些方式</li>\n<li>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</li>\n<li>说出几条 Java 中方法重载的最佳实践</li>\n</ul>\n</li>\n<li>抽象类<ul>\n<li>抽象类和接口的区别</li>\n<li>抽象类中是否可以有静态的main方法</li>\n<li>抽象类是否可实现(implements)接口</li>\n<li>抽象类是否可继承具体类(concrete class)</li>\n</ul>\n</li>\n<li>匿名类（Anonymous Inner Class）<ul>\n<li>匿名内部类是否可以继承其它类？是否可以实现接口</li>\n</ul>\n</li>\n<li>内部类<ul>\n<li>内部类分为几种</li>\n<li>内部类可以引用它的包含类（外部类）的成员吗</li>\n<li>请说一下 Java 中为什么要引入内部类？还有匿名内部类</li>\n</ul>\n</li>\n<li>继承<ul>\n<li>继承（Inheritance）与聚合（Aggregation）的区别在哪里</li>\n<li>继承和组合之间有什么不同</li>\n<li>为什么类只能单继承，接口可以多继承</li>\n<li>存在两个类，B 继承 A，C 继承 B，能将 B 转换为 C 么？如 C = (C) B</li>\n<li>如果类 a 继承类 b，实现接口c，而类 b 和接口 c 中定义了同名变量，请问会出现什么问题</li>\n</ul>\n</li>\n<li>接口<ul>\n<li>接口是什么</li>\n<li>接口是否可继承接口</li>\n<li>为什么要使用接口而不是直接使用具体类？接口有什么优点</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><ul>\n<li>泛型的存在是用来解决什么问题</li>\n<li>泛型的常用特点</li>\n<li>List<String>能否转为List<Object></Object></String></li>\n</ul>\n<h2 id=\"工具类\"><a href=\"#工具类\" class=\"headerlink\" title=\"工具类\"></a>工具类</h2><ul>\n<li>日历<ul>\n<li>Calendar Class的用途</li>\n<li>如何在Java中获取日历类的实例</li>\n<li>解释一些日历类中的重要方法<ul>\n<li>GregorianCalendar 类是什么</li>\n<li>SimpleTimeZone 类是什么</li>\n<li>Locale类是什么</li>\n<li>如何格式化日期对象</li>\n<li>如何添加小时(hour)到一个日期对象(Date Objects)</li>\n<li>如何将字符串 YYYYMMDD 转换为日期</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Math<ul>\n<li>Math.round()什么作用？Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？</li>\n</ul>\n</li>\n<li>XML<ul>\n<li>XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？DOM 和 SAX 解析器有什么不同？</li>\n<li>Java解析XML的方式</li>\n<li>用 jdom 解析 xml 文件时如何解决中文问题？如何解析</li>\n<li>你在项目中用到了 XML 技术的哪些方面？如何实现</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h2><ul>\n<li>描述动态代理的几种实现方式，分别说出相应的优缺点</li>\n</ul>\n<h2 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h2><ul>\n<li>什么是设计模式（Design Patterns）？你用过哪种设计模式？用在什么场合</li>\n<li>你知道哪些商业级设计模式？</li>\n<li>哪些设计模式可以增加系统的可扩展性</li>\n<li>单例模式<ul>\n<li>除了单例模式，你在生产环境中还用过什么设计模式？</li>\n<li>写 Singleton 单例模式</li>\n<li>单例模式的双检锁是什么</li>\n<li>如何创建线程安全的 Singleton</li>\n<li>什么是类的单例模式</li>\n<li>写出三种单例模式实现</li>\n</ul>\n</li>\n<li>适配器模式<ul>\n<li>适配器模式是什么？什么时候使用</li>\n<li>适配器模式和代理模式之前有什么不同</li>\n<li>适配器模式和装饰器模式有什么区别</li>\n</ul>\n</li>\n<li>什么时候使用享元模式</li>\n<li>什么时候使用组合模式</li>\n<li>什么时候使用访问者模式</li>\n<li>什么是模板方法模式</li>\n<li>请给出1个符合开闭原则的设计模式的例子</li>\n</ul>\n<h2 id=\"开放问题\"><a href=\"#开放问题\" class=\"headerlink\" title=\"开放问题\"></a>开放问题</h2><ul>\n<li>用一句话概括 Web 编程的特点</li>\n<li>Google是如何在一秒内把搜索结果返回给用户</li>\n<li>哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入</li>\n<li>树（二叉或其他）形成许多普通数据结构的基础。请描述一些这样的数据结构以及何时可以使用它们</li>\n<li>某一项功能如何设计</li>\n<li>线上系统突然变得异常缓慢，你如何查找问题</li>\n<li>什么样的项目不适合用框架</li>\n<li>新浪微博是如何实现把微博推给订阅者</li>\n<li>简要介绍下从浏览器输入 URL 开始到获取到请求界面之后 Java Web 应用中发生了什么</li>\n<li>请你谈谈SSH整合</li>\n<li>高并发下，如何做到安全的修改同一行数据</li>\n<li>12306网站的订票系统如何实现，如何保证不会票不被超卖</li>\n<li>网站性能优化如何优化的</li>\n<li>聊了下曾经参与设计的服务器架构</li>\n<li>请思考一个方案，实现分布式环境下的 countDownLatch</li>\n<li>请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存</li>\n<li>在你的职业生涯中，算得上最困难的技术挑战是什么</li>\n<li>如何写一篇设计文档，目录是什么</li>\n<li>大写的O是什么？举几个例子</li>\n<li>编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用</li>\n<li>解释一下网络应用的模式及其特点</li>\n<li>设计一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新</li>\n<li>说出数据连接池的工作机制是什么</li>\n<li>怎么获取一个文件中单词出现的最高频率</li>\n<li>描述一下你最常用的编程风格</li>\n<li>如果有机会重新设计你们的产品，你会怎么做</li>\n<li>如何搭建一个高可用系统</li>\n<li>如何启动时不需输入用户名与密码</li>\n<li>如何在基于Java的Web项目中实现文件上传和下载</li>\n<li>如何实现一个秒杀系统，保证只有几位用户能买到某件商品。</li>\n<li>如何实现负载均衡，有哪些算法可以实现</li>\n<li>如何设计一个购物车？想想淘宝的购物车如何实现的</li>\n<li>如何设计一套高并发支付方案，架构如何设计</li>\n<li>如何设计建立和保持 100w 的长连接</li>\n<li>如何避免浏览器缓存。</li>\n<li>如何防止缓存雪崩</li>\n<li>如果AB两个系统互相依赖，如何解除依</li>\n<li>如果有人恶意创建非法连接，怎么解决</li>\n<li>如果有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能</li>\n<li>如果系统要使用超大整数（超过long长度范围），请你设计一个数据结构来存储这种超大型数字以及设计一种算法来实现超大整数加法运算）</li>\n<li>如果要设计一个图形系统，请你设计基本的图形元件(Point,Line,Rectangle,Triangle)的简单实现</li>\n<li>如果让你实现一个并发安全的链表，你会怎么做</li>\n<li>应用服务器与WEB 服务器的区别？应用服务器怎么监控性能，各种方式的区别？你使用过的应用服务器优化技术有哪些</li>\n<li>大型网站在架构上应当考虑哪些问题</li>\n<li>有没有处理过线上问题？出现内存泄露，CPU利用率标高，应用无响应时如何处理的</li>\n<li>最近看什么书，印象最深刻的是什么</li>\n<li>描述下常用的重构技巧</li>\n<li>你使用什么版本管理工具？分支（Branch）与标签（Tag）之间的区别在哪里</li>\n<li>你有了解过存在哪些反模式（Anti-Patterns）吗</li>\n<li>你用过的网站前端优化的技术有哪些</li>\n<li>如何分析Thread dump</li>\n<li>你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念</li>\n<li>你是如何处理内存泄露或者栈溢出问题的</li>\n<li>你们线上应用的 JVM 参数有哪些</li>\n<li>怎么提升系统的QPS和吞吐量</li>\n</ul>\n<h2 id=\"知识面\"><a href=\"#知识面\" class=\"headerlink\" title=\"知识面\"></a>知识面</h2><ul>\n<li>解释什么是 MESI 协议(缓存一致性)</li>\n<li>谈谈 reactor 模型</li>\n<li>Java 9 带来了怎样的新功能</li>\n<li>Java 与 C++ 对比，C++ 或 Java 中的异常处理机制的简单原理和应用</li>\n<li>简单讲讲 Tomcat 结构，以及其类加载器流程</li>\n<li>虚拟内存是什么</li>\n<li>阐述下 SOLID 原则</li>\n<li>请简要讲一下你对测试驱动开发（TDD）的认识</li>\n<li>CDN实现原理</li>\n<li>Maven 和 ANT 有什么区别</li>\n<li>UML中有哪些常用的图</li>\n<li>Linux<ul>\n<li>Linux 下 IO 模型有几种，各自的含义是什么。</li>\n<li>Linux 系统下你关注过哪些内核参数，说说你知道的</li>\n<li>Linux 下用一行命令查看文件的最后五行</li>\n<li>平时用到哪些 Linux 命令</li>\n<li>用一行命令输出正在运行的 Java 进程</li>\n<li>使用什么命令来确定是否有 Tomcat 实例运行在机器上</li>\n</ul>\n</li>\n<li>什么是 N+1 难题</li>\n<li>什么是 paxos 算法</li>\n<li>什么是 restful，讲讲你理解的 restful</li>\n<li>什么是 zab 协议</li>\n<li>什么是领域模型(domain model)？贫血模型(anaemic domain model) 和充血模型(rich domain model)有什么区别</li>\n<li>什么是领域驱动开发（Domain Driven Development）</li>\n<li>介绍一下了解的 Java 领域的 Web Service 框架</li>\n<li>Web Server、Web Container 与 Application Server 的区别是什么</li>\n<li>微服务（MicroServices）与巨石型应用（Monolithic Applications）之间的区别在哪里</li>\n<li>描述 Cookie 和 Session 的作用，区别和各自的应用范围，Session工作原理</li>\n<li>你常用的持续集成（Continuous Integration）、静态代码分析（Static Code Analysis）工具有哪些</li>\n<li>简述下数据库正则化（Normalizations）</li>\n<li>KISS,DRY,YAGNI 等原则是什么含义</li>\n<li>分布式事务的原理，优缺点，如何使用分布式事务？</li>\n<li>布式集群下如何做到唯一序列号</li>\n<li>网络<ul>\n<li>HTTPS 的加密方式是什么，讲讲整个加密解密流程</li>\n<li>HTTPS和HTTP的区别</li>\n<li>HTTP连接池实现原理</li>\n<li>HTTP集群方案</li>\n<li>Nginx、lighttpd、Apache三大主流 Web服务器的区别</li>\n</ul>\n</li>\n<li>是否看过框架的一些代码</li>\n<li>持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些</li>\n<li>数值提升是什么</li>\n<li>你能解释一下里氏替换原则吗</li>\n<li>你是如何测试一个应用的？知道哪些测试框架</li>\n<li>传输层常见编程协议有哪些？并说出各自的特点</li>\n</ul>\n<h2 id=\"编程题\"><a href=\"#编程题\" class=\"headerlink\" title=\"编程题\"></a>编程题</h2><h3 id=\"计算加班费\"><a href=\"#计算加班费\" class=\"headerlink\" title=\"计算加班费\"></a>计算加班费</h3><p>加班10小时以下加班费是时薪的1.5倍。加班10小时或以上，按4元/时算。提示：（一个月工作26天，一天正常工作8小时）</p>\n<ul>\n<li>计算1000月薪，加班9小时的加班费</li>\n<li>计算2500月薪，加班11小时的加班费</li>\n<li>计算1000月薪，加班15小时的加班费</li>\n</ul>\n<h3 id=\"卖东西\"><a href=\"#卖东西\" class=\"headerlink\" title=\"卖东西\"></a>卖东西</h3><p>一家商场有红苹果和青苹果出售。（红苹果5元/个，青苹果4元/个）。</p>\n<ul>\n<li>模拟一个进货。红苹果跟青苹果各进200个。</li>\n<li>模拟一个出售。红苹果跟青苹果各买出10个。每卖出一个苹果需要进行统计。</li>\n</ul>\n<p>提示：一个苹果是一个单独的实体。</p>\n<h3 id=\"日期提取\"><a href=\"#日期提取\" class=\"headerlink\" title=\"日期提取\"></a>日期提取</h3><p>有这样一个时间字符串：2008-8-8 20:08:08 ， 请编写能够匹配它的正则表达式，并编写Java代码将日期后面的时分秒提取出来，即：20:08:08</p>\n<h3 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h3><ul>\n<li>8设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。</li>\n<li>用Java写一个多线程程序，如写四个线程，二个加1，二个对一个变量减一，输出</li>\n<li>wait-notify 写一段代码来解决生产者-消费者问题</li>\n</ul>\n<h3 id=\"数字\"><a href=\"#数字\" class=\"headerlink\" title=\"数字\"></a>数字</h3><ul>\n<li>判断101-200之间有多少个素数，并输出所有素数</li>\n<li>用最有效率的方法算出2乘以17等于多少</li>\n<li>有 1 亿个数字，其中有 2 个是重复的，快速找到它，时间和空间要最优</li>\n<li>2 亿个随机生成的无序整数,找出中间大小的值</li>\n<li>10 亿个数字里里面找最小的 10 个</li>\n<li>1到1亿的自然数，求所有数的拆分后的数字之和，如286 拆分成2、8、6，如1到11拆分后的数字之和 =&gt; 1 + … + 9 + 1 + 0 + 1 + 1</li>\n<li>一个数如果恰好等于它的因子之和，这个数就称为 “完数 “。例如6=1＋2＋3.编程   找出1000以内的所有完数</li>\n<li>一个数组中所有的元素都出现了三次，只有一个元素出现了一次找到这个元素</li>\n<li>一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在   第10次落地时，共经过多少米？第10次反弹多高？</li>\n<li>求100－1000内质数的和</li>\n<li>求1到100的和的平均数</li>\n<li>求s=a+a+aaa+aaaa+aa…a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加有键盘控制。 求出1到100的和</li>\n<li>算出1到40的质数，放进数组里<ul>\n<li>显示放组里的数</li>\n<li>找出第[5]个数</li>\n<li>删除第[9]个数，再显示删除后的第[9]个</li>\n</ul>\n</li>\n<li>有 3n+1 个数字，其中 3n 个中是重复的，只有 1 个是不重复的，怎么找出来。</li>\n<li>有一组数1.1.2.3.5.8.13.21.34。写出程序随便输入一个数就能给出和前一组数字同规律的头5个数</li>\n<li>计算指定数字的阶乘</li>\n<li>开发 Fizz Buzz</li>\n<li>给定一个包含 N 个整数的数组，找出丢失的整数</li>\n<li>一个排好序的数组，找出两数之和为m的所有组合</li>\n<li>将一个正整数分解质因数。例如：输入90,打印出90=2*3*3*5。</li>\n<li>打印出所有的 “水仙花数 “，所谓 “水仙花数 “是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个 “水仙花数 “，因为153=1的三次方＋5的三次方＋3的三次方</li>\n<li>原地交换两个变量的值</li>\n<li>找出4字节整数的中位数</li>\n<li>找到整数的平方根</li>\n<li>实现斐波那契</li>\n</ul>\n<h3 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h3><ul>\n<li>用Java Socket编程，读服务器几个字符，再写入本地显示</li>\n</ul>\n<h2 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h2><ul>\n<li>反射机制提供了什么功能？</li>\n<li>反射是如何实现的</li>\n<li>哪里用到反射机制</li>\n<li>反射中 Class.forName 和 ClassLoader 区别</li>\n<li>反射创建类实例的三种方式是什么</li>\n<li>如何通过反射调用对象的方法</li>\n<li>如何通过反射获取和设置对象私有字段的值</li>\n<li>反射机制的优缺点</li>\n</ul>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><ul>\n<li>写一段 JDBC 连Oracle的程序,并实现数据查询</li>\n</ul>\n<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><ul>\n<li>50个人围坐一圈，当数到三或者三的倍数出圈，问剩下的人是谁，原来的位置是多少</li>\n<li>实现一个电梯模拟器用</li>\n<li>写一个冒泡排序</li>\n<li>写一个折半查找</li>\n<li>随机产生20个不能重复的字符并排序</li>\n<li>写一个函数，传入 2 个有序的整数数组，返回一个有序的整数数组</li>\n<li>写一段代码在遍历 ArrayList 时移除一个元素</li>\n<li>古典问题：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第四个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少</li>\n<li>约瑟芬环游戏</li>\n</ul>\n<h3 id=\"正则\"><a href=\"#正则\" class=\"headerlink\" title=\"正则\"></a>正则</h3><ul>\n<li>请编写一段匹配IP地址的正则表达式</li>\n<li>写出一个正则表达式来判断一个字符串是否是一个数字</li>\n</ul>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><ul>\n<li>写一个方法，入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。</li>\n<li>写一个程序找出所有字符串的组合，并检查它们是否是回文串</li>\n<li>写一个字符串反转函数，输入abcde转换成edcba代码</li>\n<li>小游戏，倒转句子中的单词</li>\n<li>将GB2312编码的字符串转换为ISO-8859-1编码的字符串</li>\n<li>请写一段代码来计算给定文本内字符“A”的个数。分别用迭代和递归两种方式</li>\n<li>编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串。 但是要保证汉字不被截半个，如“我ABC”4，应该截为“我AB”，输入“我ABC汉DEF”，6，应该输出为“我ABC”而不是“我ABC+汉的半个”</li>\n<li>给定 2 个包含单词列表（每行一个）的文件，编程列出交集</li>\n<li>打印出一个字符串的所有排列</li>\n<li>将一个键盘输入的数字转化成中文输出(例如：输入1234567，输出:一百二拾三万四千五百六拾七)</li>\n<li>在Web应用开发过程中经常遇到输出某种编码的字符，如从 GBK 到 ISO8859-1等，如何输出一个某种编码的字符串</li>\n</ul>\n<h2 id=\"日期\"><a href=\"#日期\" class=\"headerlink\" title=\"日期\"></a>日期</h2><ul>\n<li>计算两个日期之间的差距</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li>mysql表数据压缩</li>\n</ul>"},{"title":"Paxos算法","date":"2017-03-07T08:20:27.000Z","toc":true,"_content":"### 概述\nPaxos算法是Lamport创造基于消息传递的一致性算法，包括Google的Chubby在内很多系统都应用了Paxos算法，Google Chubby[1]有下面的描述：\n```\nall working protocols for asynchronous consensus we have so far encountered have Paxos at their core.\n```\n足见该算法在分布式系统中的地位。\n<!--more-->\n### 背景说明\nPaxos解决的问题是，在分布式系统中系统间如何就一个不可变变量达成一致，仅此而已！但是在该算法的基础之上我们可以做非常有意义的事情，比如Google Chubby就是对Multi-Paxos算法的工程实现，Multi-Paxos\n算法的基础就是Paxos，通俗来说，就是多个轮次的Paxos算法的执行，确定一系列不可能变量的值，如果各个节点初始状态一致，再执行相同的操作序列（即确定的一系列不可变变量的值），那么最终结果必然也是一致的。这是可以应用于系统容错和系统一致性上的。","source":"_posts/6Paxos算法.md","raw":"---\ntitle: Paxos算法\ndate: 2017-03-07 16:20:27\ntags: Paxos\ncategories: \"技术\"\ntoc: true\n---\n### 概述\nPaxos算法是Lamport创造基于消息传递的一致性算法，包括Google的Chubby在内很多系统都应用了Paxos算法，Google Chubby[1]有下面的描述：\n```\nall working protocols for asynchronous consensus we have so far encountered have Paxos at their core.\n```\n足见该算法在分布式系统中的地位。\n<!--more-->\n### 背景说明\nPaxos解决的问题是，在分布式系统中系统间如何就一个不可变变量达成一致，仅此而已！但是在该算法的基础之上我们可以做非常有意义的事情，比如Google Chubby就是对Multi-Paxos算法的工程实现，Multi-Paxos\n算法的基础就是Paxos，通俗来说，就是多个轮次的Paxos算法的执行，确定一系列不可能变量的值，如果各个节点初始状态一致，再执行相同的操作序列（即确定的一系列不可变变量的值），那么最终结果必然也是一致的。这是可以应用于系统容错和系统一致性上的。","slug":"6Paxos算法","published":1,"updated":"2018-11-28T09:59:18.911Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tcaq0023a7xwcitunhm5","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>Paxos算法是Lamport创造基于消息传递的一致性算法，包括Google的Chubby在内很多系统都应用了Paxos算法，Google Chubby[1]有下面的描述：<br><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">all</span> working protocols <span class=\"keyword\">for</span> asynchronous consensus we have so far encountered have Paxos <span class=\"keyword\">at</span> their core.</div></pre></td></tr></table></figure></p>\n<p>足见该算法在分布式系统中的地位。<br><a id=\"more\"></a></p>\n<h3 id=\"背景说明\"><a href=\"#背景说明\" class=\"headerlink\" title=\"背景说明\"></a>背景说明</h3><p>Paxos解决的问题是，在分布式系统中系统间如何就一个不可变变量达成一致，仅此而已！但是在该算法的基础之上我们可以做非常有意义的事情，比如Google Chubby就是对Multi-Paxos算法的工程实现，Multi-Paxos<br>算法的基础就是Paxos，通俗来说，就是多个轮次的Paxos算法的执行，确定一系列不可能变量的值，如果各个节点初始状态一致，再执行相同的操作序列（即确定的一系列不可变变量的值），那么最终结果必然也是一致的。这是可以应用于系统容错和系统一致性上的。</p>\n","excerpt":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>Paxos算法是Lamport创造基于消息传递的一致性算法，包括Google的Chubby在内很多系统都应用了Paxos算法，Google Chubby[1]有下面的描述：<br><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">all</span> working protocols <span class=\"keyword\">for</span> asynchronous consensus we have so far encountered have Paxos <span class=\"keyword\">at</span> their core.</div></pre></td></tr></table></figure></p>\n<p>足见该算法在分布式系统中的地位。<br></p>","more":"<p></p>\n<h3 id=\"背景说明\"><a href=\"#背景说明\" class=\"headerlink\" title=\"背景说明\"></a>背景说明</h3><p>Paxos解决的问题是，在分布式系统中系统间如何就一个不可变变量达成一致，仅此而已！但是在该算法的基础之上我们可以做非常有意义的事情，比如Google Chubby就是对Multi-Paxos算法的工程实现，Multi-Paxos<br>算法的基础就是Paxos，通俗来说，就是多个轮次的Paxos算法的执行，确定一系列不可能变量的值，如果各个节点初始状态一致，再执行相同的操作序列（即确定的一系列不可变变量的值），那么最终结果必然也是一致的。这是可以应用于系统容错和系统一致性上的。</p>"},{"title":"HashMap不同遍历方式性能比较","date":"2017-02-11T01:55:59.000Z","toc":true,"_content":"#### 一、遍历keySet，再用get方法获得value。\n（1）利用iterator遍历\n```\nHashMap<String,String> map = new HashMap<String,String>();\nIterator<String> iterator = map.keySet().iterator();\nwhile (iterator.hasNext())\n    map.get(iterator.next());\n```\n<!--more-->\n（2）利用foreach遍历\n```\nHashMap<String,String> map = new HashMap<String,String>();\nSet<String> key = map.keySet();\nfor(String str: key)\n    map.get(str);\n```\n#### 二、遍历values，直接得到value。\n（1）利用iterator遍历\n```\nHashMap<String,String> map = new HashMap<String,String>();\nIterator<String> iterator = map.values().iterator();\nwhile (iterator.hasNext())\n    iterator.next();\n```\n（2）利用foreach遍历\n```\nHashMap<String,String> map = new HashMap<String,String>();\nCollection<String> value = map.values();\nfor(String str: value);\n```\n#### 三、遍历entrySet ,再分别用getKey和getValue得到key、value。\n（1）利用iterator遍历\n```\nHashMap<String,String> map = new HashMap<String,String>();\nIterator<Map.Entry<String,String>> iterator = map.entrySet().iterator();\nwhile(iterator.hasNext()){\n    iterator.next().getKey();\n    iterator.next().getValue();\n}\n```\n（2）利用foreach遍历\n```\nHashMap<String,String> map = new HashMap<String,String>();\nSet<Map.Entry<String,String>> entry = map.entrySet();\nfor(Map.Entry<String,String> en: entry){\n     en.getKey();\n     en.getValue();\n}\n```\n#### 四、不同遍历方式下的时间性能比较（这里设定HashMap大小为1000000）\n遍历方式|所需时间(ms)\n-|-\niterator遍历keySet|59\niterator遍历values|28\niterator遍历entrySet|32\nforeach遍历keySet|40\nforeach遍历values|26\nforeach遍历entrySet|29\n\n#### 五、 总结\n从结果可以看出：\n1. 利用foreach语句遍历普遍比iterator所需的时间少。\n2. 直接遍历values所需的时间最少。\n3. 遍历keySet所需的时间最多。原因是除了遍历keySet，我们还需要用get方法得到每一个key的value。get方法通过计算key的hash值找到对应的value，增加了遍历的时间。\n\n#### 六、 代码\n\n```\nprivate static void test1() {\n    //准备数据\n    Map<String, String> map = new HashMap<String, String>();\n    for (int i = 0; i < 1000000; i++) {\n        map.put(\"a\" + i, \"a\" + i);\n    }\n    String temp;\n    // 分别计算10次\n    for (int c = 0; c < 10; c++) {\n        long start = System.currentTimeMillis();\n        Iterator<String> iterator1 = map.keySet().iterator();\n        while (iterator1.hasNext()){\n            temp = map.get(iterator1.next());\n        }\n        System.out.print(\"KeySet->iterator->getKey：\" + (System.currentTimeMillis() - start) + \"  ms, \");\n\n        start = System.currentTimeMillis();\n        Set<String> key = map.keySet();\n        for(String str: key)\n            temp =  map.get(str);\n        System.out.print(\"KeySet->for->getKey：\" + (System.currentTimeMillis() - start) + \"  ms, \");\n\n        start = System.currentTimeMillis();\n        Iterator<String> iterator2 = map.values().iterator();\n        while (iterator2.hasNext())\n            temp = iterator2.next();\n        System.out.print(\"values->iterator：\" + (System.currentTimeMillis() - start) + \"  ms, \");\n\n        start = System.currentTimeMillis();\n        Collection<String> value = map.values();\n        for(String str: value)\n            temp = str;\n        System.out.print(\"values->for：\" + (System.currentTimeMillis() - start) + \"  ms, \");\n\n        start = System.currentTimeMillis();\n        Iterator<Map.Entry<String,String>> iterator3 = map.entrySet().iterator();\n        while(iterator3.hasNext()){\n            temp = iterator3.next().getValue();\n        }\n        System.out.print(\"entrySet->iterator->getKey：\" + (System.currentTimeMillis() - start) + \"  ms, \");\n\n        start = System.currentTimeMillis();\n        Set<Map.Entry<String,String>> entry = map.entrySet();\n        for(Map.Entry<String,String> en: entry){\n            temp = en.getValue();\n        }\n        System.out.println(\"entrySet->for->getKey：\" + (System.currentTimeMillis() - start) + \"  ms\");\n    }\n}\n```\n结果:\n```\nKeySet->iterator->getKey：55  ms, KeySet->for->getKey：58  ms, values->iterator：29  ms, values->for：25  ms, entrySet->iterator->getKey：26  ms, entrySet->for->getKey：26  ms\nKeySet->iterator->getKey：39  ms, KeySet->for->getKey：52  ms, values->iterator：63  ms, values->for：29  ms, entrySet->iterator->getKey：19  ms, entrySet->for->getKey：19  ms\nKeySet->iterator->getKey：42  ms, KeySet->for->getKey：34  ms, values->iterator：22  ms, values->for：20  ms, entrySet->iterator->getKey：20  ms, entrySet->for->getKey：21  ms\nKeySet->iterator->getKey：33  ms, KeySet->for->getKey：29  ms, values->iterator：23  ms, values->for：32  ms, entrySet->iterator->getKey：24  ms, entrySet->for->getKey：20  ms\nKeySet->iterator->getKey：35  ms, KeySet->for->getKey：30  ms, values->iterator：22  ms, values->for：20  ms, entrySet->iterator->getKey：34  ms, entrySet->for->getKey：22  ms\nKeySet->iterator->getKey：51  ms, KeySet->for->getKey：28  ms, values->iterator：21  ms, values->for：20  ms, entrySet->iterator->getKey：22  ms, entrySet->for->getKey：21  ms\nKeySet->iterator->getKey：37  ms, KeySet->for->getKey：45  ms, values->iterator：24  ms, values->for：21  ms, entrySet->iterator->getKey：22  ms, entrySet->for->getKey：21  ms\nKeySet->iterator->getKey：40  ms, KeySet->for->getKey：33  ms, values->iterator：21  ms, values->for：22  ms, entrySet->iterator->getKey：45  ms, entrySet->for->getKey：24  ms\nKeySet->iterator->getKey：40  ms, KeySet->for->getKey：33  ms, values->iterator：21  ms, values->for：21  ms, entrySet->iterator->getKey：20  ms, entrySet->for->getKey：34  ms\nKeySet->iterator->getKey：39  ms, KeySet->for->getKey：33  ms, values->iterator：22  ms, values->for：19  ms, entrySet->iterator->getKey：19  ms, entrySet->for->getKey：22  ms\n\n```","source":"_posts/4HashMap不同遍历方式性能比较.md","raw":"---\ntitle: HashMap不同遍历方式性能比较\ndate: 2017-02-11 09:55:59\ntags: Java 对比\ncategories: \"Java\"\ntoc: true\n---\n#### 一、遍历keySet，再用get方法获得value。\n（1）利用iterator遍历\n```\nHashMap<String,String> map = new HashMap<String,String>();\nIterator<String> iterator = map.keySet().iterator();\nwhile (iterator.hasNext())\n    map.get(iterator.next());\n```\n<!--more-->\n（2）利用foreach遍历\n```\nHashMap<String,String> map = new HashMap<String,String>();\nSet<String> key = map.keySet();\nfor(String str: key)\n    map.get(str);\n```\n#### 二、遍历values，直接得到value。\n（1）利用iterator遍历\n```\nHashMap<String,String> map = new HashMap<String,String>();\nIterator<String> iterator = map.values().iterator();\nwhile (iterator.hasNext())\n    iterator.next();\n```\n（2）利用foreach遍历\n```\nHashMap<String,String> map = new HashMap<String,String>();\nCollection<String> value = map.values();\nfor(String str: value);\n```\n#### 三、遍历entrySet ,再分别用getKey和getValue得到key、value。\n（1）利用iterator遍历\n```\nHashMap<String,String> map = new HashMap<String,String>();\nIterator<Map.Entry<String,String>> iterator = map.entrySet().iterator();\nwhile(iterator.hasNext()){\n    iterator.next().getKey();\n    iterator.next().getValue();\n}\n```\n（2）利用foreach遍历\n```\nHashMap<String,String> map = new HashMap<String,String>();\nSet<Map.Entry<String,String>> entry = map.entrySet();\nfor(Map.Entry<String,String> en: entry){\n     en.getKey();\n     en.getValue();\n}\n```\n#### 四、不同遍历方式下的时间性能比较（这里设定HashMap大小为1000000）\n遍历方式|所需时间(ms)\n-|-\niterator遍历keySet|59\niterator遍历values|28\niterator遍历entrySet|32\nforeach遍历keySet|40\nforeach遍历values|26\nforeach遍历entrySet|29\n\n#### 五、 总结\n从结果可以看出：\n1. 利用foreach语句遍历普遍比iterator所需的时间少。\n2. 直接遍历values所需的时间最少。\n3. 遍历keySet所需的时间最多。原因是除了遍历keySet，我们还需要用get方法得到每一个key的value。get方法通过计算key的hash值找到对应的value，增加了遍历的时间。\n\n#### 六、 代码\n\n```\nprivate static void test1() {\n    //准备数据\n    Map<String, String> map = new HashMap<String, String>();\n    for (int i = 0; i < 1000000; i++) {\n        map.put(\"a\" + i, \"a\" + i);\n    }\n    String temp;\n    // 分别计算10次\n    for (int c = 0; c < 10; c++) {\n        long start = System.currentTimeMillis();\n        Iterator<String> iterator1 = map.keySet().iterator();\n        while (iterator1.hasNext()){\n            temp = map.get(iterator1.next());\n        }\n        System.out.print(\"KeySet->iterator->getKey：\" + (System.currentTimeMillis() - start) + \"  ms, \");\n\n        start = System.currentTimeMillis();\n        Set<String> key = map.keySet();\n        for(String str: key)\n            temp =  map.get(str);\n        System.out.print(\"KeySet->for->getKey：\" + (System.currentTimeMillis() - start) + \"  ms, \");\n\n        start = System.currentTimeMillis();\n        Iterator<String> iterator2 = map.values().iterator();\n        while (iterator2.hasNext())\n            temp = iterator2.next();\n        System.out.print(\"values->iterator：\" + (System.currentTimeMillis() - start) + \"  ms, \");\n\n        start = System.currentTimeMillis();\n        Collection<String> value = map.values();\n        for(String str: value)\n            temp = str;\n        System.out.print(\"values->for：\" + (System.currentTimeMillis() - start) + \"  ms, \");\n\n        start = System.currentTimeMillis();\n        Iterator<Map.Entry<String,String>> iterator3 = map.entrySet().iterator();\n        while(iterator3.hasNext()){\n            temp = iterator3.next().getValue();\n        }\n        System.out.print(\"entrySet->iterator->getKey：\" + (System.currentTimeMillis() - start) + \"  ms, \");\n\n        start = System.currentTimeMillis();\n        Set<Map.Entry<String,String>> entry = map.entrySet();\n        for(Map.Entry<String,String> en: entry){\n            temp = en.getValue();\n        }\n        System.out.println(\"entrySet->for->getKey：\" + (System.currentTimeMillis() - start) + \"  ms\");\n    }\n}\n```\n结果:\n```\nKeySet->iterator->getKey：55  ms, KeySet->for->getKey：58  ms, values->iterator：29  ms, values->for：25  ms, entrySet->iterator->getKey：26  ms, entrySet->for->getKey：26  ms\nKeySet->iterator->getKey：39  ms, KeySet->for->getKey：52  ms, values->iterator：63  ms, values->for：29  ms, entrySet->iterator->getKey：19  ms, entrySet->for->getKey：19  ms\nKeySet->iterator->getKey：42  ms, KeySet->for->getKey：34  ms, values->iterator：22  ms, values->for：20  ms, entrySet->iterator->getKey：20  ms, entrySet->for->getKey：21  ms\nKeySet->iterator->getKey：33  ms, KeySet->for->getKey：29  ms, values->iterator：23  ms, values->for：32  ms, entrySet->iterator->getKey：24  ms, entrySet->for->getKey：20  ms\nKeySet->iterator->getKey：35  ms, KeySet->for->getKey：30  ms, values->iterator：22  ms, values->for：20  ms, entrySet->iterator->getKey：34  ms, entrySet->for->getKey：22  ms\nKeySet->iterator->getKey：51  ms, KeySet->for->getKey：28  ms, values->iterator：21  ms, values->for：20  ms, entrySet->iterator->getKey：22  ms, entrySet->for->getKey：21  ms\nKeySet->iterator->getKey：37  ms, KeySet->for->getKey：45  ms, values->iterator：24  ms, values->for：21  ms, entrySet->iterator->getKey：22  ms, entrySet->for->getKey：21  ms\nKeySet->iterator->getKey：40  ms, KeySet->for->getKey：33  ms, values->iterator：21  ms, values->for：22  ms, entrySet->iterator->getKey：45  ms, entrySet->for->getKey：24  ms\nKeySet->iterator->getKey：40  ms, KeySet->for->getKey：33  ms, values->iterator：21  ms, values->for：21  ms, entrySet->iterator->getKey：20  ms, entrySet->for->getKey：34  ms\nKeySet->iterator->getKey：39  ms, KeySet->for->getKey：33  ms, values->iterator：22  ms, values->for：19  ms, entrySet->iterator->getKey：19  ms, entrySet->for->getKey：22  ms\n\n```","slug":"4HashMap不同遍历方式性能比较","published":1,"updated":"2017-07-20T02:55:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tcas0026a7xwet91yfx6","content":"<h4 id=\"一、遍历keySet，再用get方法获得value。\"><a href=\"#一、遍历keySet，再用get方法获得value。\" class=\"headerlink\" title=\"一、遍历keySet，再用get方法获得value。\"></a>一、遍历keySet，再用get方法获得value。</h4><p>（1）利用iterator遍历<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">HashMap</span>&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt; <span class=\"built_in\">map</span> = <span class=\"keyword\">new</span> <span class=\"keyword\">HashMap</span>&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt;();</div><div class=\"line\">Iterator&lt;<span class=\"keyword\">String</span>&gt; iterator = <span class=\"built_in\">map</span>.keySet().iterator();</div><div class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext())</div><div class=\"line\">    <span class=\"built_in\">map</span>.<span class=\"built_in\">get</span>(iterator.next());</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>（2）利用foreach遍历<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">HashMap</span>&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt; <span class=\"built_in\">map</span> = <span class=\"keyword\">new</span> <span class=\"keyword\">HashMap</span>&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt;();</div><div class=\"line\">Set&lt;<span class=\"keyword\">String</span>&gt; <span class=\"built_in\">key</span> = <span class=\"built_in\">map</span>.keySet();</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">String</span> <span class=\"built_in\">str</span>: <span class=\"built_in\">key</span>)</div><div class=\"line\">    <span class=\"built_in\">map</span>.<span class=\"built_in\">get</span>(<span class=\"built_in\">str</span>);</div></pre></td></tr></table></figure></p>\n<h4 id=\"二、遍历values，直接得到value。\"><a href=\"#二、遍历values，直接得到value。\" class=\"headerlink\" title=\"二、遍历values，直接得到value。\"></a>二、遍历values，直接得到value。</h4><p>（1）利用iterator遍历<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">HashMap</span>&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt; <span class=\"built_in\">map</span> = <span class=\"keyword\">new</span> <span class=\"keyword\">HashMap</span>&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt;();</div><div class=\"line\">Iterator&lt;<span class=\"keyword\">String</span>&gt; iterator = <span class=\"built_in\">map</span>.values().iterator();</div><div class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext())</div><div class=\"line\">    iterator.next();</div></pre></td></tr></table></figure></p>\n<p>（2）利用foreach遍历<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">HashMap</span>&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt; <span class=\"built_in\">map</span> = <span class=\"keyword\">new</span> <span class=\"keyword\">HashMap</span>&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt;();</div><div class=\"line\">Collection&lt;<span class=\"keyword\">String</span>&gt; value = <span class=\"built_in\">map</span>.values();</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">String</span> <span class=\"built_in\">str</span>: value);</div></pre></td></tr></table></figure></p>\n<h4 id=\"三、遍历entrySet-再分别用getKey和getValue得到key、value。\"><a href=\"#三、遍历entrySet-再分别用getKey和getValue得到key、value。\" class=\"headerlink\" title=\"三、遍历entrySet ,再分别用getKey和getValue得到key、value。\"></a>三、遍历entrySet ,再分别用getKey和getValue得到key、value。</h4><p>（1）利用iterator遍历<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">HashMap</span>&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt; <span class=\"built_in\">map</span> = <span class=\"keyword\">new</span> <span class=\"keyword\">HashMap</span>&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt;();</div><div class=\"line\">Iterator&lt;Map.Entry&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt;&gt; iterator = <span class=\"built_in\">map</span>.entrySet().iterator();</div><div class=\"line\"><span class=\"keyword\">while</span>(iterator.hasNext())&#123;</div><div class=\"line\">    iterator.next().getKey();</div><div class=\"line\">    iterator.next().getValue();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>（2）利用foreach遍历<br><figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">HashMap&lt;<span class=\"built_in\">String</span>,<span class=\"built_in\">String</span>&gt; <span class=\"built_in\">map</span> = <span class=\"literal\">new</span> HashMap&lt;<span class=\"built_in\">String</span>,<span class=\"built_in\">String</span>&gt;();</div><div class=\"line\"><span class=\"built_in\">Set</span>&lt;<span class=\"built_in\">Map</span>.Entry&lt;<span class=\"built_in\">String</span>,<span class=\"built_in\">String</span>&gt;&gt; entry = <span class=\"built_in\">map</span>.entrySet();</div><div class=\"line\">for(<span class=\"built_in\">Map</span>.Entry&lt;<span class=\"built_in\">String</span>,<span class=\"built_in\">String</span>&gt; en: entry)&#123;</div><div class=\"line\">     en.getKey();</div><div class=\"line\">     en.getValue();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"四、不同遍历方式下的时间性能比较（这里设定HashMap大小为1000000）\"><a href=\"#四、不同遍历方式下的时间性能比较（这里设定HashMap大小为1000000）\" class=\"headerlink\" title=\"四、不同遍历方式下的时间性能比较（这里设定HashMap大小为1000000）\"></a>四、不同遍历方式下的时间性能比较（这里设定HashMap大小为1000000）</h4><table>\n<thead>\n<tr>\n<th>遍历方式</th>\n<th>所需时间(ms)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>iterator遍历keySet</td>\n<td>59</td>\n</tr>\n<tr>\n<td>iterator遍历values</td>\n<td>28</td>\n</tr>\n<tr>\n<td>iterator遍历entrySet</td>\n<td>32</td>\n</tr>\n<tr>\n<td>foreach遍历keySet</td>\n<td>40</td>\n</tr>\n<tr>\n<td>foreach遍历values</td>\n<td>26</td>\n</tr>\n<tr>\n<td>foreach遍历entrySet</td>\n<td>29</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"五、-总结\"><a href=\"#五、-总结\" class=\"headerlink\" title=\"五、 总结\"></a>五、 总结</h4><p>从结果可以看出：</p>\n<ol>\n<li>利用foreach语句遍历普遍比iterator所需的时间少。</li>\n<li>直接遍历values所需的时间最少。</li>\n<li>遍历keySet所需的时间最多。原因是除了遍历keySet，我们还需要用get方法得到每一个key的value。get方法通过计算key的hash值找到对应的value，增加了遍历的时间。</li>\n</ol>\n<h4 id=\"六、-代码\"><a href=\"#六、-代码\" class=\"headerlink\" title=\"六、 代码\"></a>六、 代码</h4><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> test1() &#123;</div><div class=\"line\">    <span class=\"comment\">//准备数据</span></div><div class=\"line\">    Map&lt;<span class=\"keyword\">String</span>, <span class=\"keyword\">String</span>&gt; <span class=\"built_in\">map</span> = <span class=\"keyword\">new</span> <span class=\"keyword\">HashMap</span>&lt;<span class=\"keyword\">String</span>, <span class=\"keyword\">String</span>&gt;();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000000</span>; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">map</span>.put(<span class=\"string\">\"a\"</span> + i, <span class=\"string\">\"a\"</span> + i);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">String</span> temp;</div><div class=\"line\">    <span class=\"comment\">// 分别计算10次</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> c = <span class=\"number\">0</span>; c &lt; <span class=\"number\">10</span>; c++) &#123;</div><div class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</div><div class=\"line\">        Iterator&lt;<span class=\"keyword\">String</span>&gt; iterator1 = <span class=\"built_in\">map</span>.keySet().iterator();</div><div class=\"line\">        <span class=\"keyword\">while</span> (iterator1.hasNext())&#123;</div><div class=\"line\">            temp = <span class=\"built_in\">map</span>.<span class=\"built_in\">get</span>(iterator1.next());</div><div class=\"line\">        &#125;</div><div class=\"line\">        System.out.<span class=\"built_in\">print</span>(<span class=\"string\">\"KeySet-&gt;iterator-&gt;getKey：\"</span> + (System.currentTimeMillis() - start) + <span class=\"string\">\"  ms, \"</span>);</div><div class=\"line\"></div><div class=\"line\">        start = System.currentTimeMillis();</div><div class=\"line\">        Set&lt;<span class=\"keyword\">String</span>&gt; <span class=\"built_in\">key</span> = <span class=\"built_in\">map</span>.keySet();</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">String</span> <span class=\"built_in\">str</span>: <span class=\"built_in\">key</span>)</div><div class=\"line\">            temp =  <span class=\"built_in\">map</span>.<span class=\"built_in\">get</span>(<span class=\"built_in\">str</span>);</div><div class=\"line\">        System.out.<span class=\"built_in\">print</span>(<span class=\"string\">\"KeySet-&gt;for-&gt;getKey：\"</span> + (System.currentTimeMillis() - start) + <span class=\"string\">\"  ms, \"</span>);</div><div class=\"line\"></div><div class=\"line\">        start = System.currentTimeMillis();</div><div class=\"line\">        Iterator&lt;<span class=\"keyword\">String</span>&gt; iterator2 = <span class=\"built_in\">map</span>.values().iterator();</div><div class=\"line\">        <span class=\"keyword\">while</span> (iterator2.hasNext())</div><div class=\"line\">            temp = iterator2.next();</div><div class=\"line\">        System.out.<span class=\"built_in\">print</span>(<span class=\"string\">\"values-&gt;iterator：\"</span> + (System.currentTimeMillis() - start) + <span class=\"string\">\"  ms, \"</span>);</div><div class=\"line\"></div><div class=\"line\">        start = System.currentTimeMillis();</div><div class=\"line\">        Collection&lt;<span class=\"keyword\">String</span>&gt; value = <span class=\"built_in\">map</span>.values();</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">String</span> <span class=\"built_in\">str</span>: value)</div><div class=\"line\">            temp = <span class=\"built_in\">str</span>;</div><div class=\"line\">        System.out.<span class=\"built_in\">print</span>(<span class=\"string\">\"values-&gt;for：\"</span> + (System.currentTimeMillis() - start) + <span class=\"string\">\"  ms, \"</span>);</div><div class=\"line\"></div><div class=\"line\">        start = System.currentTimeMillis();</div><div class=\"line\">        Iterator&lt;Map.Entry&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt;&gt; iterator3 = <span class=\"built_in\">map</span>.entrySet().iterator();</div><div class=\"line\">        <span class=\"keyword\">while</span>(iterator3.hasNext())&#123;</div><div class=\"line\">            temp = iterator3.next().getValue();</div><div class=\"line\">        &#125;</div><div class=\"line\">        System.out.<span class=\"built_in\">print</span>(<span class=\"string\">\"entrySet-&gt;iterator-&gt;getKey：\"</span> + (System.currentTimeMillis() - start) + <span class=\"string\">\"  ms, \"</span>);</div><div class=\"line\"></div><div class=\"line\">        start = System.currentTimeMillis();</div><div class=\"line\">        Set&lt;Map.Entry&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt;&gt; entry = <span class=\"built_in\">map</span>.entrySet();</div><div class=\"line\">        <span class=\"keyword\">for</span>(Map.Entry&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt; en: entry)&#123;</div><div class=\"line\">            temp = en.getValue();</div><div class=\"line\">        &#125;</div><div class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"entrySet-&gt;for-&gt;getKey：\"</span> + (System.currentTimeMillis() - start) + <span class=\"string\">\"  ms\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果:<br><figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">K<span class=\"function\"><span class=\"title\">eySet</span>-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：55  ms, KeySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：58  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>：29  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">for</span>：25  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：26  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span>getKey：<span class=\"number\">26</span>  ms</div><div class=\"line\">K<span class=\"function\"><span class=\"title\">eySet</span>-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：39  ms, KeySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：52  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>：63  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">for</span>：29  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：19  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span>getKey：<span class=\"number\">19</span>  ms</div><div class=\"line\">K<span class=\"function\"><span class=\"title\">eySet</span>-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：42  ms, KeySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：34  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>：22  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">for</span>：20  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：20  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span>getKey：<span class=\"number\">21</span>  ms</div><div class=\"line\">K<span class=\"function\"><span class=\"title\">eySet</span>-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：33  ms, KeySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：29  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>：23  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">for</span>：32  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：24  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span>getKey：<span class=\"number\">20</span>  ms</div><div class=\"line\">K<span class=\"function\"><span class=\"title\">eySet</span>-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：35  ms, KeySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：30  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>：22  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">for</span>：20  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：34  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span>getKey：<span class=\"number\">22</span>  ms</div><div class=\"line\">K<span class=\"function\"><span class=\"title\">eySet</span>-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：51  ms, KeySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：28  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>：21  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">for</span>：20  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：22  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span>getKey：<span class=\"number\">21</span>  ms</div><div class=\"line\">K<span class=\"function\"><span class=\"title\">eySet</span>-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：37  ms, KeySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：45  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>：24  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">for</span>：21  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：22  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span>getKey：<span class=\"number\">21</span>  ms</div><div class=\"line\">K<span class=\"function\"><span class=\"title\">eySet</span>-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：40  ms, KeySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：33  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>：21  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">for</span>：22  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：45  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span>getKey：<span class=\"number\">24</span>  ms</div><div class=\"line\">K<span class=\"function\"><span class=\"title\">eySet</span>-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：40  ms, KeySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：33  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>：21  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">for</span>：21  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：20  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span>getKey：<span class=\"number\">34</span>  ms</div><div class=\"line\">K<span class=\"function\"><span class=\"title\">eySet</span>-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：39  ms, KeySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：33  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>：22  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">for</span>：19  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：19  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span>getKey：<span class=\"number\">22</span>  ms</div></pre></td></tr></table></figure></p>\n","excerpt":"<h4 id=\"一、遍历keySet，再用get方法获得value。\"><a href=\"#一、遍历keySet，再用get方法获得value。\" class=\"headerlink\" title=\"一、遍历keySet，再用get方法获得value。\"></a>一、遍历keySet，再用get方法获得value。</h4><p>（1）利用iterator遍历<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">HashMap</span>&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt; <span class=\"built_in\">map</span> = <span class=\"keyword\">new</span> <span class=\"keyword\">HashMap</span>&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt;();</div><div class=\"line\">Iterator&lt;<span class=\"keyword\">String</span>&gt; iterator = <span class=\"built_in\">map</span>.keySet().iterator();</div><div class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext())</div><div class=\"line\">    <span class=\"built_in\">map</span>.<span class=\"built_in\">get</span>(iterator.next());</div></pre></td></tr></table></figure></p>","more":"<p>（2）利用foreach遍历<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">HashMap</span>&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt; <span class=\"built_in\">map</span> = <span class=\"keyword\">new</span> <span class=\"keyword\">HashMap</span>&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt;();</div><div class=\"line\">Set&lt;<span class=\"keyword\">String</span>&gt; <span class=\"built_in\">key</span> = <span class=\"built_in\">map</span>.keySet();</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">String</span> <span class=\"built_in\">str</span>: <span class=\"built_in\">key</span>)</div><div class=\"line\">    <span class=\"built_in\">map</span>.<span class=\"built_in\">get</span>(<span class=\"built_in\">str</span>);</div></pre></td></tr></table></figure></p>\n<h4 id=\"二、遍历values，直接得到value。\"><a href=\"#二、遍历values，直接得到value。\" class=\"headerlink\" title=\"二、遍历values，直接得到value。\"></a>二、遍历values，直接得到value。</h4><p>（1）利用iterator遍历<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">HashMap</span>&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt; <span class=\"built_in\">map</span> = <span class=\"keyword\">new</span> <span class=\"keyword\">HashMap</span>&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt;();</div><div class=\"line\">Iterator&lt;<span class=\"keyword\">String</span>&gt; iterator = <span class=\"built_in\">map</span>.values().iterator();</div><div class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext())</div><div class=\"line\">    iterator.next();</div></pre></td></tr></table></figure></p>\n<p>（2）利用foreach遍历<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">HashMap</span>&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt; <span class=\"built_in\">map</span> = <span class=\"keyword\">new</span> <span class=\"keyword\">HashMap</span>&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt;();</div><div class=\"line\">Collection&lt;<span class=\"keyword\">String</span>&gt; value = <span class=\"built_in\">map</span>.values();</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">String</span> <span class=\"built_in\">str</span>: value);</div></pre></td></tr></table></figure></p>\n<h4 id=\"三、遍历entrySet-再分别用getKey和getValue得到key、value。\"><a href=\"#三、遍历entrySet-再分别用getKey和getValue得到key、value。\" class=\"headerlink\" title=\"三、遍历entrySet ,再分别用getKey和getValue得到key、value。\"></a>三、遍历entrySet ,再分别用getKey和getValue得到key、value。</h4><p>（1）利用iterator遍历<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">HashMap</span>&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt; <span class=\"built_in\">map</span> = <span class=\"keyword\">new</span> <span class=\"keyword\">HashMap</span>&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt;();</div><div class=\"line\">Iterator&lt;Map.Entry&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt;&gt; iterator = <span class=\"built_in\">map</span>.entrySet().iterator();</div><div class=\"line\"><span class=\"keyword\">while</span>(iterator.hasNext())&#123;</div><div class=\"line\">    iterator.next().getKey();</div><div class=\"line\">    iterator.next().getValue();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>（2）利用foreach遍历<br><figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">HashMap&lt;<span class=\"built_in\">String</span>,<span class=\"built_in\">String</span>&gt; <span class=\"built_in\">map</span> = <span class=\"literal\">new</span> HashMap&lt;<span class=\"built_in\">String</span>,<span class=\"built_in\">String</span>&gt;();</div><div class=\"line\"><span class=\"built_in\">Set</span>&lt;<span class=\"built_in\">Map</span>.Entry&lt;<span class=\"built_in\">String</span>,<span class=\"built_in\">String</span>&gt;&gt; entry = <span class=\"built_in\">map</span>.entrySet();</div><div class=\"line\">for(<span class=\"built_in\">Map</span>.Entry&lt;<span class=\"built_in\">String</span>,<span class=\"built_in\">String</span>&gt; en: entry)&#123;</div><div class=\"line\">     en.getKey();</div><div class=\"line\">     en.getValue();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"四、不同遍历方式下的时间性能比较（这里设定HashMap大小为1000000）\"><a href=\"#四、不同遍历方式下的时间性能比较（这里设定HashMap大小为1000000）\" class=\"headerlink\" title=\"四、不同遍历方式下的时间性能比较（这里设定HashMap大小为1000000）\"></a>四、不同遍历方式下的时间性能比较（这里设定HashMap大小为1000000）</h4><table>\n<thead>\n<tr>\n<th>遍历方式</th>\n<th>所需时间(ms)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>iterator遍历keySet</td>\n<td>59</td>\n</tr>\n<tr>\n<td>iterator遍历values</td>\n<td>28</td>\n</tr>\n<tr>\n<td>iterator遍历entrySet</td>\n<td>32</td>\n</tr>\n<tr>\n<td>foreach遍历keySet</td>\n<td>40</td>\n</tr>\n<tr>\n<td>foreach遍历values</td>\n<td>26</td>\n</tr>\n<tr>\n<td>foreach遍历entrySet</td>\n<td>29</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"五、-总结\"><a href=\"#五、-总结\" class=\"headerlink\" title=\"五、 总结\"></a>五、 总结</h4><p>从结果可以看出：</p>\n<ol>\n<li>利用foreach语句遍历普遍比iterator所需的时间少。</li>\n<li>直接遍历values所需的时间最少。</li>\n<li>遍历keySet所需的时间最多。原因是除了遍历keySet，我们还需要用get方法得到每一个key的value。get方法通过计算key的hash值找到对应的value，增加了遍历的时间。</li>\n</ol>\n<h4 id=\"六、-代码\"><a href=\"#六、-代码\" class=\"headerlink\" title=\"六、 代码\"></a>六、 代码</h4><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> test1() &#123;</div><div class=\"line\">    <span class=\"comment\">//准备数据</span></div><div class=\"line\">    Map&lt;<span class=\"keyword\">String</span>, <span class=\"keyword\">String</span>&gt; <span class=\"built_in\">map</span> = <span class=\"keyword\">new</span> <span class=\"keyword\">HashMap</span>&lt;<span class=\"keyword\">String</span>, <span class=\"keyword\">String</span>&gt;();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000000</span>; i++) &#123;</div><div class=\"line\">        <span class=\"built_in\">map</span>.put(<span class=\"string\">\"a\"</span> + i, <span class=\"string\">\"a\"</span> + i);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">String</span> temp;</div><div class=\"line\">    <span class=\"comment\">// 分别计算10次</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> c = <span class=\"number\">0</span>; c &lt; <span class=\"number\">10</span>; c++) &#123;</div><div class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</div><div class=\"line\">        Iterator&lt;<span class=\"keyword\">String</span>&gt; iterator1 = <span class=\"built_in\">map</span>.keySet().iterator();</div><div class=\"line\">        <span class=\"keyword\">while</span> (iterator1.hasNext())&#123;</div><div class=\"line\">            temp = <span class=\"built_in\">map</span>.<span class=\"built_in\">get</span>(iterator1.next());</div><div class=\"line\">        &#125;</div><div class=\"line\">        System.out.<span class=\"built_in\">print</span>(<span class=\"string\">\"KeySet-&gt;iterator-&gt;getKey：\"</span> + (System.currentTimeMillis() - start) + <span class=\"string\">\"  ms, \"</span>);</div><div class=\"line\"></div><div class=\"line\">        start = System.currentTimeMillis();</div><div class=\"line\">        Set&lt;<span class=\"keyword\">String</span>&gt; <span class=\"built_in\">key</span> = <span class=\"built_in\">map</span>.keySet();</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">String</span> <span class=\"built_in\">str</span>: <span class=\"built_in\">key</span>)</div><div class=\"line\">            temp =  <span class=\"built_in\">map</span>.<span class=\"built_in\">get</span>(<span class=\"built_in\">str</span>);</div><div class=\"line\">        System.out.<span class=\"built_in\">print</span>(<span class=\"string\">\"KeySet-&gt;for-&gt;getKey：\"</span> + (System.currentTimeMillis() - start) + <span class=\"string\">\"  ms, \"</span>);</div><div class=\"line\"></div><div class=\"line\">        start = System.currentTimeMillis();</div><div class=\"line\">        Iterator&lt;<span class=\"keyword\">String</span>&gt; iterator2 = <span class=\"built_in\">map</span>.values().iterator();</div><div class=\"line\">        <span class=\"keyword\">while</span> (iterator2.hasNext())</div><div class=\"line\">            temp = iterator2.next();</div><div class=\"line\">        System.out.<span class=\"built_in\">print</span>(<span class=\"string\">\"values-&gt;iterator：\"</span> + (System.currentTimeMillis() - start) + <span class=\"string\">\"  ms, \"</span>);</div><div class=\"line\"></div><div class=\"line\">        start = System.currentTimeMillis();</div><div class=\"line\">        Collection&lt;<span class=\"keyword\">String</span>&gt; value = <span class=\"built_in\">map</span>.values();</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">String</span> <span class=\"built_in\">str</span>: value)</div><div class=\"line\">            temp = <span class=\"built_in\">str</span>;</div><div class=\"line\">        System.out.<span class=\"built_in\">print</span>(<span class=\"string\">\"values-&gt;for：\"</span> + (System.currentTimeMillis() - start) + <span class=\"string\">\"  ms, \"</span>);</div><div class=\"line\"></div><div class=\"line\">        start = System.currentTimeMillis();</div><div class=\"line\">        Iterator&lt;Map.Entry&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt;&gt; iterator3 = <span class=\"built_in\">map</span>.entrySet().iterator();</div><div class=\"line\">        <span class=\"keyword\">while</span>(iterator3.hasNext())&#123;</div><div class=\"line\">            temp = iterator3.next().getValue();</div><div class=\"line\">        &#125;</div><div class=\"line\">        System.out.<span class=\"built_in\">print</span>(<span class=\"string\">\"entrySet-&gt;iterator-&gt;getKey：\"</span> + (System.currentTimeMillis() - start) + <span class=\"string\">\"  ms, \"</span>);</div><div class=\"line\"></div><div class=\"line\">        start = System.currentTimeMillis();</div><div class=\"line\">        Set&lt;Map.Entry&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt;&gt; entry = <span class=\"built_in\">map</span>.entrySet();</div><div class=\"line\">        <span class=\"keyword\">for</span>(Map.Entry&lt;<span class=\"keyword\">String</span>,<span class=\"keyword\">String</span>&gt; en: entry)&#123;</div><div class=\"line\">            temp = en.getValue();</div><div class=\"line\">        &#125;</div><div class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"entrySet-&gt;for-&gt;getKey：\"</span> + (System.currentTimeMillis() - start) + <span class=\"string\">\"  ms\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果:<br><figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">K<span class=\"function\"><span class=\"title\">eySet</span>-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：55  ms, KeySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：58  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>：29  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">for</span>：25  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：26  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span>getKey：<span class=\"number\">26</span>  ms</div><div class=\"line\">K<span class=\"function\"><span class=\"title\">eySet</span>-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：39  ms, KeySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：52  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>：63  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">for</span>：29  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：19  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span>getKey：<span class=\"number\">19</span>  ms</div><div class=\"line\">K<span class=\"function\"><span class=\"title\">eySet</span>-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：42  ms, KeySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：34  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>：22  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">for</span>：20  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：20  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span>getKey：<span class=\"number\">21</span>  ms</div><div class=\"line\">K<span class=\"function\"><span class=\"title\">eySet</span>-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：33  ms, KeySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：29  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>：23  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">for</span>：32  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：24  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span>getKey：<span class=\"number\">20</span>  ms</div><div class=\"line\">K<span class=\"function\"><span class=\"title\">eySet</span>-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：35  ms, KeySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：30  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>：22  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">for</span>：20  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：34  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span>getKey：<span class=\"number\">22</span>  ms</div><div class=\"line\">K<span class=\"function\"><span class=\"title\">eySet</span>-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：51  ms, KeySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：28  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>：21  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">for</span>：20  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：22  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span>getKey：<span class=\"number\">21</span>  ms</div><div class=\"line\">K<span class=\"function\"><span class=\"title\">eySet</span>-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：37  ms, KeySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：45  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>：24  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">for</span>：21  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：22  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span>getKey：<span class=\"number\">21</span>  ms</div><div class=\"line\">K<span class=\"function\"><span class=\"title\">eySet</span>-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：40  ms, KeySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：33  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>：21  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">for</span>：22  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：45  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span>getKey：<span class=\"number\">24</span>  ms</div><div class=\"line\">K<span class=\"function\"><span class=\"title\">eySet</span>-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：40  ms, KeySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：33  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>：21  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">for</span>：21  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：20  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span>getKey：<span class=\"number\">34</span>  ms</div><div class=\"line\">K<span class=\"function\"><span class=\"title\">eySet</span>-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：39  ms, KeySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：33  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>：22  ms, values-&gt;</span><span class=\"function\"><span class=\"title\">for</span>：19  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">iterator</span>-&gt;</span><span class=\"function\"><span class=\"title\">getKey</span>：19  ms, entrySet-&gt;</span><span class=\"function\"><span class=\"title\">for</span>-&gt;</span>getKey：<span class=\"number\">22</span>  ms</div></pre></td></tr></table></figure></p>"},{"title":"HashMap的循环方式性能对比","date":"2017-02-10T03:11:11.000Z","toc":true,"_content":"前段时间在代码重构时候发现有几部分貌似有问题的代码，摘录出来分析一下。\n<!--more-->\n### 一、缘由\n代码重构过程中发现许多这样的代码:\n```\nfor (Movie movie : showMap.keySet()) {\n    List<ShowModel> models = showMap.get(movie);\n    if (CollectionUtils.isEmpty(models)) {\n    .............\n}\n```\n### 二、两种循环方式的实测数据\n```\npackage com.meng.Jason.collections;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Created by MengDexin.\n * Date : 17/7/19.\n * Time : 17:53.\n */\npublic class MapTest {\n\n    public static void main(String[] args) {\n        test();\n    }\n\n    public static void test() {\n        //准备数据\n        Map<String, String> map = new HashMap<String, String>();\n        for (int i = 0; i < 10000; i++) {\n            map.put(\"a\" + i, \"a\" + i);\n        }\n\n        for (int c = 0; c < 10; c++) {\n            //循环方式\n            long start = System.currentTimeMillis();\n            int count = 100, n = 0;\n            while (n < count) {\n                for (Map.Entry<String, String> entry : map.entrySet()) {\n                    String value = entry.getValue();\n                }\n                ++n;\n            }\n            System.out.print(\"方式一：\" + (System.currentTimeMillis() - start) + \"  ms, \");\n\n            start = System.currentTimeMillis();\n            n = 0;\n            while (n < count) {\n                for (String key : map.keySet()) {\n                    String value = map.get(key);\n                }\n                ++n;\n            }\n\n            System.out.println(\"方式二：\" + (System.currentTimeMillis() - start) + \" ms\");\n        }\n    }\n}\n```\n结果:\n```\n方式一：24  ms, 方式二：42 ms\n方式一：11  ms, 方式二：18 ms\n方式一：14  ms, 方式二：17 ms\n方式一：12  ms, 方式二：18 ms\n方式一：10  ms, 方式二：19 ms\n方式一：12  ms, 方式二：18 ms\n方式一：11  ms, 方式二：24 ms\n方式一：10  ms, 方式二：18 ms\n方式一：11  ms, 方式二：19 ms\n方式一：10  ms, 方式二：18 ms\n```\n### 三、原理分析\n基于以上的测试，可以得出结论:\n* 第一种循环Map的方式效率要比第二种高不少。\n\n下面分析一下这两种循环方式的源码得出性能差异的原因:\n原因一： 方式一 map.entrySet() 的效率比方式二 map.keySet() 高，map.keySet() 比map.entrySet() 多了一次请求\n```\nprivate final class KeyIterator extends HashIterator<K> {\n     public K next() {\n         return nextEntry().getKey();\n     }\n }\n```\n而  方法nextEntry() 里面有如下while循环：\n```\nfinal Entry<K,V> nextEntry() {\n    if (modCount != expectedModCount)\n        throw new ConcurrentModificationException();\n    Entry<K,V> e = next;\n    if (e == null)\n        throw new NoSuchElementException();\n    if ((next = e.next) == null) {\n        Entry[] t = table;\n        while (index < t.length && (next = t[index++]) == null)\n            ;\n    }\n    current = e;\n    return e;\n}\n```\n原因二：方式一 中Map.Entry 中已经有了key以及value，但是方式二中还需要根据key调用map.getKey() 去获取对应的value，map.getKey()里面存在这样一段代码：\n```\n/**\n  * Returns the entry associated with the specified key in the\n  * HashMap.  Returns null if the HashMap contains no mapping\n  * for the key.\n  */\n final Entry<K,V> getEntry(Object key) {\n     if (size == 0) {\n         return null;\n     }\n     int hash = (key == null) ? 0 : hash(key);\n     for (Entry<K,V> e = table[indexFor(hash, table.length)];\n          e != null;\n          e = e.next) {\n         Object k;\n         if (e.hash == hash &&\n             ((k = e.key) == key || (key != null && key.equals(k))))\n             return e;\n     }\n     return null;\n }\n```\n此处存在一个for循环，当hashCode值分布较好无冲突的时候，这个for循环只需要循环一次，但是当map中的hashCode冲突较大的时候，这个for循环会运行多次，造成性能损耗,所以，结论是第一种循环取值操作效率要高，在应用中，推荐尽量使用第一种方式进行HashMap的循环取值操作","source":"_posts/3HashMap的循环方式性能对比.md","raw":"---\ntitle: HashMap的循环方式性能对比\ndate: 2017-02-10 11:11:11\ntags: Java 对比\ncategories: \"Java\"\ntoc: true\n---\n前段时间在代码重构时候发现有几部分貌似有问题的代码，摘录出来分析一下。\n<!--more-->\n### 一、缘由\n代码重构过程中发现许多这样的代码:\n```\nfor (Movie movie : showMap.keySet()) {\n    List<ShowModel> models = showMap.get(movie);\n    if (CollectionUtils.isEmpty(models)) {\n    .............\n}\n```\n### 二、两种循环方式的实测数据\n```\npackage com.meng.Jason.collections;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Created by MengDexin.\n * Date : 17/7/19.\n * Time : 17:53.\n */\npublic class MapTest {\n\n    public static void main(String[] args) {\n        test();\n    }\n\n    public static void test() {\n        //准备数据\n        Map<String, String> map = new HashMap<String, String>();\n        for (int i = 0; i < 10000; i++) {\n            map.put(\"a\" + i, \"a\" + i);\n        }\n\n        for (int c = 0; c < 10; c++) {\n            //循环方式\n            long start = System.currentTimeMillis();\n            int count = 100, n = 0;\n            while (n < count) {\n                for (Map.Entry<String, String> entry : map.entrySet()) {\n                    String value = entry.getValue();\n                }\n                ++n;\n            }\n            System.out.print(\"方式一：\" + (System.currentTimeMillis() - start) + \"  ms, \");\n\n            start = System.currentTimeMillis();\n            n = 0;\n            while (n < count) {\n                for (String key : map.keySet()) {\n                    String value = map.get(key);\n                }\n                ++n;\n            }\n\n            System.out.println(\"方式二：\" + (System.currentTimeMillis() - start) + \" ms\");\n        }\n    }\n}\n```\n结果:\n```\n方式一：24  ms, 方式二：42 ms\n方式一：11  ms, 方式二：18 ms\n方式一：14  ms, 方式二：17 ms\n方式一：12  ms, 方式二：18 ms\n方式一：10  ms, 方式二：19 ms\n方式一：12  ms, 方式二：18 ms\n方式一：11  ms, 方式二：24 ms\n方式一：10  ms, 方式二：18 ms\n方式一：11  ms, 方式二：19 ms\n方式一：10  ms, 方式二：18 ms\n```\n### 三、原理分析\n基于以上的测试，可以得出结论:\n* 第一种循环Map的方式效率要比第二种高不少。\n\n下面分析一下这两种循环方式的源码得出性能差异的原因:\n原因一： 方式一 map.entrySet() 的效率比方式二 map.keySet() 高，map.keySet() 比map.entrySet() 多了一次请求\n```\nprivate final class KeyIterator extends HashIterator<K> {\n     public K next() {\n         return nextEntry().getKey();\n     }\n }\n```\n而  方法nextEntry() 里面有如下while循环：\n```\nfinal Entry<K,V> nextEntry() {\n    if (modCount != expectedModCount)\n        throw new ConcurrentModificationException();\n    Entry<K,V> e = next;\n    if (e == null)\n        throw new NoSuchElementException();\n    if ((next = e.next) == null) {\n        Entry[] t = table;\n        while (index < t.length && (next = t[index++]) == null)\n            ;\n    }\n    current = e;\n    return e;\n}\n```\n原因二：方式一 中Map.Entry 中已经有了key以及value，但是方式二中还需要根据key调用map.getKey() 去获取对应的value，map.getKey()里面存在这样一段代码：\n```\n/**\n  * Returns the entry associated with the specified key in the\n  * HashMap.  Returns null if the HashMap contains no mapping\n  * for the key.\n  */\n final Entry<K,V> getEntry(Object key) {\n     if (size == 0) {\n         return null;\n     }\n     int hash = (key == null) ? 0 : hash(key);\n     for (Entry<K,V> e = table[indexFor(hash, table.length)];\n          e != null;\n          e = e.next) {\n         Object k;\n         if (e.hash == hash &&\n             ((k = e.key) == key || (key != null && key.equals(k))))\n             return e;\n     }\n     return null;\n }\n```\n此处存在一个for循环，当hashCode值分布较好无冲突的时候，这个for循环只需要循环一次，但是当map中的hashCode冲突较大的时候，这个for循环会运行多次，造成性能损耗,所以，结论是第一种循环取值操作效率要高，在应用中，推荐尽量使用第一种方式进行HashMap的循环取值操作","slug":"3HashMap的循环方式性能对比","published":1,"updated":"2018-11-28T09:25:04.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tcau0028a7xwymk59ul4","content":"<p>前段时间在代码重构时候发现有几部分貌似有问题的代码，摘录出来分析一下。<br><a id=\"more\"></a></p>\n<h3 id=\"一、缘由\"><a href=\"#一、缘由\" class=\"headerlink\" title=\"一、缘由\"></a>一、缘由</h3><p>代码重构过程中发现许多这样的代码:<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (Movie movie : showMap.keySet()) &#123;</div><div class=\"line\">    List&lt;ShowModel&gt; models = showMap.get(movie);</div><div class=\"line\">    <span class=\"keyword\">if</span> (CollectionUtils.isEmpty(models)) &#123;</div><div class=\"line\">    .............</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"二、两种循环方式的实测数据\"><a href=\"#二、两种循环方式的实测数据\" class=\"headerlink\" title=\"二、两种循环方式的实测数据\"></a>二、两种循环方式的实测数据</h3><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.meng.Jason.collections;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.util.<span class=\"keyword\">HashMap</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Created by MengDexin.</div><div class=\"line\"> * Date : 17/7/19.</div><div class=\"line\"> * Time : 17:53.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> class MapTest &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(<span class=\"keyword\">String</span>[] args) &#123;</div><div class=\"line\">        test();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> test() &#123;</div><div class=\"line\">        <span class=\"comment\">//准备数据</span></div><div class=\"line\">        Map&lt;<span class=\"keyword\">String</span>, <span class=\"keyword\">String</span>&gt; <span class=\"built_in\">map</span> = <span class=\"keyword\">new</span> <span class=\"keyword\">HashMap</span>&lt;<span class=\"keyword\">String</span>, <span class=\"keyword\">String</span>&gt;();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">map</span>.put(<span class=\"string\">\"a\"</span> + i, <span class=\"string\">\"a\"</span> + i);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> c = <span class=\"number\">0</span>; c &lt; <span class=\"number\">10</span>; c++) &#123;</div><div class=\"line\">            <span class=\"comment\">//循环方式</span></div><div class=\"line\">            <span class=\"keyword\">long</span> start = System.currentTimeMillis();</div><div class=\"line\">            <span class=\"built_in\">int</span> count = <span class=\"number\">100</span>, n = <span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"keyword\">while</span> (n &lt; count) &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (Map.Entry&lt;<span class=\"keyword\">String</span>, <span class=\"keyword\">String</span>&gt; entry : <span class=\"built_in\">map</span>.entrySet()) &#123;</div><div class=\"line\">                    <span class=\"keyword\">String</span> value = entry.getValue();</div><div class=\"line\">                &#125;</div><div class=\"line\">                ++n;</div><div class=\"line\">            &#125;</div><div class=\"line\">            System.out.<span class=\"built_in\">print</span>(<span class=\"string\">\"方式一：\"</span> + (System.currentTimeMillis() - start) + <span class=\"string\">\"  ms, \"</span>);</div><div class=\"line\"></div><div class=\"line\">            start = System.currentTimeMillis();</div><div class=\"line\">            n = <span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"keyword\">while</span> (n &lt; count) &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">String</span> <span class=\"built_in\">key</span> : <span class=\"built_in\">map</span>.keySet()) &#123;</div><div class=\"line\">                    <span class=\"keyword\">String</span> value = <span class=\"built_in\">map</span>.<span class=\"built_in\">get</span>(<span class=\"built_in\">key</span>);</div><div class=\"line\">                &#125;</div><div class=\"line\">                ++n;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"方式二：\"</span> + (System.currentTimeMillis() - start) + <span class=\"string\">\" ms\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果:<br><figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">方式一：<span class=\"number\">24</span>  ms, 方式二：<span class=\"number\">42</span> <span class=\"keyword\">ms</span></div><div class=\"line\"><span class=\"title\">方式一：11</span>  ms, 方式二：<span class=\"number\">18</span> <span class=\"keyword\">ms</span></div><div class=\"line\"><span class=\"title\">方式一：14</span>  ms, 方式二：<span class=\"number\">17</span> <span class=\"keyword\">ms</span></div><div class=\"line\"><span class=\"title\">方式一：12</span>  ms, 方式二：<span class=\"number\">18</span> <span class=\"keyword\">ms</span></div><div class=\"line\"><span class=\"title\">方式一：10</span>  ms, 方式二：<span class=\"number\">19</span> <span class=\"keyword\">ms</span></div><div class=\"line\"><span class=\"title\">方式一：12</span>  ms, 方式二：<span class=\"number\">18</span> <span class=\"keyword\">ms</span></div><div class=\"line\"><span class=\"title\">方式一：11</span>  ms, 方式二：<span class=\"number\">24</span> <span class=\"keyword\">ms</span></div><div class=\"line\"><span class=\"title\">方式一：10</span>  ms, 方式二：<span class=\"number\">18</span> <span class=\"keyword\">ms</span></div><div class=\"line\"><span class=\"title\">方式一：11</span>  ms, 方式二：<span class=\"number\">19</span> <span class=\"keyword\">ms</span></div><div class=\"line\"><span class=\"title\">方式一：10</span>  ms, 方式二：<span class=\"number\">18</span> ms</div></pre></td></tr></table></figure></p>\n<h3 id=\"三、原理分析\"><a href=\"#三、原理分析\" class=\"headerlink\" title=\"三、原理分析\"></a>三、原理分析</h3><p>基于以上的测试，可以得出结论:</p>\n<ul>\n<li>第一种循环Map的方式效率要比第二种高不少。</li>\n</ul>\n<p>下面分析一下这两种循环方式的源码得出性能差异的原因:<br>原因一： 方式一 map.entrySet() 的效率比方式二 map.keySet() 高，map.keySet() 比map.entrySet() 多了一次请求<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KeyIterator</span> <span class=\"keyword\">extends</span> <span class=\"title\">HashIterator&lt;K&gt;</span> </span>&#123;</div><div class=\"line\">     public <span class=\"type\">K</span> next() &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> nextEntry().getKey();</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>而  方法nextEntry() 里面有如下while循环：<br><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> Entry&lt;K,V&gt; nextEntry() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (modCount != expectedModCount)</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</div><div class=\"line\">    Entry&lt;K,V&gt; e = <span class=\"keyword\">next</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>)</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</div><div class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"keyword\">next</span> = e.<span class=\"keyword\">next</span>) == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        Entry[] t = table;</div><div class=\"line\">        <span class=\"keyword\">while</span> (index &lt; t.length &amp;&amp; (<span class=\"keyword\">next</span> = t[index++]) == <span class=\"keyword\">null</span>)</div><div class=\"line\">            ;</div><div class=\"line\">    &#125;</div><div class=\"line\">    current = e;</div><div class=\"line\">    <span class=\"keyword\">return</span> e;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>原因二：方式一 中Map.Entry 中已经有了key以及value，但是方式二中还需要根据key调用map.getKey() 去获取对应的value，map.getKey()里面存在这样一段代码：<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">  * Returns the entry associated with the specified key in the</div><div class=\"line\">  * HashMap.  Returns null if the HashMap contains no mapping</div><div class=\"line\">  * for the key.</div><div class=\"line\">  */</div><div class=\"line\"> <span class=\"keyword\">final</span> Entry&lt;K,V&gt; getEntry(<span class=\"keyword\">Object</span> <span class=\"built_in\">key</span>) &#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (<span class=\"built_in\">size</span> == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"built_in\">int</span> hash = (<span class=\"built_in\">key</span> == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : hash(<span class=\"built_in\">key</span>);</div><div class=\"line\">     <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</div><div class=\"line\">          e != <span class=\"keyword\">null</span>;</div><div class=\"line\">          e = e.next) &#123;</div><div class=\"line\">         <span class=\"keyword\">Object</span> k;</div><div class=\"line\">         <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</div><div class=\"line\">             ((k = e.<span class=\"built_in\">key</span>) == <span class=\"built_in\">key</span> || (<span class=\"built_in\">key</span> != <span class=\"keyword\">null</span> &amp;&amp; <span class=\"built_in\">key</span>.equals(k))))</div><div class=\"line\">             <span class=\"keyword\">return</span> e;</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>此处存在一个for循环，当hashCode值分布较好无冲突的时候，这个for循环只需要循环一次，但是当map中的hashCode冲突较大的时候，这个for循环会运行多次，造成性能损耗,所以，结论是第一种循环取值操作效率要高，在应用中，推荐尽量使用第一种方式进行HashMap的循环取值操作</p>\n","excerpt":"<p>前段时间在代码重构时候发现有几部分貌似有问题的代码，摘录出来分析一下。<br></p>","more":"<p></p>\n<h3 id=\"一、缘由\"><a href=\"#一、缘由\" class=\"headerlink\" title=\"一、缘由\"></a>一、缘由</h3><p>代码重构过程中发现许多这样的代码:<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (Movie movie : showMap.keySet()) &#123;</div><div class=\"line\">    List&lt;ShowModel&gt; models = showMap.get(movie);</div><div class=\"line\">    <span class=\"keyword\">if</span> (CollectionUtils.isEmpty(models)) &#123;</div><div class=\"line\">    .............</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"二、两种循环方式的实测数据\"><a href=\"#二、两种循环方式的实测数据\" class=\"headerlink\" title=\"二、两种循环方式的实测数据\"></a>二、两种循环方式的实测数据</h3><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.meng.Jason.collections;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.util.<span class=\"keyword\">HashMap</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Created by MengDexin.</div><div class=\"line\"> * Date : 17/7/19.</div><div class=\"line\"> * Time : 17:53.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> class MapTest &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(<span class=\"keyword\">String</span>[] args) &#123;</div><div class=\"line\">        test();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> test() &#123;</div><div class=\"line\">        <span class=\"comment\">//准备数据</span></div><div class=\"line\">        Map&lt;<span class=\"keyword\">String</span>, <span class=\"keyword\">String</span>&gt; <span class=\"built_in\">map</span> = <span class=\"keyword\">new</span> <span class=\"keyword\">HashMap</span>&lt;<span class=\"keyword\">String</span>, <span class=\"keyword\">String</span>&gt;();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</div><div class=\"line\">            <span class=\"built_in\">map</span>.put(<span class=\"string\">\"a\"</span> + i, <span class=\"string\">\"a\"</span> + i);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> c = <span class=\"number\">0</span>; c &lt; <span class=\"number\">10</span>; c++) &#123;</div><div class=\"line\">            <span class=\"comment\">//循环方式</span></div><div class=\"line\">            <span class=\"keyword\">long</span> start = System.currentTimeMillis();</div><div class=\"line\">            <span class=\"built_in\">int</span> count = <span class=\"number\">100</span>, n = <span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"keyword\">while</span> (n &lt; count) &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (Map.Entry&lt;<span class=\"keyword\">String</span>, <span class=\"keyword\">String</span>&gt; entry : <span class=\"built_in\">map</span>.entrySet()) &#123;</div><div class=\"line\">                    <span class=\"keyword\">String</span> value = entry.getValue();</div><div class=\"line\">                &#125;</div><div class=\"line\">                ++n;</div><div class=\"line\">            &#125;</div><div class=\"line\">            System.out.<span class=\"built_in\">print</span>(<span class=\"string\">\"方式一：\"</span> + (System.currentTimeMillis() - start) + <span class=\"string\">\"  ms, \"</span>);</div><div class=\"line\"></div><div class=\"line\">            start = System.currentTimeMillis();</div><div class=\"line\">            n = <span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"keyword\">while</span> (n &lt; count) &#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">String</span> <span class=\"built_in\">key</span> : <span class=\"built_in\">map</span>.keySet()) &#123;</div><div class=\"line\">                    <span class=\"keyword\">String</span> value = <span class=\"built_in\">map</span>.<span class=\"built_in\">get</span>(<span class=\"built_in\">key</span>);</div><div class=\"line\">                &#125;</div><div class=\"line\">                ++n;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"方式二：\"</span> + (System.currentTimeMillis() - start) + <span class=\"string\">\" ms\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果:<br><figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">方式一：<span class=\"number\">24</span>  ms, 方式二：<span class=\"number\">42</span> <span class=\"keyword\">ms</span></div><div class=\"line\"><span class=\"title\">方式一：11</span>  ms, 方式二：<span class=\"number\">18</span> <span class=\"keyword\">ms</span></div><div class=\"line\"><span class=\"title\">方式一：14</span>  ms, 方式二：<span class=\"number\">17</span> <span class=\"keyword\">ms</span></div><div class=\"line\"><span class=\"title\">方式一：12</span>  ms, 方式二：<span class=\"number\">18</span> <span class=\"keyword\">ms</span></div><div class=\"line\"><span class=\"title\">方式一：10</span>  ms, 方式二：<span class=\"number\">19</span> <span class=\"keyword\">ms</span></div><div class=\"line\"><span class=\"title\">方式一：12</span>  ms, 方式二：<span class=\"number\">18</span> <span class=\"keyword\">ms</span></div><div class=\"line\"><span class=\"title\">方式一：11</span>  ms, 方式二：<span class=\"number\">24</span> <span class=\"keyword\">ms</span></div><div class=\"line\"><span class=\"title\">方式一：10</span>  ms, 方式二：<span class=\"number\">18</span> <span class=\"keyword\">ms</span></div><div class=\"line\"><span class=\"title\">方式一：11</span>  ms, 方式二：<span class=\"number\">19</span> <span class=\"keyword\">ms</span></div><div class=\"line\"><span class=\"title\">方式一：10</span>  ms, 方式二：<span class=\"number\">18</span> ms</div></pre></td></tr></table></figure></p>\n<h3 id=\"三、原理分析\"><a href=\"#三、原理分析\" class=\"headerlink\" title=\"三、原理分析\"></a>三、原理分析</h3><p>基于以上的测试，可以得出结论:</p>\n<ul>\n<li>第一种循环Map的方式效率要比第二种高不少。</li>\n</ul>\n<p>下面分析一下这两种循环方式的源码得出性能差异的原因:<br>原因一： 方式一 map.entrySet() 的效率比方式二 map.keySet() 高，map.keySet() 比map.entrySet() 多了一次请求<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KeyIterator</span> <span class=\"keyword\">extends</span> <span class=\"title\">HashIterator&lt;K&gt;</span> </span>&#123;</div><div class=\"line\">     public <span class=\"type\">K</span> next() &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> nextEntry().getKey();</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>而  方法nextEntry() 里面有如下while循环：<br><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> Entry&lt;K,V&gt; nextEntry() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (modCount != expectedModCount)</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</div><div class=\"line\">    Entry&lt;K,V&gt; e = <span class=\"keyword\">next</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>)</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</div><div class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"keyword\">next</span> = e.<span class=\"keyword\">next</span>) == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        Entry[] t = table;</div><div class=\"line\">        <span class=\"keyword\">while</span> (index &lt; t.length &amp;&amp; (<span class=\"keyword\">next</span> = t[index++]) == <span class=\"keyword\">null</span>)</div><div class=\"line\">            ;</div><div class=\"line\">    &#125;</div><div class=\"line\">    current = e;</div><div class=\"line\">    <span class=\"keyword\">return</span> e;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>原因二：方式一 中Map.Entry 中已经有了key以及value，但是方式二中还需要根据key调用map.getKey() 去获取对应的value，map.getKey()里面存在这样一段代码：<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">  * Returns the entry associated with the specified key in the</div><div class=\"line\">  * HashMap.  Returns null if the HashMap contains no mapping</div><div class=\"line\">  * for the key.</div><div class=\"line\">  */</div><div class=\"line\"> <span class=\"keyword\">final</span> Entry&lt;K,V&gt; getEntry(<span class=\"keyword\">Object</span> <span class=\"built_in\">key</span>) &#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (<span class=\"built_in\">size</span> == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"built_in\">int</span> hash = (<span class=\"built_in\">key</span> == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : hash(<span class=\"built_in\">key</span>);</div><div class=\"line\">     <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</div><div class=\"line\">          e != <span class=\"keyword\">null</span>;</div><div class=\"line\">          e = e.next) &#123;</div><div class=\"line\">         <span class=\"keyword\">Object</span> k;</div><div class=\"line\">         <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</div><div class=\"line\">             ((k = e.<span class=\"built_in\">key</span>) == <span class=\"built_in\">key</span> || (<span class=\"built_in\">key</span> != <span class=\"keyword\">null</span> &amp;&amp; <span class=\"built_in\">key</span>.equals(k))))</div><div class=\"line\">             <span class=\"keyword\">return</span> e;</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>此处存在一个for循环，当hashCode值分布较好无冲突的时候，这个for循环只需要循环一次，但是当map中的hashCode冲突较大的时候，这个for循环会运行多次，造成性能损耗,所以，结论是第一种循环取值操作效率要高，在应用中，推荐尽量使用第一种方式进行HashMap的循环取值操作</p>"},{"title":"技术框架入门","date":"2017-03-01T08:20:27.000Z","toc":true,"_content":"我这个人有一个很大的缺点,就是特别喜欢总结,把一些东西归类、划分、对比。非要把人家的优劣区分出来才行,但是有时候对技术容易浅尝辄止。这篇文章就是对工作学习中用到的技术分别整理一下。\n<!--more-->\n\n#### 一、语言\n##### 1.1.Java 健壮的大型软件\n##### 1.2.C 操作系统及驱动\n##### 1.3.C++ 需求效率的软件\n##### 1.4.Python 快速开发应用程序\n##### 1.5.Go\n##### 1.6.JVM语言：Scala(Spark)\\Groovy\\Clojure\\Kotlin\n##### 1.7.Ruby\n##### 1.8.参考资料\n- [七周七语言](https://book.douban.com/subject/10555435/)\n\n#### 二、Java IDE（集成开发环境）\n##### 1.1.Eclipse\n##### 1.2.MyEclipse\n##### 1.3.IntellijIDEA jetbrains\n##### 1.4.NetBean\n##### 1.5.参考资料\n- [IDEA对比Eclipse](https://www.zhihu.com/question/29076145)\n\n#### 三、非关系型数据库\n##### 1.1.Redis\n##### 1.2.Memcached\n##### 1.3.MongoDB\n##### 1.4.Tair\n##### 1.5.参考资料\n\n#### 四、关系型数据库\n##### 1.1.MySQL\n##### 1.2.Oracle\n##### 1.3.SqlServer\n\n#### 五、RPC(Remote Procedure Call Protocol)框架\nRPC的主要功能: 目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。\n说得通俗一点就是：调用远程计算机上的服务，就像调用本地服务一样。\n\n##### RMI\n1. JAVA自带的远程方法调用工具，不过有一定的局限性，毕竟是JAVA语言最开始时的设计，后来很多框架的原理都基于RMI;\n\n##### Hessian\n1. 点评将Hessian封装产生了[Pigeon](https://github.com/dianping/pigeon)\n\n##### Thrift\n##### Dubbo\n##### Proto Buffer\n##### Kryo\n##### Jackson\n##### WebService\n\n#### 六、一致性服务\n##### Zookeeper\n1. ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等;\n2. ZooKeeper的名字很有趣, 是为了管理Hadoop生态系统的Pig(猪)、Hive(蜜蜂)、Hbase(海豚)等;\n3. Paxos算法\n\n\n#### 七、实时应用监控平台\n##### Cat (Central Application Tracking)\n1. CAT (Central Application Tracking) 是基于Java开发的实时应用监控平台，为美团点评提供了全面的监控服务和决策支持。\n2. CAT作为美团点评基础监控组件，它已经在中间件框架（MVC框架，RPC框架，数据库框架，缓存框架等）中得到广泛应用，为点评各业务线提供系统的性能指标、健康状况、基础告警等。\n3. CAT作为美团点评移动端基础监控组件，覆盖了美团点评侧几乎所有APP，提供了近实时的多维数据分析，立体式监控功能。\n4. CAT很大的优势是它是一个实时系统，从数据生成到服务端处理结束是秒级别，秒级定义是48分钟40秒，基本上看到48分钟38秒数据，整体报表的统计粒度是分钟级；第二个优势，数据是接近全量统计，目前大约5%的高qps项目是采样统计。\n5. Github: https://github.com/dianping/cat\n\n\n\n\n\n\n","source":"_posts/5技术框架入门.md","raw":"---\ntitle: 技术框架入门\ndate: 2017-03-01 16:20:27\ntags: Markdown\ncategories: \"技术\"\ntoc: true\n---\n我这个人有一个很大的缺点,就是特别喜欢总结,把一些东西归类、划分、对比。非要把人家的优劣区分出来才行,但是有时候对技术容易浅尝辄止。这篇文章就是对工作学习中用到的技术分别整理一下。\n<!--more-->\n\n#### 一、语言\n##### 1.1.Java 健壮的大型软件\n##### 1.2.C 操作系统及驱动\n##### 1.3.C++ 需求效率的软件\n##### 1.4.Python 快速开发应用程序\n##### 1.5.Go\n##### 1.6.JVM语言：Scala(Spark)\\Groovy\\Clojure\\Kotlin\n##### 1.7.Ruby\n##### 1.8.参考资料\n- [七周七语言](https://book.douban.com/subject/10555435/)\n\n#### 二、Java IDE（集成开发环境）\n##### 1.1.Eclipse\n##### 1.2.MyEclipse\n##### 1.3.IntellijIDEA jetbrains\n##### 1.4.NetBean\n##### 1.5.参考资料\n- [IDEA对比Eclipse](https://www.zhihu.com/question/29076145)\n\n#### 三、非关系型数据库\n##### 1.1.Redis\n##### 1.2.Memcached\n##### 1.3.MongoDB\n##### 1.4.Tair\n##### 1.5.参考资料\n\n#### 四、关系型数据库\n##### 1.1.MySQL\n##### 1.2.Oracle\n##### 1.3.SqlServer\n\n#### 五、RPC(Remote Procedure Call Protocol)框架\nRPC的主要功能: 目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。\n说得通俗一点就是：调用远程计算机上的服务，就像调用本地服务一样。\n\n##### RMI\n1. JAVA自带的远程方法调用工具，不过有一定的局限性，毕竟是JAVA语言最开始时的设计，后来很多框架的原理都基于RMI;\n\n##### Hessian\n1. 点评将Hessian封装产生了[Pigeon](https://github.com/dianping/pigeon)\n\n##### Thrift\n##### Dubbo\n##### Proto Buffer\n##### Kryo\n##### Jackson\n##### WebService\n\n#### 六、一致性服务\n##### Zookeeper\n1. ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等;\n2. ZooKeeper的名字很有趣, 是为了管理Hadoop生态系统的Pig(猪)、Hive(蜜蜂)、Hbase(海豚)等;\n3. Paxos算法\n\n\n#### 七、实时应用监控平台\n##### Cat (Central Application Tracking)\n1. CAT (Central Application Tracking) 是基于Java开发的实时应用监控平台，为美团点评提供了全面的监控服务和决策支持。\n2. CAT作为美团点评基础监控组件，它已经在中间件框架（MVC框架，RPC框架，数据库框架，缓存框架等）中得到广泛应用，为点评各业务线提供系统的性能指标、健康状况、基础告警等。\n3. CAT作为美团点评移动端基础监控组件，覆盖了美团点评侧几乎所有APP，提供了近实时的多维数据分析，立体式监控功能。\n4. CAT很大的优势是它是一个实时系统，从数据生成到服务端处理结束是秒级别，秒级定义是48分钟40秒，基本上看到48分钟38秒数据，整体报表的统计粒度是分钟级；第二个优势，数据是接近全量统计，目前大约5%的高qps项目是采样统计。\n5. Github: https://github.com/dianping/cat\n\n\n\n\n\n\n","slug":"5技术框架入门","published":1,"updated":"2018-11-29T02:50:26.821Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tcav002ba7xwfybgdloo","content":"<p>我这个人有一个很大的缺点,就是特别喜欢总结,把一些东西归类、划分、对比。非要把人家的优劣区分出来才行,但是有时候对技术容易浅尝辄止。这篇文章就是对工作学习中用到的技术分别整理一下。<br><a id=\"more\"></a></p>\n<h4 id=\"一、语言\"><a href=\"#一、语言\" class=\"headerlink\" title=\"一、语言\"></a>一、语言</h4><h5 id=\"1-1-Java-健壮的大型软件\"><a href=\"#1-1-Java-健壮的大型软件\" class=\"headerlink\" title=\"1.1.Java 健壮的大型软件\"></a>1.1.Java 健壮的大型软件</h5><h5 id=\"1-2-C-操作系统及驱动\"><a href=\"#1-2-C-操作系统及驱动\" class=\"headerlink\" title=\"1.2.C 操作系统及驱动\"></a>1.2.C 操作系统及驱动</h5><h5 id=\"1-3-C-需求效率的软件\"><a href=\"#1-3-C-需求效率的软件\" class=\"headerlink\" title=\"1.3.C++ 需求效率的软件\"></a>1.3.C++ 需求效率的软件</h5><h5 id=\"1-4-Python-快速开发应用程序\"><a href=\"#1-4-Python-快速开发应用程序\" class=\"headerlink\" title=\"1.4.Python 快速开发应用程序\"></a>1.4.Python 快速开发应用程序</h5><h5 id=\"1-5-Go\"><a href=\"#1-5-Go\" class=\"headerlink\" title=\"1.5.Go\"></a>1.5.Go</h5><h5 id=\"1-6-JVM语言：Scala-Spark-Groovy-Clojure-Kotlin\"><a href=\"#1-6-JVM语言：Scala-Spark-Groovy-Clojure-Kotlin\" class=\"headerlink\" title=\"1.6.JVM语言：Scala(Spark)\\Groovy\\Clojure\\Kotlin\"></a>1.6.JVM语言：Scala(Spark)\\Groovy\\Clojure\\Kotlin</h5><h5 id=\"1-7-Ruby\"><a href=\"#1-7-Ruby\" class=\"headerlink\" title=\"1.7.Ruby\"></a>1.7.Ruby</h5><h5 id=\"1-8-参考资料\"><a href=\"#1-8-参考资料\" class=\"headerlink\" title=\"1.8.参考资料\"></a>1.8.参考资料</h5><ul>\n<li><a href=\"https://book.douban.com/subject/10555435/\" target=\"_blank\" rel=\"external\">七周七语言</a></li>\n</ul>\n<h4 id=\"二、Java-IDE（集成开发环境）\"><a href=\"#二、Java-IDE（集成开发环境）\" class=\"headerlink\" title=\"二、Java IDE（集成开发环境）\"></a>二、Java IDE（集成开发环境）</h4><h5 id=\"1-1-Eclipse\"><a href=\"#1-1-Eclipse\" class=\"headerlink\" title=\"1.1.Eclipse\"></a>1.1.Eclipse</h5><h5 id=\"1-2-MyEclipse\"><a href=\"#1-2-MyEclipse\" class=\"headerlink\" title=\"1.2.MyEclipse\"></a>1.2.MyEclipse</h5><h5 id=\"1-3-IntellijIDEA-jetbrains\"><a href=\"#1-3-IntellijIDEA-jetbrains\" class=\"headerlink\" title=\"1.3.IntellijIDEA jetbrains\"></a>1.3.IntellijIDEA jetbrains</h5><h5 id=\"1-4-NetBean\"><a href=\"#1-4-NetBean\" class=\"headerlink\" title=\"1.4.NetBean\"></a>1.4.NetBean</h5><h5 id=\"1-5-参考资料\"><a href=\"#1-5-参考资料\" class=\"headerlink\" title=\"1.5.参考资料\"></a>1.5.参考资料</h5><ul>\n<li><a href=\"https://www.zhihu.com/question/29076145\" target=\"_blank\" rel=\"external\">IDEA对比Eclipse</a></li>\n</ul>\n<h4 id=\"三、非关系型数据库\"><a href=\"#三、非关系型数据库\" class=\"headerlink\" title=\"三、非关系型数据库\"></a>三、非关系型数据库</h4><h5 id=\"1-1-Redis\"><a href=\"#1-1-Redis\" class=\"headerlink\" title=\"1.1.Redis\"></a>1.1.Redis</h5><h5 id=\"1-2-Memcached\"><a href=\"#1-2-Memcached\" class=\"headerlink\" title=\"1.2.Memcached\"></a>1.2.Memcached</h5><h5 id=\"1-3-MongoDB\"><a href=\"#1-3-MongoDB\" class=\"headerlink\" title=\"1.3.MongoDB\"></a>1.3.MongoDB</h5><h5 id=\"1-4-Tair\"><a href=\"#1-4-Tair\" class=\"headerlink\" title=\"1.4.Tair\"></a>1.4.Tair</h5><h5 id=\"1-5-参考资料-1\"><a href=\"#1-5-参考资料-1\" class=\"headerlink\" title=\"1.5.参考资料\"></a>1.5.参考资料</h5><h4 id=\"四、关系型数据库\"><a href=\"#四、关系型数据库\" class=\"headerlink\" title=\"四、关系型数据库\"></a>四、关系型数据库</h4><h5 id=\"1-1-MySQL\"><a href=\"#1-1-MySQL\" class=\"headerlink\" title=\"1.1.MySQL\"></a>1.1.MySQL</h5><h5 id=\"1-2-Oracle\"><a href=\"#1-2-Oracle\" class=\"headerlink\" title=\"1.2.Oracle\"></a>1.2.Oracle</h5><h5 id=\"1-3-SqlServer\"><a href=\"#1-3-SqlServer\" class=\"headerlink\" title=\"1.3.SqlServer\"></a>1.3.SqlServer</h5><h4 id=\"五、RPC-Remote-Procedure-Call-Protocol-框架\"><a href=\"#五、RPC-Remote-Procedure-Call-Protocol-框架\" class=\"headerlink\" title=\"五、RPC(Remote Procedure Call Protocol)框架\"></a>五、RPC(Remote Procedure Call Protocol)框架</h4><p>RPC的主要功能: 目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。<br>说得通俗一点就是：调用远程计算机上的服务，就像调用本地服务一样。</p>\n<h5 id=\"RMI\"><a href=\"#RMI\" class=\"headerlink\" title=\"RMI\"></a>RMI</h5><ol>\n<li>JAVA自带的远程方法调用工具，不过有一定的局限性，毕竟是JAVA语言最开始时的设计，后来很多框架的原理都基于RMI;</li>\n</ol>\n<h5 id=\"Hessian\"><a href=\"#Hessian\" class=\"headerlink\" title=\"Hessian\"></a>Hessian</h5><ol>\n<li>点评将Hessian封装产生了<a href=\"https://github.com/dianping/pigeon\" target=\"_blank\" rel=\"external\">Pigeon</a></li>\n</ol>\n<h5 id=\"Thrift\"><a href=\"#Thrift\" class=\"headerlink\" title=\"Thrift\"></a>Thrift</h5><h5 id=\"Dubbo\"><a href=\"#Dubbo\" class=\"headerlink\" title=\"Dubbo\"></a>Dubbo</h5><h5 id=\"Proto-Buffer\"><a href=\"#Proto-Buffer\" class=\"headerlink\" title=\"Proto Buffer\"></a>Proto Buffer</h5><h5 id=\"Kryo\"><a href=\"#Kryo\" class=\"headerlink\" title=\"Kryo\"></a>Kryo</h5><h5 id=\"Jackson\"><a href=\"#Jackson\" class=\"headerlink\" title=\"Jackson\"></a>Jackson</h5><h5 id=\"WebService\"><a href=\"#WebService\" class=\"headerlink\" title=\"WebService\"></a>WebService</h5><h4 id=\"六、一致性服务\"><a href=\"#六、一致性服务\" class=\"headerlink\" title=\"六、一致性服务\"></a>六、一致性服务</h4><h5 id=\"Zookeeper\"><a href=\"#Zookeeper\" class=\"headerlink\" title=\"Zookeeper\"></a>Zookeeper</h5><ol>\n<li>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等;</li>\n<li>ZooKeeper的名字很有趣, 是为了管理Hadoop生态系统的Pig(猪)、Hive(蜜蜂)、Hbase(海豚)等;</li>\n<li>Paxos算法</li>\n</ol>\n<h4 id=\"七、实时应用监控平台\"><a href=\"#七、实时应用监控平台\" class=\"headerlink\" title=\"七、实时应用监控平台\"></a>七、实时应用监控平台</h4><h5 id=\"Cat-Central-Application-Tracking\"><a href=\"#Cat-Central-Application-Tracking\" class=\"headerlink\" title=\"Cat (Central Application Tracking)\"></a>Cat (Central Application Tracking)</h5><ol>\n<li>CAT (Central Application Tracking) 是基于Java开发的实时应用监控平台，为美团点评提供了全面的监控服务和决策支持。</li>\n<li>CAT作为美团点评基础监控组件，它已经在中间件框架（MVC框架，RPC框架，数据库框架，缓存框架等）中得到广泛应用，为点评各业务线提供系统的性能指标、健康状况、基础告警等。</li>\n<li>CAT作为美团点评移动端基础监控组件，覆盖了美团点评侧几乎所有APP，提供了近实时的多维数据分析，立体式监控功能。</li>\n<li>CAT很大的优势是它是一个实时系统，从数据生成到服务端处理结束是秒级别，秒级定义是48分钟40秒，基本上看到48分钟38秒数据，整体报表的统计粒度是分钟级；第二个优势，数据是接近全量统计，目前大约5%的高qps项目是采样统计。</li>\n<li>Github: <a href=\"https://github.com/dianping/cat\" target=\"_blank\" rel=\"external\">https://github.com/dianping/cat</a></li>\n</ol>\n","excerpt":"<p>我这个人有一个很大的缺点,就是特别喜欢总结,把一些东西归类、划分、对比。非要把人家的优劣区分出来才行,但是有时候对技术容易浅尝辄止。这篇文章就是对工作学习中用到的技术分别整理一下。<br></p>","more":"<p></p>\n<h4 id=\"一、语言\"><a href=\"#一、语言\" class=\"headerlink\" title=\"一、语言\"></a>一、语言</h4><h5 id=\"1-1-Java-健壮的大型软件\"><a href=\"#1-1-Java-健壮的大型软件\" class=\"headerlink\" title=\"1.1.Java 健壮的大型软件\"></a>1.1.Java 健壮的大型软件</h5><h5 id=\"1-2-C-操作系统及驱动\"><a href=\"#1-2-C-操作系统及驱动\" class=\"headerlink\" title=\"1.2.C 操作系统及驱动\"></a>1.2.C 操作系统及驱动</h5><h5 id=\"1-3-C-需求效率的软件\"><a href=\"#1-3-C-需求效率的软件\" class=\"headerlink\" title=\"1.3.C++ 需求效率的软件\"></a>1.3.C++ 需求效率的软件</h5><h5 id=\"1-4-Python-快速开发应用程序\"><a href=\"#1-4-Python-快速开发应用程序\" class=\"headerlink\" title=\"1.4.Python 快速开发应用程序\"></a>1.4.Python 快速开发应用程序</h5><h5 id=\"1-5-Go\"><a href=\"#1-5-Go\" class=\"headerlink\" title=\"1.5.Go\"></a>1.5.Go</h5><h5 id=\"1-6-JVM语言：Scala-Spark-Groovy-Clojure-Kotlin\"><a href=\"#1-6-JVM语言：Scala-Spark-Groovy-Clojure-Kotlin\" class=\"headerlink\" title=\"1.6.JVM语言：Scala(Spark)\\Groovy\\Clojure\\Kotlin\"></a>1.6.JVM语言：Scala(Spark)\\Groovy\\Clojure\\Kotlin</h5><h5 id=\"1-7-Ruby\"><a href=\"#1-7-Ruby\" class=\"headerlink\" title=\"1.7.Ruby\"></a>1.7.Ruby</h5><h5 id=\"1-8-参考资料\"><a href=\"#1-8-参考资料\" class=\"headerlink\" title=\"1.8.参考资料\"></a>1.8.参考资料</h5><ul>\n<li><a href=\"https://book.douban.com/subject/10555435/\">七周七语言</a></li>\n</ul>\n<h4 id=\"二、Java-IDE（集成开发环境）\"><a href=\"#二、Java-IDE（集成开发环境）\" class=\"headerlink\" title=\"二、Java IDE（集成开发环境）\"></a>二、Java IDE（集成开发环境）</h4><h5 id=\"1-1-Eclipse\"><a href=\"#1-1-Eclipse\" class=\"headerlink\" title=\"1.1.Eclipse\"></a>1.1.Eclipse</h5><h5 id=\"1-2-MyEclipse\"><a href=\"#1-2-MyEclipse\" class=\"headerlink\" title=\"1.2.MyEclipse\"></a>1.2.MyEclipse</h5><h5 id=\"1-3-IntellijIDEA-jetbrains\"><a href=\"#1-3-IntellijIDEA-jetbrains\" class=\"headerlink\" title=\"1.3.IntellijIDEA jetbrains\"></a>1.3.IntellijIDEA jetbrains</h5><h5 id=\"1-4-NetBean\"><a href=\"#1-4-NetBean\" class=\"headerlink\" title=\"1.4.NetBean\"></a>1.4.NetBean</h5><h5 id=\"1-5-参考资料\"><a href=\"#1-5-参考资料\" class=\"headerlink\" title=\"1.5.参考资料\"></a>1.5.参考资料</h5><ul>\n<li><a href=\"https://www.zhihu.com/question/29076145\">IDEA对比Eclipse</a></li>\n</ul>\n<h4 id=\"三、非关系型数据库\"><a href=\"#三、非关系型数据库\" class=\"headerlink\" title=\"三、非关系型数据库\"></a>三、非关系型数据库</h4><h5 id=\"1-1-Redis\"><a href=\"#1-1-Redis\" class=\"headerlink\" title=\"1.1.Redis\"></a>1.1.Redis</h5><h5 id=\"1-2-Memcached\"><a href=\"#1-2-Memcached\" class=\"headerlink\" title=\"1.2.Memcached\"></a>1.2.Memcached</h5><h5 id=\"1-3-MongoDB\"><a href=\"#1-3-MongoDB\" class=\"headerlink\" title=\"1.3.MongoDB\"></a>1.3.MongoDB</h5><h5 id=\"1-4-Tair\"><a href=\"#1-4-Tair\" class=\"headerlink\" title=\"1.4.Tair\"></a>1.4.Tair</h5><h5 id=\"1-5-参考资料-1\"><a href=\"#1-5-参考资料-1\" class=\"headerlink\" title=\"1.5.参考资料\"></a>1.5.参考资料</h5><h4 id=\"四、关系型数据库\"><a href=\"#四、关系型数据库\" class=\"headerlink\" title=\"四、关系型数据库\"></a>四、关系型数据库</h4><h5 id=\"1-1-MySQL\"><a href=\"#1-1-MySQL\" class=\"headerlink\" title=\"1.1.MySQL\"></a>1.1.MySQL</h5><h5 id=\"1-2-Oracle\"><a href=\"#1-2-Oracle\" class=\"headerlink\" title=\"1.2.Oracle\"></a>1.2.Oracle</h5><h5 id=\"1-3-SqlServer\"><a href=\"#1-3-SqlServer\" class=\"headerlink\" title=\"1.3.SqlServer\"></a>1.3.SqlServer</h5><h4 id=\"五、RPC-Remote-Procedure-Call-Protocol-框架\"><a href=\"#五、RPC-Remote-Procedure-Call-Protocol-框架\" class=\"headerlink\" title=\"五、RPC(Remote Procedure Call Protocol)框架\"></a>五、RPC(Remote Procedure Call Protocol)框架</h4><p>RPC的主要功能: 目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。<br>说得通俗一点就是：调用远程计算机上的服务，就像调用本地服务一样。</p>\n<h5 id=\"RMI\"><a href=\"#RMI\" class=\"headerlink\" title=\"RMI\"></a>RMI</h5><ol>\n<li>JAVA自带的远程方法调用工具，不过有一定的局限性，毕竟是JAVA语言最开始时的设计，后来很多框架的原理都基于RMI;</li>\n</ol>\n<h5 id=\"Hessian\"><a href=\"#Hessian\" class=\"headerlink\" title=\"Hessian\"></a>Hessian</h5><ol>\n<li>点评将Hessian封装产生了<a href=\"https://github.com/dianping/pigeon\">Pigeon</a></li>\n</ol>\n<h5 id=\"Thrift\"><a href=\"#Thrift\" class=\"headerlink\" title=\"Thrift\"></a>Thrift</h5><h5 id=\"Dubbo\"><a href=\"#Dubbo\" class=\"headerlink\" title=\"Dubbo\"></a>Dubbo</h5><h5 id=\"Proto-Buffer\"><a href=\"#Proto-Buffer\" class=\"headerlink\" title=\"Proto Buffer\"></a>Proto Buffer</h5><h5 id=\"Kryo\"><a href=\"#Kryo\" class=\"headerlink\" title=\"Kryo\"></a>Kryo</h5><h5 id=\"Jackson\"><a href=\"#Jackson\" class=\"headerlink\" title=\"Jackson\"></a>Jackson</h5><h5 id=\"WebService\"><a href=\"#WebService\" class=\"headerlink\" title=\"WebService\"></a>WebService</h5><h4 id=\"六、一致性服务\"><a href=\"#六、一致性服务\" class=\"headerlink\" title=\"六、一致性服务\"></a>六、一致性服务</h4><h5 id=\"Zookeeper\"><a href=\"#Zookeeper\" class=\"headerlink\" title=\"Zookeeper\"></a>Zookeeper</h5><ol>\n<li>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等;</li>\n<li>ZooKeeper的名字很有趣, 是为了管理Hadoop生态系统的Pig(猪)、Hive(蜜蜂)、Hbase(海豚)等;</li>\n<li>Paxos算法</li>\n</ol>\n<h4 id=\"七、实时应用监控平台\"><a href=\"#七、实时应用监控平台\" class=\"headerlink\" title=\"七、实时应用监控平台\"></a>七、实时应用监控平台</h4><h5 id=\"Cat-Central-Application-Tracking\"><a href=\"#Cat-Central-Application-Tracking\" class=\"headerlink\" title=\"Cat (Central Application Tracking)\"></a>Cat (Central Application Tracking)</h5><ol>\n<li>CAT (Central Application Tracking) 是基于Java开发的实时应用监控平台，为美团点评提供了全面的监控服务和决策支持。</li>\n<li>CAT作为美团点评基础监控组件，它已经在中间件框架（MVC框架，RPC框架，数据库框架，缓存框架等）中得到广泛应用，为点评各业务线提供系统的性能指标、健康状况、基础告警等。</li>\n<li>CAT作为美团点评移动端基础监控组件，覆盖了美团点评侧几乎所有APP，提供了近实时的多维数据分析，立体式监控功能。</li>\n<li>CAT很大的优势是它是一个实时系统，从数据生成到服务端处理结束是秒级别，秒级定义是48分钟40秒，基本上看到48分钟38秒数据，整体报表的统计粒度是分钟级；第二个优势，数据是接近全量统计，目前大约5%的高qps项目是采样统计。</li>\n<li>Github: <a href=\"https://github.com/dianping/cat\">https://github.com/dianping/cat</a></li>\n</ol>"},{"title":"Java技术栈","date":"2017-03-09T08:39:56.000Z","toc":true,"_content":"### 1 java基础：\n\n#### 1.1 算法\n1. 排序算法：直接插入排序、希尔排序、冒泡排序、快速排序、直接选择排序、堆排序、归并排序、基数排序\n2. 二叉查找树、红黑树、B树、B+树、LSM树（分别有对应的应用，数据库、HBase）\n3. BitSet解决数据重复和是否存在等问题\n<!--more-->\n\n#### 1.2 基本\n1. 字符串常量池的迁移\n2. 字符串KMP算法\n3. equals和hashcode\n4. 泛型、异常、反射\n5. string的hash算法\n6. hash冲突的解决办法：拉链法\n7. foreach循环的原理\n8. static、final、transient等关键字的作用\n9. volatile关键字的底层实现原理\n10. Collections.sort方法使用的是哪种排序方法\n11. Future接口，常见的线程池中的FutureTask实现等\n12. string的intern方法的内部细节，jdk1.6和jdk1.7的变化以及内部cpp代码StringTable的实现\n\n#### 1.3 设计模式\n1. 单例模式\n2. 工厂模式\n3. 装饰者模式\n4. 观察者设计模式\n5. ThreadLocal设计模式\n6. 其他\n\n#### 1.4 正则表达式\n1. 捕获组和非捕获组\n2. 贪婪，勉强，独占模式\n\n#### 1.5 java内存模型以及垃圾回收算法\n1. 类加载机制，也就是双亲委派模型\n2. java内存分配模型（默认HotSpot）\n3. 线程共享的：堆区、永久区 线程独享的：虚拟机栈、本地方法栈、程序计数器\n4. 内存分配机制：年轻代（Eden区、两个Survivor区）、年老代、永久代以及他们的分配过程\n5. 强引用、软引用、弱引用、虚引用与GC\n6. happens-before规则\n7. 指令重排序、内存栅栏\n8. Java 8的内存分代改进\n9. 垃圾回收算法：\n标记-清除（不足之处：效率不高、内存碎片）\n复制算法（解决了上述问题，但是内存只能使用一半，针对大部分对象存活时间短的场景，引出了一个默认的8:1:1的改进，缺点是仍然需要借助外界来解决可能承载不下的问题）\n标记整理\n10. 常用垃圾收集器：\n新生代：Serial收集器、ParNew收集器、Parallel Scavenge 收集器\n老年代：Serial Old收集器、Parallel Old收集器、CMS（Concurrent Mark Sweep）收集器、 G1 收集器（跨新生代和老年代）\n11. 常用gc的参数：-Xmn、-Xms、-Xmx、-XX:MaxPermSize、-XX:SurvivorRatio、-XX:-PrintGCDetails\n12. 常用工具： jps、jstat、jmap、jstack、图形工具jConsole、Visual VM、MAT\n\n#### 1.6 锁以及并发容器的源码\n1. synchronized和volatile理解\n2. Unsafe类的原理，使用它来实现CAS。因此诞生了AtomicInteger系列等\n3. CAS可能产生的ABA问题的解决，如加入修改次数、版本号\n4. 同步器AQS的实现原理\n5. 独占锁、共享锁；可重入的独占锁ReentrantLock、共享锁 实现原理\n6. 公平锁和非公平锁\n7. 读写锁 ReentrantReadWriteLock的实现原理\n8. LockSupport工具\n9. Condition接口及其实现原理\n10. HashMap、HashSet、ArrayList、LinkedList、HashTable、ConcurrentHashMap、TreeMap的实现原理\n11. HashMap的并发问题\n12. ConcurrentLinkedQueue的实现原理\n13. Fork/Join框架\n14. CountDownLatch和CyclicBarrier\n\n#### 1.7 线程池源码\n1. 内部执行原理\n2. 各种线程池的区别\n\n### 2 web方面：\n\n#### 2.1 SpringMVC的架构设计\n1. servlet开发存在的问题：映射问题、参数获取问题、格式化转换问题、返回值处理问题、视图渲染问题\n2. SpringMVC为解决上述问题开发的几大组件及接口：HandlerMapping、HandlerAdapter、HandlerMethodArgumentResolver、HttpMessageConverter、Converter、GenericConverter、HandlerMethodReturnValueHandler、ViewResolver、MultipartResolver\n3. DispatcherServlet、容器、组件三者之间的关系\n4. 叙述SpringMVC对请求的整体处理流程\n5. SpringBoot\n\n#### 2.2 SpringAOP源码\n1. AOP的实现分类：编译期、字节码加载前、字节码加载后三种时机来实现AOP\n2. 深刻理解其中的角色：AOP联盟、aspectj、jboss AOP、Spring自身实现的AOP、Spring嵌入aspectj。特别是能用代码区分后两者\n3. 接口设计：\n AOP联盟定义的概念或接口：Pointcut（概念，没有定义对应的接口）、Joinpoint、Advice、MethodInterceptor、MethodInvocation\n SpringAOP针对上述Advice接口定义的接口及其实现类：BeforeAdvice、AfterAdvice、MethodBeforeAdvice、AfterReturningAdvice；针对aspectj对上述接口的实现AspectJMethodBeforeAdvice、AspectJAfterReturningAdvice、AspectJAfterThrowingAdvice、AspectJAfterAdvice。\n SpringAOP定义的定义的AdvisorAdapter接口：将上述Advise转化为MethodInterceptor\n SpringAOP定义的Pointcut接口：含有两个属性ClassFilter（过滤类）、MethodMatcher（过滤方法）\n SpringAOP定义的ExpressionPointcut接口：实现中会引入aspectj的pointcut表达式\n SpringAOP定义的PointcutAdvisor接口（将上述Advice接口和Pointcut接口结合起来）\n4. SpringAOP的调用流程\n5. SpringAOP自己的实现方式（代表人物ProxyFactoryBean）和借助aspectj实现方式区分\n\n#### 2.3 Spring事务体系源码以及分布式事务Jotm Atomikos源码实现\n1. jdbc事务存在的问题\n3. Hibernate对事务的改进\n3. 针对各种各样的事务，Spring如何定义事务体系的接口，以及如何融合jdbc事务和Hibernate事务的\n4. 三种事务模型包含的角色以及各自的职责\n5. 事务代码也业务代码分离的实现（AOP+ThreadLocal来实现）\n6. Spring事务拦截器TransactionInterceptor全景\n7. X/Open DTP模型，两阶段提交，JTA接口定义\n8. Jotm、Atomikos的实现原理\n9. 事务的传播属性\n10. PROPAGATION_REQUIRES_NEW、PROPAGATION_NESTED的实现原理以及区别\n11. 事物的挂起和恢复的原理\n\n#### 2.4 数据库隔离级别\n1. Read uncommitted：读未提交\n2. Read committed ： 读已提交\n3. Repeatable read：可重复读\n4. Serializable ：串行化\n\n#### 2.5 数据库\n1. 数据库性能的优化\n2. 深入理解mysql的Record Locks、Gap Locks、Next-Key Locks\n例如下面的在什么情况下会出现死锁：\nstart transaction; DELETE FROM t WHERE id =6; INSERT INTO t VALUES(6); commit;\n3. insert into select语句的加锁情况\n4. 事务的ACID特性概念\n5. innodb的MVCC理解\n6. undo redo binlog\n7. undo redo 都可以实现持久化，他们的流程是什么？为什么选用redo来做持久化？\n8. undo、redo结合起来实现原子性和持久化，为什么undo log要先于redo log持久化？\n9. undo为什么要依赖redo？\n10. 日志内容可以是物理日志，也可以是逻辑日志？他们各自的优点和缺点是？\n11. redo log最终采用的是物理日志加逻辑日志，物理到page，page内逻辑。还存在什么问题？怎么解决？Double Write\n12. undo log为什么不采用物理日志而采用逻辑日志？\n13. 为什么要引入Checkpoint？\n14. 引入Checkpoint后为了保证一致性需要阻塞用户操作一段时间，怎么解决这个问题？（这个问题还是很有普遍性的，redis、ZooKeeper都有类似的情况以及不同的应对策略）又有了同步Checkpoint和异步Checkpoint\n15. 开启binlog的情况下，事务内部2PC的一般过程（含有2次持久化，redo log和binlog的持久化）\n16. 解释上述过程，为什么binlog的持久化要在redo log之后，在存储引擎commit之前？\n17. 为什么要保持事务之间写入binlog和执行存储引擎commit操作的顺序性？（即先写入binlog日志的事务一定先commit）\n18. 为了保证上述顺序性，之前的办法是加锁prepare_commit_mutex，但是这极大的降低了事务的效率，怎么来实现binlog的group commit？\n19. 怎么将redo log的持久化也实现group commit？至此事务内部2PC的过程，2次持久化的操作都可以group commit了，极大提高了效率\n\n#### 2.6 ORM框架: mybatis、Hibernate\n1. 最原始的jdbc->Spring的JdbcTemplate->hibernate->JPA->SpringDataJPA的演进之路\n\n#### 2.7 SpringSecurity、shiro、SSO（单点登录）\n1. Session和Cookie的区别和联系以及Session的实现原理\n2. SpringSecurity的认证过程以及与Session的关系\n3. CAS实现SSO（详见Cas（01）——简介）输入图片说明\n\n#### 2.8 日志\n1. jdk自带的logging、log4j、log4j2、logback\n2. 门面commons-logging、slf4j\n3. 上述6种混战时的日志转换\n\n#### 2.9 datasource\n1. c3p0\n2. druid\n3. JdbcTemplate执行sql语句的过程中对Connection的使用和管理\n\n#### 2.10 HTTPS的实现原理\n\n### 3 分布式、java中间件、web服务器等方面：\n\n#### 3.1 ZooKeeper源码\n1. 客户端架构\n2. 服务器端单机版和集群版，对应的请求处理器\n3. 集群版session的建立和激活过程\n4. Leader选举过程\n5. 事务日志和快照文件的详细解析\n6. 实现分布式锁、分布式ID分发器\n7. 实现Leader选举\n8. ZAB协议实现一致性原理\n\n#### 3.2 序列化和反序列化框架\n1. Avro研究\n2. Thrift研究\n3. Protobuf研究\n4. Protostuff研究\n5. Hessian\n\n#### 3.3 RPC框架dubbo源码\n1. dubbo扩展机制的实现，对比SPI机制\n2. 服务的发布过程\n3. 服务的订阅过程\n4. RPC通信的设计\n\n#### 3.4 NIO模块以及对应的Netty和Mina、thrift源码\n1. TCP握手和断开及有限状态机\n2. backlog\n3. BIO NIO\n4. 阻塞/非阻塞的区别、同步/异步的区别\n5. 阻塞IO、非阻塞IO、多路复用IO、异步IO\n6. Reactor线程模型\n7. jdk的poll、epoll与底层poll、epoll的对接实现\n8. Netty自己的epoll实现\n9. 内核层poll、epoll的大致实现\n10. epoll的边缘触发和水平触发\n11. Netty的EventLoopGroup设计\n12. Netty的ByteBuf设计\n13. Netty的ChannelHandler\n13. Netty的零拷贝\n14. Netty的线程模型，特别是与业务线程以及资源释放方面的理解\n\n#### 3.5 消息队列kafka、RocketMQ、Notify、Hermes\n1. kafka的文件存储设计\n2. kafka的副本复制过程\n3. kafka副本的leader选举过程\n4. kafka的消息丢失问题\n5. kafka的消息顺序性问题\n6. kafka的isr设计和过半对比\n7. kafka本身做的很轻量级来保持高效，很多高级特性没有：事务、优先级的消息、消息的过滤，更重要的是服务治理不健全，一旦出问题，不能直观反应出来，不太适合对数据要求十分严苛的企业级系统，而适合日志之类并发量大但是允许少量的丢失或重复等场景\n8. Notify、RocketMQ的事务设计\n9. 基于文件的kafka、RocketMQ和基于数据库的Notify和Hermes\n10. 设计一个消息系统要考虑哪些方面\n11. 丢失消息、消息重复、高可用等话题\n\n#### 3.6 数据库的分库分表mycat\n\n#### 3.7 NoSql数据库mongodb\n\n#### 3.8 KV键值系统memcached redis\n1. redis对客户端的维护和管理，读写缓冲区\n2. redis事务的实现\n3. Jedis客户端的实现\n4. JedisPool以及ShardedJedisPool的实现\n5. redis epoll实现，循环中的文件事件和时间事件\n6. redis的RDB持久化，save和bgsave\n7. redis AOF命令追加、文件写入、文件同步到磁盘\n8. redis AOF重写，为了减少阻塞时间采取的措施\n9. redis的LRU内存回收算法\n10. redis的master slave复制\n11. redis的sentinel高可用方案\n12. redis的cluster分片方案\n\n#### 3.9 web服务器tomcat、ngnix的设计原理\n1. tomcat的整体架构设计\n2. tomcat对通信的并发控制\n3. http请求到达tomcat的整个处理流程\n\n#### 3.10 ELK日志实时处理查询系统\n1. Elasticsearch、Logstash、Kibana\n\n#### 3.11 服务方面\n1. SOA与微服务\n2. 服务的合并部署、多版本自动快速切换和回滚\n详见基于Java容器的多应用部署技术实践\n3. 服务的治理：限流、降级\n具体见 张开涛大神的架构系列\n服务限流：令牌桶、漏桶\n服务降级、服务的熔断、服务的隔离：netflix的hystrix组件\n4. 服务的线性扩展\n无状态的服务如何做线性扩展：\n如一般的web应用，直接使用硬件或者软件做负载均衡，简单的轮训机制\n有状态服务如何做线性扩展：\n如Redis的扩展：一致性hash，迁移工具\n5. 服务链路监控和报警：CAT、Dapper、Pinpoint\n\n#### 3.12 Spring Cloud\n1. Spring Cloud Zookeeper:用于服务注册和发现\n2. Spring Cloud Config:分布式配置\n3. Spring Cloud Netflix Eureka：用于rest服务的注册和发现\n4. Spring Cloud Netflix Hystrix：服务的隔离、熔断和降级\n5. Spring Cloud Netflix Zuul:动态路由，API Gateway\n\n#### 3.13 分布式事务\n1. JTA分布式事务接口定义，对此与Spring事务体系的整合\n2. TCC分布式事务概念\n3. TCC分布式事务实现框架案例1：tcc-transaction\n13.3.1 TccCompensableAspect切面拦截创建ROOT事务\n13.3.2 TccTransactionContextAspect切面使远程RPC调用资源加入到上述事务中，作为一个参与者\n13.3.3 TccCompensableAspect切面根据远程RPC传递的TransactionContext的标记创建出分支事务\n13.3.4 全部RPC调用完毕，ROOT事务开始提交或者回滚，执行所有参与者的提交或回滚\n13.3.5 所有参与者的提交或者回滚，还是通过远程RPC调用，provider端开始执行对应分支事务的confirm或者cancel方法\n13.3.6 事务的存储，集群共享问题\n13.3.7 事务的恢复，避免集群重复恢复\n4. TCC分布式事务实现框架案例2：ByteTCC\n13.4.1 JTA事务管理实现，类比Jotm、Atomikos等JTA实现\n13.4.2 事务的存储和恢复，集群是否共享问题\n调用方创建CompensableTransaction事务，并加入资源\n13.4.3 CompensableMethodInterceptor拦截器向spring事务注入CompensableInvocation资源\n13.4.4 Spring的分布式事务管理器创建作为协调者CompensableTransaction类型事务，和当前线程进行绑定，同时创建一个jta事务\n13.4.5 在执行sql等操作的时候，所使用的jdbc等XAResource资源加入上述jta事务\n13.4.6 dubbo RPC远程调用前，CompensableDubboServiceFilter创建出一个代理XAResource，加入上述CompensableTransaction类型事务，并在RPC调用过程传递TransactionContext\n参与方创建分支的CompensableTransaction事务，并加入资源，然后提交jta事务\n13.4.7 RPC远程调用来到provider端，CompensableDubboServiceFilter根据传递过来的TransactionContext创建出对应的CompensableTransaction类型事务\n13.4.8 provider端，执行时遇见@Transactional和@Compensable，作为一个参与者开启try阶段的事务，即创建了一个jta事务\n13.4.9 provider端try执行完毕开始准备try的提交，仅仅是提交上述jta事务，返回结果到RPC调用端\n调用方决定回滚还是提交\n13.4.10 全部执行完毕后开始事务的提交或者回滚，如果是提交则先对jta事务进行提交（包含jdbc等XAResource资源的提交），提交成功后再对CompensableTransaction类型事务进行提交，如果jta事务提交失败，则需要回滚CompensableTransaction类型事务。\n13.4.11 CompensableTransaction类型事务的提交就是对CompensableInvocation资源和RPC资源的提交，分别调用每一个CompensableInvocation资源的confirm，以及每一个RPC资源的提交\nCompensableInvocation资源的提交\n13.4.12 此时每一个CompensableInvocation资源的confirm又会准备开启一个新的事务，当前线程的CompensableTransaction类型事务已存在，所以这里开启事务仅仅是创建了一个新的jta事务而已\n13.4.13 针对此，每一个CompensableInvocation资源的confirm开启的事务，又开始重复上述过程，对于jdbc等资源都加入新创建的jta事务中，而RPC资源和CompensableInvocation资源仍然加入到当前线程绑定的CompensableTransaction类型事务\n13.4.14 当前CompensableInvocation资源的confirm开启的事务执行完毕后，开始执行commit,此时仍然是执行jta事务的提交，提交完毕，一个CompensableInvocation资源的confirm完成，继续执行下一个CompensableInvocation资源的confirm，即又要重新开启一个新的jta事务\nRPC资源的提交（参与方CompensableTransaction事务的提交）\n13.4.15 当所有CompensableInvocation资源的confirm执行完毕，开始执行RPC资源的commit，会进行远程调用，执行远程provider分支事务的提交，远程调用过程会传递事务id\n13.4.16 provider端，根据传递过来的事务id找到对应的CompensableTransaction事务，开始执行提交操作，提交操作完成后返回响应\n结束\n13.4.17 协调者收到响应后继续执行下一个RPC资源的提交，当所有RPC资源也完成相应的提交，则协调者算是彻底完成该事务\n\n#### 3.14 一致性算法\n1. raft（详见Raft算法赏析）\n14.1.1 leader选举过程，leader选举约束，要包含所有commited entries，实现上log比过半的log都最新即可\n14.1.2 log复制过程，leader给所有的follower发送AppendEntries RPC请求，过半follower回复ok，则可提交该entry，然后向客户端响应OK\n14.1.3 在上述leader收到过半复制之后，挂了，则后续leader不能直接对这些之前term的过半entry进行提交（这一部分有详细的案例来证明，并能说出根本原因），目前做法是在当前term中创建空的entry，然后如果这些新创建的entry被大部分复制了，则此时就可以对之前term的过半entry进行提交了\n14.1.4 leader一旦认为某个term可以提交了，则更新自己的commitIndex，同时应用entry到状态机中，然后在下一次与follower的heartbeat通信中，将leader的commitIndex带给follower，让他们进行更新，同时应用entry到他们的状态机中\n14.1.5 从上述流程可以看到，作为client来说，可能会出现这样的情况：leader认为某次client的请求可以提交了（对应的entry已经被过半复制了），此时leader挂了，还没来得及给client回复，也就是说对client来说，请求虽然失败了，但是请求对应的entry却被持久化保存了，但是有的时候却是请求失败了（过半都没复制成功）没有持久化成功，也就是说请求失败了，服务器端可能成功了也可能失败了。所以这时候需要在client端下功夫，即cleint端重试的时候仍然使用之前的请求数据进行重试，而不是采用新的数据进行重试，服务器端也必须要实现幂等。\n14.1.6 Cluster membership changes\n2. ZooKeeper使用的ZAB协议（详见ZooKeeper的一致性算法赏析）\n14.2.1 leader选举过程。要点：对于不同状态下的server的投票的收集，投票是需要选举出一个包含所有日志的server来作为leader\n14.2.2 leader和follower数据同步过程，全量同步、差异同步、日志之间的纠正和截断，来保证和leader之间的一致性。以及follower加入已经完成选举的系统，此时的同步的要点：阻塞leader处理写请求，完成日志之间的差异同步，还要处理现有进行中的请求的同步，完成同步后，解除阻塞。\n14.2.3 广播阶段，即正常处理客户端的请求，过半响应即可回复客户端。\n14.2.4 日志的恢复和持久化。持久化：每隔一定数量的事务日志持久化一次，leader选举前持久化一次。恢复：简单的认为已写入日志的的事务请求都算作已提交的请求（不管之前是否已过半复制），全部执行commit提交。具体的恢复是：先恢复快照日志，然后再应用相应的事务日志\n3. paxos（详见paxos算法证明过程）\n14.3.1 paxos的运作过程：\nPhase 1: (a) 一个proposer选择一个编号为n的议案，向所有的acceptor发送prepare请求\nPhase 1: (b) 如果acceptor已经响应的prepare请求中议案编号都比n小，则它承诺不再响应prepare请求或者accept请求中议案编号小于n的， 并且找出已经accept的最大议案的value返回给该proposer。如果已响应的编号比n大，则直接忽略该prepare请求。\nPhase 2：(a) 如果proposer收到了过半的acceptors响应，那么将提出一个议案（n，v）,v就是上述所有acceptor响应中最大accept议案的value，或者是proposer自己的value。然后将该议案发送给所有的acceptor。这个请求叫做accept请求，这一步才是所谓发送议案请求，而前面的prepare请求更多的是一个构建出最终议案(n,v)的过程。\nPhase 2：(b) acceptor接收到编号为n的议案，如果acceptor还没有对大于n的议案的prepare请求响应过，则acceptor就accept该议案，否则拒绝\n14.3.2 paxos的证明过程：\n1 足够多的问题\n2 acceptor的初始accept\n3 P2-对结果要求\n4 P2a-对acceptor的accept要求\n5 P2b-对proposer提出议案的要求（结果上要求）\n6 P2c-对proposer提出议案的要求（做法上要求）\n7 引出prepare过程和P1a\n8 优化prepare\n14.3.3 base paxos和multi-paxos\n\n### 4 大数据方向\n\n#### 4.1 Hadoop\n1. UserGroupInformation源码解读：JAAS认证、user和group关系的维护\n2. RPC通信的实现\n3. 代理用户的过程\n4. kerberos认证\n\n#### 4.2 MapReduce\n1. MapReduce理论及其对应的接口定义\n\n#### 4.3 HDFS\n1. MapFile、SequenceFile\n2. ACL\n\n#### 4.4 YARN、Mesos 资源调度\n\n#### 4.5 oozie\n1. oozie XCommand设计\n2. DagEngine的实现原理\n\n#### 4.6 Hive\n1. HiveServer2、metatore的thrift RPC通信设计\n2. Hive的优化过程\n3. HiveServer2的认证和授权\n4. metastore的认证和授权\n5. HiveServer2向metatore的用户传递过程\n\n#### 4.7 Hbase\n1. Hbase的整体架构图\n2. Hbase的WAL和MVCC设计\n3. client端的异步批量flush寻找RegionServer的过程\n4. Zookeeper上HBase节点解释\n5. Hbase中的mini、major合并\n6. Region的高可用问题对比kafka分区的高可用实现\n7. RegionServer RPC调用的隔离问题\n8. 数据从内存刷写到HDFS的粒度问题\n9. rowKey的设计\n10. MemStore与LSM\n\n#### 4.8 Spark\n1. 不同的部署方式\n2. SparkSql的实现方式\n3. 。。。","source":"_posts/7Java技术栈.md","raw":"---\ntitle: Java技术栈\ndate: 2017-03-09 16:39:56\ntags: Java 面试\ncategories: \"面试\"\ntoc: true\n---\n### 1 java基础：\n\n#### 1.1 算法\n1. 排序算法：直接插入排序、希尔排序、冒泡排序、快速排序、直接选择排序、堆排序、归并排序、基数排序\n2. 二叉查找树、红黑树、B树、B+树、LSM树（分别有对应的应用，数据库、HBase）\n3. BitSet解决数据重复和是否存在等问题\n<!--more-->\n\n#### 1.2 基本\n1. 字符串常量池的迁移\n2. 字符串KMP算法\n3. equals和hashcode\n4. 泛型、异常、反射\n5. string的hash算法\n6. hash冲突的解决办法：拉链法\n7. foreach循环的原理\n8. static、final、transient等关键字的作用\n9. volatile关键字的底层实现原理\n10. Collections.sort方法使用的是哪种排序方法\n11. Future接口，常见的线程池中的FutureTask实现等\n12. string的intern方法的内部细节，jdk1.6和jdk1.7的变化以及内部cpp代码StringTable的实现\n\n#### 1.3 设计模式\n1. 单例模式\n2. 工厂模式\n3. 装饰者模式\n4. 观察者设计模式\n5. ThreadLocal设计模式\n6. 其他\n\n#### 1.4 正则表达式\n1. 捕获组和非捕获组\n2. 贪婪，勉强，独占模式\n\n#### 1.5 java内存模型以及垃圾回收算法\n1. 类加载机制，也就是双亲委派模型\n2. java内存分配模型（默认HotSpot）\n3. 线程共享的：堆区、永久区 线程独享的：虚拟机栈、本地方法栈、程序计数器\n4. 内存分配机制：年轻代（Eden区、两个Survivor区）、年老代、永久代以及他们的分配过程\n5. 强引用、软引用、弱引用、虚引用与GC\n6. happens-before规则\n7. 指令重排序、内存栅栏\n8. Java 8的内存分代改进\n9. 垃圾回收算法：\n标记-清除（不足之处：效率不高、内存碎片）\n复制算法（解决了上述问题，但是内存只能使用一半，针对大部分对象存活时间短的场景，引出了一个默认的8:1:1的改进，缺点是仍然需要借助外界来解决可能承载不下的问题）\n标记整理\n10. 常用垃圾收集器：\n新生代：Serial收集器、ParNew收集器、Parallel Scavenge 收集器\n老年代：Serial Old收集器、Parallel Old收集器、CMS（Concurrent Mark Sweep）收集器、 G1 收集器（跨新生代和老年代）\n11. 常用gc的参数：-Xmn、-Xms、-Xmx、-XX:MaxPermSize、-XX:SurvivorRatio、-XX:-PrintGCDetails\n12. 常用工具： jps、jstat、jmap、jstack、图形工具jConsole、Visual VM、MAT\n\n#### 1.6 锁以及并发容器的源码\n1. synchronized和volatile理解\n2. Unsafe类的原理，使用它来实现CAS。因此诞生了AtomicInteger系列等\n3. CAS可能产生的ABA问题的解决，如加入修改次数、版本号\n4. 同步器AQS的实现原理\n5. 独占锁、共享锁；可重入的独占锁ReentrantLock、共享锁 实现原理\n6. 公平锁和非公平锁\n7. 读写锁 ReentrantReadWriteLock的实现原理\n8. LockSupport工具\n9. Condition接口及其实现原理\n10. HashMap、HashSet、ArrayList、LinkedList、HashTable、ConcurrentHashMap、TreeMap的实现原理\n11. HashMap的并发问题\n12. ConcurrentLinkedQueue的实现原理\n13. Fork/Join框架\n14. CountDownLatch和CyclicBarrier\n\n#### 1.7 线程池源码\n1. 内部执行原理\n2. 各种线程池的区别\n\n### 2 web方面：\n\n#### 2.1 SpringMVC的架构设计\n1. servlet开发存在的问题：映射问题、参数获取问题、格式化转换问题、返回值处理问题、视图渲染问题\n2. SpringMVC为解决上述问题开发的几大组件及接口：HandlerMapping、HandlerAdapter、HandlerMethodArgumentResolver、HttpMessageConverter、Converter、GenericConverter、HandlerMethodReturnValueHandler、ViewResolver、MultipartResolver\n3. DispatcherServlet、容器、组件三者之间的关系\n4. 叙述SpringMVC对请求的整体处理流程\n5. SpringBoot\n\n#### 2.2 SpringAOP源码\n1. AOP的实现分类：编译期、字节码加载前、字节码加载后三种时机来实现AOP\n2. 深刻理解其中的角色：AOP联盟、aspectj、jboss AOP、Spring自身实现的AOP、Spring嵌入aspectj。特别是能用代码区分后两者\n3. 接口设计：\n AOP联盟定义的概念或接口：Pointcut（概念，没有定义对应的接口）、Joinpoint、Advice、MethodInterceptor、MethodInvocation\n SpringAOP针对上述Advice接口定义的接口及其实现类：BeforeAdvice、AfterAdvice、MethodBeforeAdvice、AfterReturningAdvice；针对aspectj对上述接口的实现AspectJMethodBeforeAdvice、AspectJAfterReturningAdvice、AspectJAfterThrowingAdvice、AspectJAfterAdvice。\n SpringAOP定义的定义的AdvisorAdapter接口：将上述Advise转化为MethodInterceptor\n SpringAOP定义的Pointcut接口：含有两个属性ClassFilter（过滤类）、MethodMatcher（过滤方法）\n SpringAOP定义的ExpressionPointcut接口：实现中会引入aspectj的pointcut表达式\n SpringAOP定义的PointcutAdvisor接口（将上述Advice接口和Pointcut接口结合起来）\n4. SpringAOP的调用流程\n5. SpringAOP自己的实现方式（代表人物ProxyFactoryBean）和借助aspectj实现方式区分\n\n#### 2.3 Spring事务体系源码以及分布式事务Jotm Atomikos源码实现\n1. jdbc事务存在的问题\n3. Hibernate对事务的改进\n3. 针对各种各样的事务，Spring如何定义事务体系的接口，以及如何融合jdbc事务和Hibernate事务的\n4. 三种事务模型包含的角色以及各自的职责\n5. 事务代码也业务代码分离的实现（AOP+ThreadLocal来实现）\n6. Spring事务拦截器TransactionInterceptor全景\n7. X/Open DTP模型，两阶段提交，JTA接口定义\n8. Jotm、Atomikos的实现原理\n9. 事务的传播属性\n10. PROPAGATION_REQUIRES_NEW、PROPAGATION_NESTED的实现原理以及区别\n11. 事物的挂起和恢复的原理\n\n#### 2.4 数据库隔离级别\n1. Read uncommitted：读未提交\n2. Read committed ： 读已提交\n3. Repeatable read：可重复读\n4. Serializable ：串行化\n\n#### 2.5 数据库\n1. 数据库性能的优化\n2. 深入理解mysql的Record Locks、Gap Locks、Next-Key Locks\n例如下面的在什么情况下会出现死锁：\nstart transaction; DELETE FROM t WHERE id =6; INSERT INTO t VALUES(6); commit;\n3. insert into select语句的加锁情况\n4. 事务的ACID特性概念\n5. innodb的MVCC理解\n6. undo redo binlog\n7. undo redo 都可以实现持久化，他们的流程是什么？为什么选用redo来做持久化？\n8. undo、redo结合起来实现原子性和持久化，为什么undo log要先于redo log持久化？\n9. undo为什么要依赖redo？\n10. 日志内容可以是物理日志，也可以是逻辑日志？他们各自的优点和缺点是？\n11. redo log最终采用的是物理日志加逻辑日志，物理到page，page内逻辑。还存在什么问题？怎么解决？Double Write\n12. undo log为什么不采用物理日志而采用逻辑日志？\n13. 为什么要引入Checkpoint？\n14. 引入Checkpoint后为了保证一致性需要阻塞用户操作一段时间，怎么解决这个问题？（这个问题还是很有普遍性的，redis、ZooKeeper都有类似的情况以及不同的应对策略）又有了同步Checkpoint和异步Checkpoint\n15. 开启binlog的情况下，事务内部2PC的一般过程（含有2次持久化，redo log和binlog的持久化）\n16. 解释上述过程，为什么binlog的持久化要在redo log之后，在存储引擎commit之前？\n17. 为什么要保持事务之间写入binlog和执行存储引擎commit操作的顺序性？（即先写入binlog日志的事务一定先commit）\n18. 为了保证上述顺序性，之前的办法是加锁prepare_commit_mutex，但是这极大的降低了事务的效率，怎么来实现binlog的group commit？\n19. 怎么将redo log的持久化也实现group commit？至此事务内部2PC的过程，2次持久化的操作都可以group commit了，极大提高了效率\n\n#### 2.6 ORM框架: mybatis、Hibernate\n1. 最原始的jdbc->Spring的JdbcTemplate->hibernate->JPA->SpringDataJPA的演进之路\n\n#### 2.7 SpringSecurity、shiro、SSO（单点登录）\n1. Session和Cookie的区别和联系以及Session的实现原理\n2. SpringSecurity的认证过程以及与Session的关系\n3. CAS实现SSO（详见Cas（01）——简介）输入图片说明\n\n#### 2.8 日志\n1. jdk自带的logging、log4j、log4j2、logback\n2. 门面commons-logging、slf4j\n3. 上述6种混战时的日志转换\n\n#### 2.9 datasource\n1. c3p0\n2. druid\n3. JdbcTemplate执行sql语句的过程中对Connection的使用和管理\n\n#### 2.10 HTTPS的实现原理\n\n### 3 分布式、java中间件、web服务器等方面：\n\n#### 3.1 ZooKeeper源码\n1. 客户端架构\n2. 服务器端单机版和集群版，对应的请求处理器\n3. 集群版session的建立和激活过程\n4. Leader选举过程\n5. 事务日志和快照文件的详细解析\n6. 实现分布式锁、分布式ID分发器\n7. 实现Leader选举\n8. ZAB协议实现一致性原理\n\n#### 3.2 序列化和反序列化框架\n1. Avro研究\n2. Thrift研究\n3. Protobuf研究\n4. Protostuff研究\n5. Hessian\n\n#### 3.3 RPC框架dubbo源码\n1. dubbo扩展机制的实现，对比SPI机制\n2. 服务的发布过程\n3. 服务的订阅过程\n4. RPC通信的设计\n\n#### 3.4 NIO模块以及对应的Netty和Mina、thrift源码\n1. TCP握手和断开及有限状态机\n2. backlog\n3. BIO NIO\n4. 阻塞/非阻塞的区别、同步/异步的区别\n5. 阻塞IO、非阻塞IO、多路复用IO、异步IO\n6. Reactor线程模型\n7. jdk的poll、epoll与底层poll、epoll的对接实现\n8. Netty自己的epoll实现\n9. 内核层poll、epoll的大致实现\n10. epoll的边缘触发和水平触发\n11. Netty的EventLoopGroup设计\n12. Netty的ByteBuf设计\n13. Netty的ChannelHandler\n13. Netty的零拷贝\n14. Netty的线程模型，特别是与业务线程以及资源释放方面的理解\n\n#### 3.5 消息队列kafka、RocketMQ、Notify、Hermes\n1. kafka的文件存储设计\n2. kafka的副本复制过程\n3. kafka副本的leader选举过程\n4. kafka的消息丢失问题\n5. kafka的消息顺序性问题\n6. kafka的isr设计和过半对比\n7. kafka本身做的很轻量级来保持高效，很多高级特性没有：事务、优先级的消息、消息的过滤，更重要的是服务治理不健全，一旦出问题，不能直观反应出来，不太适合对数据要求十分严苛的企业级系统，而适合日志之类并发量大但是允许少量的丢失或重复等场景\n8. Notify、RocketMQ的事务设计\n9. 基于文件的kafka、RocketMQ和基于数据库的Notify和Hermes\n10. 设计一个消息系统要考虑哪些方面\n11. 丢失消息、消息重复、高可用等话题\n\n#### 3.6 数据库的分库分表mycat\n\n#### 3.7 NoSql数据库mongodb\n\n#### 3.8 KV键值系统memcached redis\n1. redis对客户端的维护和管理，读写缓冲区\n2. redis事务的实现\n3. Jedis客户端的实现\n4. JedisPool以及ShardedJedisPool的实现\n5. redis epoll实现，循环中的文件事件和时间事件\n6. redis的RDB持久化，save和bgsave\n7. redis AOF命令追加、文件写入、文件同步到磁盘\n8. redis AOF重写，为了减少阻塞时间采取的措施\n9. redis的LRU内存回收算法\n10. redis的master slave复制\n11. redis的sentinel高可用方案\n12. redis的cluster分片方案\n\n#### 3.9 web服务器tomcat、ngnix的设计原理\n1. tomcat的整体架构设计\n2. tomcat对通信的并发控制\n3. http请求到达tomcat的整个处理流程\n\n#### 3.10 ELK日志实时处理查询系统\n1. Elasticsearch、Logstash、Kibana\n\n#### 3.11 服务方面\n1. SOA与微服务\n2. 服务的合并部署、多版本自动快速切换和回滚\n详见基于Java容器的多应用部署技术实践\n3. 服务的治理：限流、降级\n具体见 张开涛大神的架构系列\n服务限流：令牌桶、漏桶\n服务降级、服务的熔断、服务的隔离：netflix的hystrix组件\n4. 服务的线性扩展\n无状态的服务如何做线性扩展：\n如一般的web应用，直接使用硬件或者软件做负载均衡，简单的轮训机制\n有状态服务如何做线性扩展：\n如Redis的扩展：一致性hash，迁移工具\n5. 服务链路监控和报警：CAT、Dapper、Pinpoint\n\n#### 3.12 Spring Cloud\n1. Spring Cloud Zookeeper:用于服务注册和发现\n2. Spring Cloud Config:分布式配置\n3. Spring Cloud Netflix Eureka：用于rest服务的注册和发现\n4. Spring Cloud Netflix Hystrix：服务的隔离、熔断和降级\n5. Spring Cloud Netflix Zuul:动态路由，API Gateway\n\n#### 3.13 分布式事务\n1. JTA分布式事务接口定义，对此与Spring事务体系的整合\n2. TCC分布式事务概念\n3. TCC分布式事务实现框架案例1：tcc-transaction\n13.3.1 TccCompensableAspect切面拦截创建ROOT事务\n13.3.2 TccTransactionContextAspect切面使远程RPC调用资源加入到上述事务中，作为一个参与者\n13.3.3 TccCompensableAspect切面根据远程RPC传递的TransactionContext的标记创建出分支事务\n13.3.4 全部RPC调用完毕，ROOT事务开始提交或者回滚，执行所有参与者的提交或回滚\n13.3.5 所有参与者的提交或者回滚，还是通过远程RPC调用，provider端开始执行对应分支事务的confirm或者cancel方法\n13.3.6 事务的存储，集群共享问题\n13.3.7 事务的恢复，避免集群重复恢复\n4. TCC分布式事务实现框架案例2：ByteTCC\n13.4.1 JTA事务管理实现，类比Jotm、Atomikos等JTA实现\n13.4.2 事务的存储和恢复，集群是否共享问题\n调用方创建CompensableTransaction事务，并加入资源\n13.4.3 CompensableMethodInterceptor拦截器向spring事务注入CompensableInvocation资源\n13.4.4 Spring的分布式事务管理器创建作为协调者CompensableTransaction类型事务，和当前线程进行绑定，同时创建一个jta事务\n13.4.5 在执行sql等操作的时候，所使用的jdbc等XAResource资源加入上述jta事务\n13.4.6 dubbo RPC远程调用前，CompensableDubboServiceFilter创建出一个代理XAResource，加入上述CompensableTransaction类型事务，并在RPC调用过程传递TransactionContext\n参与方创建分支的CompensableTransaction事务，并加入资源，然后提交jta事务\n13.4.7 RPC远程调用来到provider端，CompensableDubboServiceFilter根据传递过来的TransactionContext创建出对应的CompensableTransaction类型事务\n13.4.8 provider端，执行时遇见@Transactional和@Compensable，作为一个参与者开启try阶段的事务，即创建了一个jta事务\n13.4.9 provider端try执行完毕开始准备try的提交，仅仅是提交上述jta事务，返回结果到RPC调用端\n调用方决定回滚还是提交\n13.4.10 全部执行完毕后开始事务的提交或者回滚，如果是提交则先对jta事务进行提交（包含jdbc等XAResource资源的提交），提交成功后再对CompensableTransaction类型事务进行提交，如果jta事务提交失败，则需要回滚CompensableTransaction类型事务。\n13.4.11 CompensableTransaction类型事务的提交就是对CompensableInvocation资源和RPC资源的提交，分别调用每一个CompensableInvocation资源的confirm，以及每一个RPC资源的提交\nCompensableInvocation资源的提交\n13.4.12 此时每一个CompensableInvocation资源的confirm又会准备开启一个新的事务，当前线程的CompensableTransaction类型事务已存在，所以这里开启事务仅仅是创建了一个新的jta事务而已\n13.4.13 针对此，每一个CompensableInvocation资源的confirm开启的事务，又开始重复上述过程，对于jdbc等资源都加入新创建的jta事务中，而RPC资源和CompensableInvocation资源仍然加入到当前线程绑定的CompensableTransaction类型事务\n13.4.14 当前CompensableInvocation资源的confirm开启的事务执行完毕后，开始执行commit,此时仍然是执行jta事务的提交，提交完毕，一个CompensableInvocation资源的confirm完成，继续执行下一个CompensableInvocation资源的confirm，即又要重新开启一个新的jta事务\nRPC资源的提交（参与方CompensableTransaction事务的提交）\n13.4.15 当所有CompensableInvocation资源的confirm执行完毕，开始执行RPC资源的commit，会进行远程调用，执行远程provider分支事务的提交，远程调用过程会传递事务id\n13.4.16 provider端，根据传递过来的事务id找到对应的CompensableTransaction事务，开始执行提交操作，提交操作完成后返回响应\n结束\n13.4.17 协调者收到响应后继续执行下一个RPC资源的提交，当所有RPC资源也完成相应的提交，则协调者算是彻底完成该事务\n\n#### 3.14 一致性算法\n1. raft（详见Raft算法赏析）\n14.1.1 leader选举过程，leader选举约束，要包含所有commited entries，实现上log比过半的log都最新即可\n14.1.2 log复制过程，leader给所有的follower发送AppendEntries RPC请求，过半follower回复ok，则可提交该entry，然后向客户端响应OK\n14.1.3 在上述leader收到过半复制之后，挂了，则后续leader不能直接对这些之前term的过半entry进行提交（这一部分有详细的案例来证明，并能说出根本原因），目前做法是在当前term中创建空的entry，然后如果这些新创建的entry被大部分复制了，则此时就可以对之前term的过半entry进行提交了\n14.1.4 leader一旦认为某个term可以提交了，则更新自己的commitIndex，同时应用entry到状态机中，然后在下一次与follower的heartbeat通信中，将leader的commitIndex带给follower，让他们进行更新，同时应用entry到他们的状态机中\n14.1.5 从上述流程可以看到，作为client来说，可能会出现这样的情况：leader认为某次client的请求可以提交了（对应的entry已经被过半复制了），此时leader挂了，还没来得及给client回复，也就是说对client来说，请求虽然失败了，但是请求对应的entry却被持久化保存了，但是有的时候却是请求失败了（过半都没复制成功）没有持久化成功，也就是说请求失败了，服务器端可能成功了也可能失败了。所以这时候需要在client端下功夫，即cleint端重试的时候仍然使用之前的请求数据进行重试，而不是采用新的数据进行重试，服务器端也必须要实现幂等。\n14.1.6 Cluster membership changes\n2. ZooKeeper使用的ZAB协议（详见ZooKeeper的一致性算法赏析）\n14.2.1 leader选举过程。要点：对于不同状态下的server的投票的收集，投票是需要选举出一个包含所有日志的server来作为leader\n14.2.2 leader和follower数据同步过程，全量同步、差异同步、日志之间的纠正和截断，来保证和leader之间的一致性。以及follower加入已经完成选举的系统，此时的同步的要点：阻塞leader处理写请求，完成日志之间的差异同步，还要处理现有进行中的请求的同步，完成同步后，解除阻塞。\n14.2.3 广播阶段，即正常处理客户端的请求，过半响应即可回复客户端。\n14.2.4 日志的恢复和持久化。持久化：每隔一定数量的事务日志持久化一次，leader选举前持久化一次。恢复：简单的认为已写入日志的的事务请求都算作已提交的请求（不管之前是否已过半复制），全部执行commit提交。具体的恢复是：先恢复快照日志，然后再应用相应的事务日志\n3. paxos（详见paxos算法证明过程）\n14.3.1 paxos的运作过程：\nPhase 1: (a) 一个proposer选择一个编号为n的议案，向所有的acceptor发送prepare请求\nPhase 1: (b) 如果acceptor已经响应的prepare请求中议案编号都比n小，则它承诺不再响应prepare请求或者accept请求中议案编号小于n的， 并且找出已经accept的最大议案的value返回给该proposer。如果已响应的编号比n大，则直接忽略该prepare请求。\nPhase 2：(a) 如果proposer收到了过半的acceptors响应，那么将提出一个议案（n，v）,v就是上述所有acceptor响应中最大accept议案的value，或者是proposer自己的value。然后将该议案发送给所有的acceptor。这个请求叫做accept请求，这一步才是所谓发送议案请求，而前面的prepare请求更多的是一个构建出最终议案(n,v)的过程。\nPhase 2：(b) acceptor接收到编号为n的议案，如果acceptor还没有对大于n的议案的prepare请求响应过，则acceptor就accept该议案，否则拒绝\n14.3.2 paxos的证明过程：\n1 足够多的问题\n2 acceptor的初始accept\n3 P2-对结果要求\n4 P2a-对acceptor的accept要求\n5 P2b-对proposer提出议案的要求（结果上要求）\n6 P2c-对proposer提出议案的要求（做法上要求）\n7 引出prepare过程和P1a\n8 优化prepare\n14.3.3 base paxos和multi-paxos\n\n### 4 大数据方向\n\n#### 4.1 Hadoop\n1. UserGroupInformation源码解读：JAAS认证、user和group关系的维护\n2. RPC通信的实现\n3. 代理用户的过程\n4. kerberos认证\n\n#### 4.2 MapReduce\n1. MapReduce理论及其对应的接口定义\n\n#### 4.3 HDFS\n1. MapFile、SequenceFile\n2. ACL\n\n#### 4.4 YARN、Mesos 资源调度\n\n#### 4.5 oozie\n1. oozie XCommand设计\n2. DagEngine的实现原理\n\n#### 4.6 Hive\n1. HiveServer2、metatore的thrift RPC通信设计\n2. Hive的优化过程\n3. HiveServer2的认证和授权\n4. metastore的认证和授权\n5. HiveServer2向metatore的用户传递过程\n\n#### 4.7 Hbase\n1. Hbase的整体架构图\n2. Hbase的WAL和MVCC设计\n3. client端的异步批量flush寻找RegionServer的过程\n4. Zookeeper上HBase节点解释\n5. Hbase中的mini、major合并\n6. Region的高可用问题对比kafka分区的高可用实现\n7. RegionServer RPC调用的隔离问题\n8. 数据从内存刷写到HDFS的粒度问题\n9. rowKey的设计\n10. MemStore与LSM\n\n#### 4.8 Spark\n1. 不同的部署方式\n2. SparkSql的实现方式\n3. 。。。","slug":"7Java技术栈","published":1,"updated":"2017-07-20T08:11:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tcaw002fa7xwqjevjhfg","content":"<h3 id=\"1-java基础：\"><a href=\"#1-java基础：\" class=\"headerlink\" title=\"1 java基础：\"></a>1 java基础：</h3><h4 id=\"1-1-算法\"><a href=\"#1-1-算法\" class=\"headerlink\" title=\"1.1 算法\"></a>1.1 算法</h4><ol>\n<li>排序算法：直接插入排序、希尔排序、冒泡排序、快速排序、直接选择排序、堆排序、归并排序、基数排序</li>\n<li>二叉查找树、红黑树、B树、B+树、LSM树（分别有对应的应用，数据库、HBase）</li>\n<li>BitSet解决数据重复和是否存在等问题<a id=\"more\"></a>\n</li>\n</ol>\n<h4 id=\"1-2-基本\"><a href=\"#1-2-基本\" class=\"headerlink\" title=\"1.2 基本\"></a>1.2 基本</h4><ol>\n<li>字符串常量池的迁移</li>\n<li>字符串KMP算法</li>\n<li>equals和hashcode</li>\n<li>泛型、异常、反射</li>\n<li>string的hash算法</li>\n<li>hash冲突的解决办法：拉链法</li>\n<li>foreach循环的原理</li>\n<li>static、final、transient等关键字的作用</li>\n<li>volatile关键字的底层实现原理</li>\n<li>Collections.sort方法使用的是哪种排序方法</li>\n<li>Future接口，常见的线程池中的FutureTask实现等</li>\n<li>string的intern方法的内部细节，jdk1.6和jdk1.7的变化以及内部cpp代码StringTable的实现</li>\n</ol>\n<h4 id=\"1-3-设计模式\"><a href=\"#1-3-设计模式\" class=\"headerlink\" title=\"1.3 设计模式\"></a>1.3 设计模式</h4><ol>\n<li>单例模式</li>\n<li>工厂模式</li>\n<li>装饰者模式</li>\n<li>观察者设计模式</li>\n<li>ThreadLocal设计模式</li>\n<li>其他</li>\n</ol>\n<h4 id=\"1-4-正则表达式\"><a href=\"#1-4-正则表达式\" class=\"headerlink\" title=\"1.4 正则表达式\"></a>1.4 正则表达式</h4><ol>\n<li>捕获组和非捕获组</li>\n<li>贪婪，勉强，独占模式</li>\n</ol>\n<h4 id=\"1-5-java内存模型以及垃圾回收算法\"><a href=\"#1-5-java内存模型以及垃圾回收算法\" class=\"headerlink\" title=\"1.5 java内存模型以及垃圾回收算法\"></a>1.5 java内存模型以及垃圾回收算法</h4><ol>\n<li>类加载机制，也就是双亲委派模型</li>\n<li>java内存分配模型（默认HotSpot）</li>\n<li>线程共享的：堆区、永久区 线程独享的：虚拟机栈、本地方法栈、程序计数器</li>\n<li>内存分配机制：年轻代（Eden区、两个Survivor区）、年老代、永久代以及他们的分配过程</li>\n<li>强引用、软引用、弱引用、虚引用与GC</li>\n<li>happens-before规则</li>\n<li>指令重排序、内存栅栏</li>\n<li>Java 8的内存分代改进</li>\n<li>垃圾回收算法：<br>标记-清除（不足之处：效率不高、内存碎片）<br>复制算法（解决了上述问题，但是内存只能使用一半，针对大部分对象存活时间短的场景，引出了一个默认的8:1:1的改进，缺点是仍然需要借助外界来解决可能承载不下的问题）<br>标记整理</li>\n<li>常用垃圾收集器：<br>新生代：Serial收集器、ParNew收集器、Parallel Scavenge 收集器<br>老年代：Serial Old收集器、Parallel Old收集器、CMS（Concurrent Mark Sweep）收集器、 G1 收集器（跨新生代和老年代）</li>\n<li>常用gc的参数：-Xmn、-Xms、-Xmx、-XX:MaxPermSize、-XX:SurvivorRatio、-XX:-PrintGCDetails</li>\n<li>常用工具： jps、jstat、jmap、jstack、图形工具jConsole、Visual VM、MAT</li>\n</ol>\n<h4 id=\"1-6-锁以及并发容器的源码\"><a href=\"#1-6-锁以及并发容器的源码\" class=\"headerlink\" title=\"1.6 锁以及并发容器的源码\"></a>1.6 锁以及并发容器的源码</h4><ol>\n<li>synchronized和volatile理解</li>\n<li>Unsafe类的原理，使用它来实现CAS。因此诞生了AtomicInteger系列等</li>\n<li>CAS可能产生的ABA问题的解决，如加入修改次数、版本号</li>\n<li>同步器AQS的实现原理</li>\n<li>独占锁、共享锁；可重入的独占锁ReentrantLock、共享锁 实现原理</li>\n<li>公平锁和非公平锁</li>\n<li>读写锁 ReentrantReadWriteLock的实现原理</li>\n<li>LockSupport工具</li>\n<li>Condition接口及其实现原理</li>\n<li>HashMap、HashSet、ArrayList、LinkedList、HashTable、ConcurrentHashMap、TreeMap的实现原理</li>\n<li>HashMap的并发问题</li>\n<li>ConcurrentLinkedQueue的实现原理</li>\n<li>Fork/Join框架</li>\n<li>CountDownLatch和CyclicBarrier</li>\n</ol>\n<h4 id=\"1-7-线程池源码\"><a href=\"#1-7-线程池源码\" class=\"headerlink\" title=\"1.7 线程池源码\"></a>1.7 线程池源码</h4><ol>\n<li>内部执行原理</li>\n<li>各种线程池的区别</li>\n</ol>\n<h3 id=\"2-web方面：\"><a href=\"#2-web方面：\" class=\"headerlink\" title=\"2 web方面：\"></a>2 web方面：</h3><h4 id=\"2-1-SpringMVC的架构设计\"><a href=\"#2-1-SpringMVC的架构设计\" class=\"headerlink\" title=\"2.1 SpringMVC的架构设计\"></a>2.1 SpringMVC的架构设计</h4><ol>\n<li>servlet开发存在的问题：映射问题、参数获取问题、格式化转换问题、返回值处理问题、视图渲染问题</li>\n<li>SpringMVC为解决上述问题开发的几大组件及接口：HandlerMapping、HandlerAdapter、HandlerMethodArgumentResolver、HttpMessageConverter、Converter、GenericConverter、HandlerMethodReturnValueHandler、ViewResolver、MultipartResolver</li>\n<li>DispatcherServlet、容器、组件三者之间的关系</li>\n<li>叙述SpringMVC对请求的整体处理流程</li>\n<li>SpringBoot</li>\n</ol>\n<h4 id=\"2-2-SpringAOP源码\"><a href=\"#2-2-SpringAOP源码\" class=\"headerlink\" title=\"2.2 SpringAOP源码\"></a>2.2 SpringAOP源码</h4><ol>\n<li>AOP的实现分类：编译期、字节码加载前、字节码加载后三种时机来实现AOP</li>\n<li>深刻理解其中的角色：AOP联盟、aspectj、jboss AOP、Spring自身实现的AOP、Spring嵌入aspectj。特别是能用代码区分后两者</li>\n<li>接口设计：<br>AOP联盟定义的概念或接口：Pointcut（概念，没有定义对应的接口）、Joinpoint、Advice、MethodInterceptor、MethodInvocation<br>SpringAOP针对上述Advice接口定义的接口及其实现类：BeforeAdvice、AfterAdvice、MethodBeforeAdvice、AfterReturningAdvice；针对aspectj对上述接口的实现AspectJMethodBeforeAdvice、AspectJAfterReturningAdvice、AspectJAfterThrowingAdvice、AspectJAfterAdvice。<br>SpringAOP定义的定义的AdvisorAdapter接口：将上述Advise转化为MethodInterceptor<br>SpringAOP定义的Pointcut接口：含有两个属性ClassFilter（过滤类）、MethodMatcher（过滤方法）<br>SpringAOP定义的ExpressionPointcut接口：实现中会引入aspectj的pointcut表达式<br>SpringAOP定义的PointcutAdvisor接口（将上述Advice接口和Pointcut接口结合起来）</li>\n<li>SpringAOP的调用流程</li>\n<li>SpringAOP自己的实现方式（代表人物ProxyFactoryBean）和借助aspectj实现方式区分</li>\n</ol>\n<h4 id=\"2-3-Spring事务体系源码以及分布式事务Jotm-Atomikos源码实现\"><a href=\"#2-3-Spring事务体系源码以及分布式事务Jotm-Atomikos源码实现\" class=\"headerlink\" title=\"2.3 Spring事务体系源码以及分布式事务Jotm Atomikos源码实现\"></a>2.3 Spring事务体系源码以及分布式事务Jotm Atomikos源码实现</h4><ol>\n<li>jdbc事务存在的问题</li>\n<li>Hibernate对事务的改进</li>\n<li>针对各种各样的事务，Spring如何定义事务体系的接口，以及如何融合jdbc事务和Hibernate事务的</li>\n<li>三种事务模型包含的角色以及各自的职责</li>\n<li>事务代码也业务代码分离的实现（AOP+ThreadLocal来实现）</li>\n<li>Spring事务拦截器TransactionInterceptor全景</li>\n<li>X/Open DTP模型，两阶段提交，JTA接口定义</li>\n<li>Jotm、Atomikos的实现原理</li>\n<li>事务的传播属性</li>\n<li>PROPAGATION_REQUIRES_NEW、PROPAGATION_NESTED的实现原理以及区别</li>\n<li>事物的挂起和恢复的原理</li>\n</ol>\n<h4 id=\"2-4-数据库隔离级别\"><a href=\"#2-4-数据库隔离级别\" class=\"headerlink\" title=\"2.4 数据库隔离级别\"></a>2.4 数据库隔离级别</h4><ol>\n<li>Read uncommitted：读未提交</li>\n<li>Read committed ： 读已提交</li>\n<li>Repeatable read：可重复读</li>\n<li>Serializable ：串行化</li>\n</ol>\n<h4 id=\"2-5-数据库\"><a href=\"#2-5-数据库\" class=\"headerlink\" title=\"2.5 数据库\"></a>2.5 数据库</h4><ol>\n<li>数据库性能的优化</li>\n<li>深入理解mysql的Record Locks、Gap Locks、Next-Key Locks<br>例如下面的在什么情况下会出现死锁：<br>start transaction; DELETE FROM t WHERE id =6; INSERT INTO t VALUES(6); commit;</li>\n<li>insert into select语句的加锁情况</li>\n<li>事务的ACID特性概念</li>\n<li>innodb的MVCC理解</li>\n<li>undo redo binlog</li>\n<li>undo redo 都可以实现持久化，他们的流程是什么？为什么选用redo来做持久化？</li>\n<li>undo、redo结合起来实现原子性和持久化，为什么undo log要先于redo log持久化？</li>\n<li>undo为什么要依赖redo？</li>\n<li>日志内容可以是物理日志，也可以是逻辑日志？他们各自的优点和缺点是？</li>\n<li>redo log最终采用的是物理日志加逻辑日志，物理到page，page内逻辑。还存在什么问题？怎么解决？Double Write</li>\n<li>undo log为什么不采用物理日志而采用逻辑日志？</li>\n<li>为什么要引入Checkpoint？</li>\n<li>引入Checkpoint后为了保证一致性需要阻塞用户操作一段时间，怎么解决这个问题？（这个问题还是很有普遍性的，redis、ZooKeeper都有类似的情况以及不同的应对策略）又有了同步Checkpoint和异步Checkpoint</li>\n<li>开启binlog的情况下，事务内部2PC的一般过程（含有2次持久化，redo log和binlog的持久化）</li>\n<li>解释上述过程，为什么binlog的持久化要在redo log之后，在存储引擎commit之前？</li>\n<li>为什么要保持事务之间写入binlog和执行存储引擎commit操作的顺序性？（即先写入binlog日志的事务一定先commit）</li>\n<li>为了保证上述顺序性，之前的办法是加锁prepare_commit_mutex，但是这极大的降低了事务的效率，怎么来实现binlog的group commit？</li>\n<li>怎么将redo log的持久化也实现group commit？至此事务内部2PC的过程，2次持久化的操作都可以group commit了，极大提高了效率</li>\n</ol>\n<h4 id=\"2-6-ORM框架-mybatis、Hibernate\"><a href=\"#2-6-ORM框架-mybatis、Hibernate\" class=\"headerlink\" title=\"2.6 ORM框架: mybatis、Hibernate\"></a>2.6 ORM框架: mybatis、Hibernate</h4><ol>\n<li>最原始的jdbc-&gt;Spring的JdbcTemplate-&gt;hibernate-&gt;JPA-&gt;SpringDataJPA的演进之路</li>\n</ol>\n<h4 id=\"2-7-SpringSecurity、shiro、SSO（单点登录）\"><a href=\"#2-7-SpringSecurity、shiro、SSO（单点登录）\" class=\"headerlink\" title=\"2.7 SpringSecurity、shiro、SSO（单点登录）\"></a>2.7 SpringSecurity、shiro、SSO（单点登录）</h4><ol>\n<li>Session和Cookie的区别和联系以及Session的实现原理</li>\n<li>SpringSecurity的认证过程以及与Session的关系</li>\n<li>CAS实现SSO（详见Cas（01）——简介）输入图片说明</li>\n</ol>\n<h4 id=\"2-8-日志\"><a href=\"#2-8-日志\" class=\"headerlink\" title=\"2.8 日志\"></a>2.8 日志</h4><ol>\n<li>jdk自带的logging、log4j、log4j2、logback</li>\n<li>门面commons-logging、slf4j</li>\n<li>上述6种混战时的日志转换</li>\n</ol>\n<h4 id=\"2-9-datasource\"><a href=\"#2-9-datasource\" class=\"headerlink\" title=\"2.9 datasource\"></a>2.9 datasource</h4><ol>\n<li>c3p0</li>\n<li>druid</li>\n<li>JdbcTemplate执行sql语句的过程中对Connection的使用和管理</li>\n</ol>\n<h4 id=\"2-10-HTTPS的实现原理\"><a href=\"#2-10-HTTPS的实现原理\" class=\"headerlink\" title=\"2.10 HTTPS的实现原理\"></a>2.10 HTTPS的实现原理</h4><h3 id=\"3-分布式、java中间件、web服务器等方面：\"><a href=\"#3-分布式、java中间件、web服务器等方面：\" class=\"headerlink\" title=\"3 分布式、java中间件、web服务器等方面：\"></a>3 分布式、java中间件、web服务器等方面：</h3><h4 id=\"3-1-ZooKeeper源码\"><a href=\"#3-1-ZooKeeper源码\" class=\"headerlink\" title=\"3.1 ZooKeeper源码\"></a>3.1 ZooKeeper源码</h4><ol>\n<li>客户端架构</li>\n<li>服务器端单机版和集群版，对应的请求处理器</li>\n<li>集群版session的建立和激活过程</li>\n<li>Leader选举过程</li>\n<li>事务日志和快照文件的详细解析</li>\n<li>实现分布式锁、分布式ID分发器</li>\n<li>实现Leader选举</li>\n<li>ZAB协议实现一致性原理</li>\n</ol>\n<h4 id=\"3-2-序列化和反序列化框架\"><a href=\"#3-2-序列化和反序列化框架\" class=\"headerlink\" title=\"3.2 序列化和反序列化框架\"></a>3.2 序列化和反序列化框架</h4><ol>\n<li>Avro研究</li>\n<li>Thrift研究</li>\n<li>Protobuf研究</li>\n<li>Protostuff研究</li>\n<li>Hessian</li>\n</ol>\n<h4 id=\"3-3-RPC框架dubbo源码\"><a href=\"#3-3-RPC框架dubbo源码\" class=\"headerlink\" title=\"3.3 RPC框架dubbo源码\"></a>3.3 RPC框架dubbo源码</h4><ol>\n<li>dubbo扩展机制的实现，对比SPI机制</li>\n<li>服务的发布过程</li>\n<li>服务的订阅过程</li>\n<li>RPC通信的设计</li>\n</ol>\n<h4 id=\"3-4-NIO模块以及对应的Netty和Mina、thrift源码\"><a href=\"#3-4-NIO模块以及对应的Netty和Mina、thrift源码\" class=\"headerlink\" title=\"3.4 NIO模块以及对应的Netty和Mina、thrift源码\"></a>3.4 NIO模块以及对应的Netty和Mina、thrift源码</h4><ol>\n<li>TCP握手和断开及有限状态机</li>\n<li>backlog</li>\n<li>BIO NIO</li>\n<li>阻塞/非阻塞的区别、同步/异步的区别</li>\n<li>阻塞IO、非阻塞IO、多路复用IO、异步IO</li>\n<li>Reactor线程模型</li>\n<li>jdk的poll、epoll与底层poll、epoll的对接实现</li>\n<li>Netty自己的epoll实现</li>\n<li>内核层poll、epoll的大致实现</li>\n<li>epoll的边缘触发和水平触发</li>\n<li>Netty的EventLoopGroup设计</li>\n<li>Netty的ByteBuf设计</li>\n<li>Netty的ChannelHandler</li>\n<li>Netty的零拷贝</li>\n<li>Netty的线程模型，特别是与业务线程以及资源释放方面的理解</li>\n</ol>\n<h4 id=\"3-5-消息队列kafka、RocketMQ、Notify、Hermes\"><a href=\"#3-5-消息队列kafka、RocketMQ、Notify、Hermes\" class=\"headerlink\" title=\"3.5 消息队列kafka、RocketMQ、Notify、Hermes\"></a>3.5 消息队列kafka、RocketMQ、Notify、Hermes</h4><ol>\n<li>kafka的文件存储设计</li>\n<li>kafka的副本复制过程</li>\n<li>kafka副本的leader选举过程</li>\n<li>kafka的消息丢失问题</li>\n<li>kafka的消息顺序性问题</li>\n<li>kafka的isr设计和过半对比</li>\n<li>kafka本身做的很轻量级来保持高效，很多高级特性没有：事务、优先级的消息、消息的过滤，更重要的是服务治理不健全，一旦出问题，不能直观反应出来，不太适合对数据要求十分严苛的企业级系统，而适合日志之类并发量大但是允许少量的丢失或重复等场景</li>\n<li>Notify、RocketMQ的事务设计</li>\n<li>基于文件的kafka、RocketMQ和基于数据库的Notify和Hermes</li>\n<li>设计一个消息系统要考虑哪些方面</li>\n<li>丢失消息、消息重复、高可用等话题</li>\n</ol>\n<h4 id=\"3-6-数据库的分库分表mycat\"><a href=\"#3-6-数据库的分库分表mycat\" class=\"headerlink\" title=\"3.6 数据库的分库分表mycat\"></a>3.6 数据库的分库分表mycat</h4><h4 id=\"3-7-NoSql数据库mongodb\"><a href=\"#3-7-NoSql数据库mongodb\" class=\"headerlink\" title=\"3.7 NoSql数据库mongodb\"></a>3.7 NoSql数据库mongodb</h4><h4 id=\"3-8-KV键值系统memcached-redis\"><a href=\"#3-8-KV键值系统memcached-redis\" class=\"headerlink\" title=\"3.8 KV键值系统memcached redis\"></a>3.8 KV键值系统memcached redis</h4><ol>\n<li>redis对客户端的维护和管理，读写缓冲区</li>\n<li>redis事务的实现</li>\n<li>Jedis客户端的实现</li>\n<li>JedisPool以及ShardedJedisPool的实现</li>\n<li>redis epoll实现，循环中的文件事件和时间事件</li>\n<li>redis的RDB持久化，save和bgsave</li>\n<li>redis AOF命令追加、文件写入、文件同步到磁盘</li>\n<li>redis AOF重写，为了减少阻塞时间采取的措施</li>\n<li>redis的LRU内存回收算法</li>\n<li>redis的master slave复制</li>\n<li>redis的sentinel高可用方案</li>\n<li>redis的cluster分片方案</li>\n</ol>\n<h4 id=\"3-9-web服务器tomcat、ngnix的设计原理\"><a href=\"#3-9-web服务器tomcat、ngnix的设计原理\" class=\"headerlink\" title=\"3.9 web服务器tomcat、ngnix的设计原理\"></a>3.9 web服务器tomcat、ngnix的设计原理</h4><ol>\n<li>tomcat的整体架构设计</li>\n<li>tomcat对通信的并发控制</li>\n<li>http请求到达tomcat的整个处理流程</li>\n</ol>\n<h4 id=\"3-10-ELK日志实时处理查询系统\"><a href=\"#3-10-ELK日志实时处理查询系统\" class=\"headerlink\" title=\"3.10 ELK日志实时处理查询系统\"></a>3.10 ELK日志实时处理查询系统</h4><ol>\n<li>Elasticsearch、Logstash、Kibana</li>\n</ol>\n<h4 id=\"3-11-服务方面\"><a href=\"#3-11-服务方面\" class=\"headerlink\" title=\"3.11 服务方面\"></a>3.11 服务方面</h4><ol>\n<li>SOA与微服务</li>\n<li>服务的合并部署、多版本自动快速切换和回滚<br>详见基于Java容器的多应用部署技术实践</li>\n<li>服务的治理：限流、降级<br>具体见 张开涛大神的架构系列<br>服务限流：令牌桶、漏桶<br>服务降级、服务的熔断、服务的隔离：netflix的hystrix组件</li>\n<li>服务的线性扩展<br>无状态的服务如何做线性扩展：<br>如一般的web应用，直接使用硬件或者软件做负载均衡，简单的轮训机制<br>有状态服务如何做线性扩展：<br>如Redis的扩展：一致性hash，迁移工具</li>\n<li>服务链路监控和报警：CAT、Dapper、Pinpoint</li>\n</ol>\n<h4 id=\"3-12-Spring-Cloud\"><a href=\"#3-12-Spring-Cloud\" class=\"headerlink\" title=\"3.12 Spring Cloud\"></a>3.12 Spring Cloud</h4><ol>\n<li>Spring Cloud Zookeeper:用于服务注册和发现</li>\n<li>Spring Cloud Config:分布式配置</li>\n<li>Spring Cloud Netflix Eureka：用于rest服务的注册和发现</li>\n<li>Spring Cloud Netflix Hystrix：服务的隔离、熔断和降级</li>\n<li>Spring Cloud Netflix Zuul:动态路由，API Gateway</li>\n</ol>\n<h4 id=\"3-13-分布式事务\"><a href=\"#3-13-分布式事务\" class=\"headerlink\" title=\"3.13 分布式事务\"></a>3.13 分布式事务</h4><ol>\n<li>JTA分布式事务接口定义，对此与Spring事务体系的整合</li>\n<li>TCC分布式事务概念</li>\n<li>TCC分布式事务实现框架案例1：tcc-transaction<br>13.3.1 TccCompensableAspect切面拦截创建ROOT事务<br>13.3.2 TccTransactionContextAspect切面使远程RPC调用资源加入到上述事务中，作为一个参与者<br>13.3.3 TccCompensableAspect切面根据远程RPC传递的TransactionContext的标记创建出分支事务<br>13.3.4 全部RPC调用完毕，ROOT事务开始提交或者回滚，执行所有参与者的提交或回滚<br>13.3.5 所有参与者的提交或者回滚，还是通过远程RPC调用，provider端开始执行对应分支事务的confirm或者cancel方法<br>13.3.6 事务的存储，集群共享问题<br>13.3.7 事务的恢复，避免集群重复恢复</li>\n<li>TCC分布式事务实现框架案例2：ByteTCC<br>13.4.1 JTA事务管理实现，类比Jotm、Atomikos等JTA实现<br>13.4.2 事务的存储和恢复，集群是否共享问题<br>调用方创建CompensableTransaction事务，并加入资源<br>13.4.3 CompensableMethodInterceptor拦截器向spring事务注入CompensableInvocation资源<br>13.4.4 Spring的分布式事务管理器创建作为协调者CompensableTransaction类型事务，和当前线程进行绑定，同时创建一个jta事务<br>13.4.5 在执行sql等操作的时候，所使用的jdbc等XAResource资源加入上述jta事务<br>13.4.6 dubbo RPC远程调用前，CompensableDubboServiceFilter创建出一个代理XAResource，加入上述CompensableTransaction类型事务，并在RPC调用过程传递TransactionContext<br>参与方创建分支的CompensableTransaction事务，并加入资源，然后提交jta事务<br>13.4.7 RPC远程调用来到provider端，CompensableDubboServiceFilter根据传递过来的TransactionContext创建出对应的CompensableTransaction类型事务<br>13.4.8 provider端，执行时遇见@Transactional和@Compensable，作为一个参与者开启try阶段的事务，即创建了一个jta事务<br>13.4.9 provider端try执行完毕开始准备try的提交，仅仅是提交上述jta事务，返回结果到RPC调用端<br>调用方决定回滚还是提交<br>13.4.10 全部执行完毕后开始事务的提交或者回滚，如果是提交则先对jta事务进行提交（包含jdbc等XAResource资源的提交），提交成功后再对CompensableTransaction类型事务进行提交，如果jta事务提交失败，则需要回滚CompensableTransaction类型事务。<br>13.4.11 CompensableTransaction类型事务的提交就是对CompensableInvocation资源和RPC资源的提交，分别调用每一个CompensableInvocation资源的confirm，以及每一个RPC资源的提交<br>CompensableInvocation资源的提交<br>13.4.12 此时每一个CompensableInvocation资源的confirm又会准备开启一个新的事务，当前线程的CompensableTransaction类型事务已存在，所以这里开启事务仅仅是创建了一个新的jta事务而已<br>13.4.13 针对此，每一个CompensableInvocation资源的confirm开启的事务，又开始重复上述过程，对于jdbc等资源都加入新创建的jta事务中，而RPC资源和CompensableInvocation资源仍然加入到当前线程绑定的CompensableTransaction类型事务<br>13.4.14 当前CompensableInvocation资源的confirm开启的事务执行完毕后，开始执行commit,此时仍然是执行jta事务的提交，提交完毕，一个CompensableInvocation资源的confirm完成，继续执行下一个CompensableInvocation资源的confirm，即又要重新开启一个新的jta事务<br>RPC资源的提交（参与方CompensableTransaction事务的提交）<br>13.4.15 当所有CompensableInvocation资源的confirm执行完毕，开始执行RPC资源的commit，会进行远程调用，执行远程provider分支事务的提交，远程调用过程会传递事务id<br>13.4.16 provider端，根据传递过来的事务id找到对应的CompensableTransaction事务，开始执行提交操作，提交操作完成后返回响应<br>结束<br>13.4.17 协调者收到响应后继续执行下一个RPC资源的提交，当所有RPC资源也完成相应的提交，则协调者算是彻底完成该事务</li>\n</ol>\n<h4 id=\"3-14-一致性算法\"><a href=\"#3-14-一致性算法\" class=\"headerlink\" title=\"3.14 一致性算法\"></a>3.14 一致性算法</h4><ol>\n<li>raft（详见Raft算法赏析）<br>14.1.1 leader选举过程，leader选举约束，要包含所有commited entries，实现上log比过半的log都最新即可<br>14.1.2 log复制过程，leader给所有的follower发送AppendEntries RPC请求，过半follower回复ok，则可提交该entry，然后向客户端响应OK<br>14.1.3 在上述leader收到过半复制之后，挂了，则后续leader不能直接对这些之前term的过半entry进行提交（这一部分有详细的案例来证明，并能说出根本原因），目前做法是在当前term中创建空的entry，然后如果这些新创建的entry被大部分复制了，则此时就可以对之前term的过半entry进行提交了<br>14.1.4 leader一旦认为某个term可以提交了，则更新自己的commitIndex，同时应用entry到状态机中，然后在下一次与follower的heartbeat通信中，将leader的commitIndex带给follower，让他们进行更新，同时应用entry到他们的状态机中<br>14.1.5 从上述流程可以看到，作为client来说，可能会出现这样的情况：leader认为某次client的请求可以提交了（对应的entry已经被过半复制了），此时leader挂了，还没来得及给client回复，也就是说对client来说，请求虽然失败了，但是请求对应的entry却被持久化保存了，但是有的时候却是请求失败了（过半都没复制成功）没有持久化成功，也就是说请求失败了，服务器端可能成功了也可能失败了。所以这时候需要在client端下功夫，即cleint端重试的时候仍然使用之前的请求数据进行重试，而不是采用新的数据进行重试，服务器端也必须要实现幂等。<br>14.1.6 Cluster membership changes</li>\n<li>ZooKeeper使用的ZAB协议（详见ZooKeeper的一致性算法赏析）<br>14.2.1 leader选举过程。要点：对于不同状态下的server的投票的收集，投票是需要选举出一个包含所有日志的server来作为leader<br>14.2.2 leader和follower数据同步过程，全量同步、差异同步、日志之间的纠正和截断，来保证和leader之间的一致性。以及follower加入已经完成选举的系统，此时的同步的要点：阻塞leader处理写请求，完成日志之间的差异同步，还要处理现有进行中的请求的同步，完成同步后，解除阻塞。<br>14.2.3 广播阶段，即正常处理客户端的请求，过半响应即可回复客户端。<br>14.2.4 日志的恢复和持久化。持久化：每隔一定数量的事务日志持久化一次，leader选举前持久化一次。恢复：简单的认为已写入日志的的事务请求都算作已提交的请求（不管之前是否已过半复制），全部执行commit提交。具体的恢复是：先恢复快照日志，然后再应用相应的事务日志</li>\n<li>paxos（详见paxos算法证明过程）<br>14.3.1 paxos的运作过程：<br>Phase 1: (a) 一个proposer选择一个编号为n的议案，向所有的acceptor发送prepare请求<br>Phase 1: (b) 如果acceptor已经响应的prepare请求中议案编号都比n小，则它承诺不再响应prepare请求或者accept请求中议案编号小于n的， 并且找出已经accept的最大议案的value返回给该proposer。如果已响应的编号比n大，则直接忽略该prepare请求。<br>Phase 2：(a) 如果proposer收到了过半的acceptors响应，那么将提出一个议案（n，v）,v就是上述所有acceptor响应中最大accept议案的value，或者是proposer自己的value。然后将该议案发送给所有的acceptor。这个请求叫做accept请求，这一步才是所谓发送议案请求，而前面的prepare请求更多的是一个构建出最终议案(n,v)的过程。<br>Phase 2：(b) acceptor接收到编号为n的议案，如果acceptor还没有对大于n的议案的prepare请求响应过，则acceptor就accept该议案，否则拒绝<br>14.3.2 paxos的证明过程：<br>1 足够多的问题<br>2 acceptor的初始accept<br>3 P2-对结果要求<br>4 P2a-对acceptor的accept要求<br>5 P2b-对proposer提出议案的要求（结果上要求）<br>6 P2c-对proposer提出议案的要求（做法上要求）<br>7 引出prepare过程和P1a<br>8 优化prepare<br>14.3.3 base paxos和multi-paxos</li>\n</ol>\n<h3 id=\"4-大数据方向\"><a href=\"#4-大数据方向\" class=\"headerlink\" title=\"4 大数据方向\"></a>4 大数据方向</h3><h4 id=\"4-1-Hadoop\"><a href=\"#4-1-Hadoop\" class=\"headerlink\" title=\"4.1 Hadoop\"></a>4.1 Hadoop</h4><ol>\n<li>UserGroupInformation源码解读：JAAS认证、user和group关系的维护</li>\n<li>RPC通信的实现</li>\n<li>代理用户的过程</li>\n<li>kerberos认证</li>\n</ol>\n<h4 id=\"4-2-MapReduce\"><a href=\"#4-2-MapReduce\" class=\"headerlink\" title=\"4.2 MapReduce\"></a>4.2 MapReduce</h4><ol>\n<li>MapReduce理论及其对应的接口定义</li>\n</ol>\n<h4 id=\"4-3-HDFS\"><a href=\"#4-3-HDFS\" class=\"headerlink\" title=\"4.3 HDFS\"></a>4.3 HDFS</h4><ol>\n<li>MapFile、SequenceFile</li>\n<li>ACL</li>\n</ol>\n<h4 id=\"4-4-YARN、Mesos-资源调度\"><a href=\"#4-4-YARN、Mesos-资源调度\" class=\"headerlink\" title=\"4.4 YARN、Mesos 资源调度\"></a>4.4 YARN、Mesos 资源调度</h4><h4 id=\"4-5-oozie\"><a href=\"#4-5-oozie\" class=\"headerlink\" title=\"4.5 oozie\"></a>4.5 oozie</h4><ol>\n<li>oozie XCommand设计</li>\n<li>DagEngine的实现原理</li>\n</ol>\n<h4 id=\"4-6-Hive\"><a href=\"#4-6-Hive\" class=\"headerlink\" title=\"4.6 Hive\"></a>4.6 Hive</h4><ol>\n<li>HiveServer2、metatore的thrift RPC通信设计</li>\n<li>Hive的优化过程</li>\n<li>HiveServer2的认证和授权</li>\n<li>metastore的认证和授权</li>\n<li>HiveServer2向metatore的用户传递过程</li>\n</ol>\n<h4 id=\"4-7-Hbase\"><a href=\"#4-7-Hbase\" class=\"headerlink\" title=\"4.7 Hbase\"></a>4.7 Hbase</h4><ol>\n<li>Hbase的整体架构图</li>\n<li>Hbase的WAL和MVCC设计</li>\n<li>client端的异步批量flush寻找RegionServer的过程</li>\n<li>Zookeeper上HBase节点解释</li>\n<li>Hbase中的mini、major合并</li>\n<li>Region的高可用问题对比kafka分区的高可用实现</li>\n<li>RegionServer RPC调用的隔离问题</li>\n<li>数据从内存刷写到HDFS的粒度问题</li>\n<li>rowKey的设计</li>\n<li>MemStore与LSM</li>\n</ol>\n<h4 id=\"4-8-Spark\"><a href=\"#4-8-Spark\" class=\"headerlink\" title=\"4.8 Spark\"></a>4.8 Spark</h4><ol>\n<li>不同的部署方式</li>\n<li>SparkSql的实现方式</li>\n<li>。。。</li>\n</ol>\n","excerpt":"<h3 id=\"1-java基础：\"><a href=\"#1-java基础：\" class=\"headerlink\" title=\"1 java基础：\"></a>1 java基础：</h3><h4 id=\"1-1-算法\"><a href=\"#1-1-算法\" class=\"headerlink\" title=\"1.1 算法\"></a>1.1 算法</h4><ol>\n<li>排序算法：直接插入排序、希尔排序、冒泡排序、快速排序、直接选择排序、堆排序、归并排序、基数排序</li>\n<li>二叉查找树、红黑树、B树、B+树、LSM树（分别有对应的应用，数据库、HBase）</li>\n<li>BitSet解决数据重复和是否存在等问题</li></ol>","more":"\n\n<h4 id=\"1-2-基本\"><a href=\"#1-2-基本\" class=\"headerlink\" title=\"1.2 基本\"></a>1.2 基本</h4><ol>\n<li>字符串常量池的迁移</li>\n<li>字符串KMP算法</li>\n<li>equals和hashcode</li>\n<li>泛型、异常、反射</li>\n<li>string的hash算法</li>\n<li>hash冲突的解决办法：拉链法</li>\n<li>foreach循环的原理</li>\n<li>static、final、transient等关键字的作用</li>\n<li>volatile关键字的底层实现原理</li>\n<li>Collections.sort方法使用的是哪种排序方法</li>\n<li>Future接口，常见的线程池中的FutureTask实现等</li>\n<li>string的intern方法的内部细节，jdk1.6和jdk1.7的变化以及内部cpp代码StringTable的实现</li>\n</ol>\n<h4 id=\"1-3-设计模式\"><a href=\"#1-3-设计模式\" class=\"headerlink\" title=\"1.3 设计模式\"></a>1.3 设计模式</h4><ol>\n<li>单例模式</li>\n<li>工厂模式</li>\n<li>装饰者模式</li>\n<li>观察者设计模式</li>\n<li>ThreadLocal设计模式</li>\n<li>其他</li>\n</ol>\n<h4 id=\"1-4-正则表达式\"><a href=\"#1-4-正则表达式\" class=\"headerlink\" title=\"1.4 正则表达式\"></a>1.4 正则表达式</h4><ol>\n<li>捕获组和非捕获组</li>\n<li>贪婪，勉强，独占模式</li>\n</ol>\n<h4 id=\"1-5-java内存模型以及垃圾回收算法\"><a href=\"#1-5-java内存模型以及垃圾回收算法\" class=\"headerlink\" title=\"1.5 java内存模型以及垃圾回收算法\"></a>1.5 java内存模型以及垃圾回收算法</h4><ol>\n<li>类加载机制，也就是双亲委派模型</li>\n<li>java内存分配模型（默认HotSpot）</li>\n<li>线程共享的：堆区、永久区 线程独享的：虚拟机栈、本地方法栈、程序计数器</li>\n<li>内存分配机制：年轻代（Eden区、两个Survivor区）、年老代、永久代以及他们的分配过程</li>\n<li>强引用、软引用、弱引用、虚引用与GC</li>\n<li>happens-before规则</li>\n<li>指令重排序、内存栅栏</li>\n<li>Java 8的内存分代改进</li>\n<li>垃圾回收算法：<br>标记-清除（不足之处：效率不高、内存碎片）<br>复制算法（解决了上述问题，但是内存只能使用一半，针对大部分对象存活时间短的场景，引出了一个默认的8:1:1的改进，缺点是仍然需要借助外界来解决可能承载不下的问题）<br>标记整理</li>\n<li>常用垃圾收集器：<br>新生代：Serial收集器、ParNew收集器、Parallel Scavenge 收集器<br>老年代：Serial Old收集器、Parallel Old收集器、CMS（Concurrent Mark Sweep）收集器、 G1 收集器（跨新生代和老年代）</li>\n<li>常用gc的参数：-Xmn、-Xms、-Xmx、-XX:MaxPermSize、-XX:SurvivorRatio、-XX:-PrintGCDetails</li>\n<li>常用工具： jps、jstat、jmap、jstack、图形工具jConsole、Visual VM、MAT</li>\n</ol>\n<h4 id=\"1-6-锁以及并发容器的源码\"><a href=\"#1-6-锁以及并发容器的源码\" class=\"headerlink\" title=\"1.6 锁以及并发容器的源码\"></a>1.6 锁以及并发容器的源码</h4><ol>\n<li>synchronized和volatile理解</li>\n<li>Unsafe类的原理，使用它来实现CAS。因此诞生了AtomicInteger系列等</li>\n<li>CAS可能产生的ABA问题的解决，如加入修改次数、版本号</li>\n<li>同步器AQS的实现原理</li>\n<li>独占锁、共享锁；可重入的独占锁ReentrantLock、共享锁 实现原理</li>\n<li>公平锁和非公平锁</li>\n<li>读写锁 ReentrantReadWriteLock的实现原理</li>\n<li>LockSupport工具</li>\n<li>Condition接口及其实现原理</li>\n<li>HashMap、HashSet、ArrayList、LinkedList、HashTable、ConcurrentHashMap、TreeMap的实现原理</li>\n<li>HashMap的并发问题</li>\n<li>ConcurrentLinkedQueue的实现原理</li>\n<li>Fork/Join框架</li>\n<li>CountDownLatch和CyclicBarrier</li>\n</ol>\n<h4 id=\"1-7-线程池源码\"><a href=\"#1-7-线程池源码\" class=\"headerlink\" title=\"1.7 线程池源码\"></a>1.7 线程池源码</h4><ol>\n<li>内部执行原理</li>\n<li>各种线程池的区别</li>\n</ol>\n<h3 id=\"2-web方面：\"><a href=\"#2-web方面：\" class=\"headerlink\" title=\"2 web方面：\"></a>2 web方面：</h3><h4 id=\"2-1-SpringMVC的架构设计\"><a href=\"#2-1-SpringMVC的架构设计\" class=\"headerlink\" title=\"2.1 SpringMVC的架构设计\"></a>2.1 SpringMVC的架构设计</h4><ol>\n<li>servlet开发存在的问题：映射问题、参数获取问题、格式化转换问题、返回值处理问题、视图渲染问题</li>\n<li>SpringMVC为解决上述问题开发的几大组件及接口：HandlerMapping、HandlerAdapter、HandlerMethodArgumentResolver、HttpMessageConverter、Converter、GenericConverter、HandlerMethodReturnValueHandler、ViewResolver、MultipartResolver</li>\n<li>DispatcherServlet、容器、组件三者之间的关系</li>\n<li>叙述SpringMVC对请求的整体处理流程</li>\n<li>SpringBoot</li>\n</ol>\n<h4 id=\"2-2-SpringAOP源码\"><a href=\"#2-2-SpringAOP源码\" class=\"headerlink\" title=\"2.2 SpringAOP源码\"></a>2.2 SpringAOP源码</h4><ol>\n<li>AOP的实现分类：编译期、字节码加载前、字节码加载后三种时机来实现AOP</li>\n<li>深刻理解其中的角色：AOP联盟、aspectj、jboss AOP、Spring自身实现的AOP、Spring嵌入aspectj。特别是能用代码区分后两者</li>\n<li>接口设计：<br>AOP联盟定义的概念或接口：Pointcut（概念，没有定义对应的接口）、Joinpoint、Advice、MethodInterceptor、MethodInvocation<br>SpringAOP针对上述Advice接口定义的接口及其实现类：BeforeAdvice、AfterAdvice、MethodBeforeAdvice、AfterReturningAdvice；针对aspectj对上述接口的实现AspectJMethodBeforeAdvice、AspectJAfterReturningAdvice、AspectJAfterThrowingAdvice、AspectJAfterAdvice。<br>SpringAOP定义的定义的AdvisorAdapter接口：将上述Advise转化为MethodInterceptor<br>SpringAOP定义的Pointcut接口：含有两个属性ClassFilter（过滤类）、MethodMatcher（过滤方法）<br>SpringAOP定义的ExpressionPointcut接口：实现中会引入aspectj的pointcut表达式<br>SpringAOP定义的PointcutAdvisor接口（将上述Advice接口和Pointcut接口结合起来）</li>\n<li>SpringAOP的调用流程</li>\n<li>SpringAOP自己的实现方式（代表人物ProxyFactoryBean）和借助aspectj实现方式区分</li>\n</ol>\n<h4 id=\"2-3-Spring事务体系源码以及分布式事务Jotm-Atomikos源码实现\"><a href=\"#2-3-Spring事务体系源码以及分布式事务Jotm-Atomikos源码实现\" class=\"headerlink\" title=\"2.3 Spring事务体系源码以及分布式事务Jotm Atomikos源码实现\"></a>2.3 Spring事务体系源码以及分布式事务Jotm Atomikos源码实现</h4><ol>\n<li>jdbc事务存在的问题</li>\n<li>Hibernate对事务的改进</li>\n<li>针对各种各样的事务，Spring如何定义事务体系的接口，以及如何融合jdbc事务和Hibernate事务的</li>\n<li>三种事务模型包含的角色以及各自的职责</li>\n<li>事务代码也业务代码分离的实现（AOP+ThreadLocal来实现）</li>\n<li>Spring事务拦截器TransactionInterceptor全景</li>\n<li>X/Open DTP模型，两阶段提交，JTA接口定义</li>\n<li>Jotm、Atomikos的实现原理</li>\n<li>事务的传播属性</li>\n<li>PROPAGATION_REQUIRES_NEW、PROPAGATION_NESTED的实现原理以及区别</li>\n<li>事物的挂起和恢复的原理</li>\n</ol>\n<h4 id=\"2-4-数据库隔离级别\"><a href=\"#2-4-数据库隔离级别\" class=\"headerlink\" title=\"2.4 数据库隔离级别\"></a>2.4 数据库隔离级别</h4><ol>\n<li>Read uncommitted：读未提交</li>\n<li>Read committed ： 读已提交</li>\n<li>Repeatable read：可重复读</li>\n<li>Serializable ：串行化</li>\n</ol>\n<h4 id=\"2-5-数据库\"><a href=\"#2-5-数据库\" class=\"headerlink\" title=\"2.5 数据库\"></a>2.5 数据库</h4><ol>\n<li>数据库性能的优化</li>\n<li>深入理解mysql的Record Locks、Gap Locks、Next-Key Locks<br>例如下面的在什么情况下会出现死锁：<br>start transaction; DELETE FROM t WHERE id =6; INSERT INTO t VALUES(6); commit;</li>\n<li>insert into select语句的加锁情况</li>\n<li>事务的ACID特性概念</li>\n<li>innodb的MVCC理解</li>\n<li>undo redo binlog</li>\n<li>undo redo 都可以实现持久化，他们的流程是什么？为什么选用redo来做持久化？</li>\n<li>undo、redo结合起来实现原子性和持久化，为什么undo log要先于redo log持久化？</li>\n<li>undo为什么要依赖redo？</li>\n<li>日志内容可以是物理日志，也可以是逻辑日志？他们各自的优点和缺点是？</li>\n<li>redo log最终采用的是物理日志加逻辑日志，物理到page，page内逻辑。还存在什么问题？怎么解决？Double Write</li>\n<li>undo log为什么不采用物理日志而采用逻辑日志？</li>\n<li>为什么要引入Checkpoint？</li>\n<li>引入Checkpoint后为了保证一致性需要阻塞用户操作一段时间，怎么解决这个问题？（这个问题还是很有普遍性的，redis、ZooKeeper都有类似的情况以及不同的应对策略）又有了同步Checkpoint和异步Checkpoint</li>\n<li>开启binlog的情况下，事务内部2PC的一般过程（含有2次持久化，redo log和binlog的持久化）</li>\n<li>解释上述过程，为什么binlog的持久化要在redo log之后，在存储引擎commit之前？</li>\n<li>为什么要保持事务之间写入binlog和执行存储引擎commit操作的顺序性？（即先写入binlog日志的事务一定先commit）</li>\n<li>为了保证上述顺序性，之前的办法是加锁prepare_commit_mutex，但是这极大的降低了事务的效率，怎么来实现binlog的group commit？</li>\n<li>怎么将redo log的持久化也实现group commit？至此事务内部2PC的过程，2次持久化的操作都可以group commit了，极大提高了效率</li>\n</ol>\n<h4 id=\"2-6-ORM框架-mybatis、Hibernate\"><a href=\"#2-6-ORM框架-mybatis、Hibernate\" class=\"headerlink\" title=\"2.6 ORM框架: mybatis、Hibernate\"></a>2.6 ORM框架: mybatis、Hibernate</h4><ol>\n<li>最原始的jdbc-&gt;Spring的JdbcTemplate-&gt;hibernate-&gt;JPA-&gt;SpringDataJPA的演进之路</li>\n</ol>\n<h4 id=\"2-7-SpringSecurity、shiro、SSO（单点登录）\"><a href=\"#2-7-SpringSecurity、shiro、SSO（单点登录）\" class=\"headerlink\" title=\"2.7 SpringSecurity、shiro、SSO（单点登录）\"></a>2.7 SpringSecurity、shiro、SSO（单点登录）</h4><ol>\n<li>Session和Cookie的区别和联系以及Session的实现原理</li>\n<li>SpringSecurity的认证过程以及与Session的关系</li>\n<li>CAS实现SSO（详见Cas（01）——简介）输入图片说明</li>\n</ol>\n<h4 id=\"2-8-日志\"><a href=\"#2-8-日志\" class=\"headerlink\" title=\"2.8 日志\"></a>2.8 日志</h4><ol>\n<li>jdk自带的logging、log4j、log4j2、logback</li>\n<li>门面commons-logging、slf4j</li>\n<li>上述6种混战时的日志转换</li>\n</ol>\n<h4 id=\"2-9-datasource\"><a href=\"#2-9-datasource\" class=\"headerlink\" title=\"2.9 datasource\"></a>2.9 datasource</h4><ol>\n<li>c3p0</li>\n<li>druid</li>\n<li>JdbcTemplate执行sql语句的过程中对Connection的使用和管理</li>\n</ol>\n<h4 id=\"2-10-HTTPS的实现原理\"><a href=\"#2-10-HTTPS的实现原理\" class=\"headerlink\" title=\"2.10 HTTPS的实现原理\"></a>2.10 HTTPS的实现原理</h4><h3 id=\"3-分布式、java中间件、web服务器等方面：\"><a href=\"#3-分布式、java中间件、web服务器等方面：\" class=\"headerlink\" title=\"3 分布式、java中间件、web服务器等方面：\"></a>3 分布式、java中间件、web服务器等方面：</h3><h4 id=\"3-1-ZooKeeper源码\"><a href=\"#3-1-ZooKeeper源码\" class=\"headerlink\" title=\"3.1 ZooKeeper源码\"></a>3.1 ZooKeeper源码</h4><ol>\n<li>客户端架构</li>\n<li>服务器端单机版和集群版，对应的请求处理器</li>\n<li>集群版session的建立和激活过程</li>\n<li>Leader选举过程</li>\n<li>事务日志和快照文件的详细解析</li>\n<li>实现分布式锁、分布式ID分发器</li>\n<li>实现Leader选举</li>\n<li>ZAB协议实现一致性原理</li>\n</ol>\n<h4 id=\"3-2-序列化和反序列化框架\"><a href=\"#3-2-序列化和反序列化框架\" class=\"headerlink\" title=\"3.2 序列化和反序列化框架\"></a>3.2 序列化和反序列化框架</h4><ol>\n<li>Avro研究</li>\n<li>Thrift研究</li>\n<li>Protobuf研究</li>\n<li>Protostuff研究</li>\n<li>Hessian</li>\n</ol>\n<h4 id=\"3-3-RPC框架dubbo源码\"><a href=\"#3-3-RPC框架dubbo源码\" class=\"headerlink\" title=\"3.3 RPC框架dubbo源码\"></a>3.3 RPC框架dubbo源码</h4><ol>\n<li>dubbo扩展机制的实现，对比SPI机制</li>\n<li>服务的发布过程</li>\n<li>服务的订阅过程</li>\n<li>RPC通信的设计</li>\n</ol>\n<h4 id=\"3-4-NIO模块以及对应的Netty和Mina、thrift源码\"><a href=\"#3-4-NIO模块以及对应的Netty和Mina、thrift源码\" class=\"headerlink\" title=\"3.4 NIO模块以及对应的Netty和Mina、thrift源码\"></a>3.4 NIO模块以及对应的Netty和Mina、thrift源码</h4><ol>\n<li>TCP握手和断开及有限状态机</li>\n<li>backlog</li>\n<li>BIO NIO</li>\n<li>阻塞/非阻塞的区别、同步/异步的区别</li>\n<li>阻塞IO、非阻塞IO、多路复用IO、异步IO</li>\n<li>Reactor线程模型</li>\n<li>jdk的poll、epoll与底层poll、epoll的对接实现</li>\n<li>Netty自己的epoll实现</li>\n<li>内核层poll、epoll的大致实现</li>\n<li>epoll的边缘触发和水平触发</li>\n<li>Netty的EventLoopGroup设计</li>\n<li>Netty的ByteBuf设计</li>\n<li>Netty的ChannelHandler</li>\n<li>Netty的零拷贝</li>\n<li>Netty的线程模型，特别是与业务线程以及资源释放方面的理解</li>\n</ol>\n<h4 id=\"3-5-消息队列kafka、RocketMQ、Notify、Hermes\"><a href=\"#3-5-消息队列kafka、RocketMQ、Notify、Hermes\" class=\"headerlink\" title=\"3.5 消息队列kafka、RocketMQ、Notify、Hermes\"></a>3.5 消息队列kafka、RocketMQ、Notify、Hermes</h4><ol>\n<li>kafka的文件存储设计</li>\n<li>kafka的副本复制过程</li>\n<li>kafka副本的leader选举过程</li>\n<li>kafka的消息丢失问题</li>\n<li>kafka的消息顺序性问题</li>\n<li>kafka的isr设计和过半对比</li>\n<li>kafka本身做的很轻量级来保持高效，很多高级特性没有：事务、优先级的消息、消息的过滤，更重要的是服务治理不健全，一旦出问题，不能直观反应出来，不太适合对数据要求十分严苛的企业级系统，而适合日志之类并发量大但是允许少量的丢失或重复等场景</li>\n<li>Notify、RocketMQ的事务设计</li>\n<li>基于文件的kafka、RocketMQ和基于数据库的Notify和Hermes</li>\n<li>设计一个消息系统要考虑哪些方面</li>\n<li>丢失消息、消息重复、高可用等话题</li>\n</ol>\n<h4 id=\"3-6-数据库的分库分表mycat\"><a href=\"#3-6-数据库的分库分表mycat\" class=\"headerlink\" title=\"3.6 数据库的分库分表mycat\"></a>3.6 数据库的分库分表mycat</h4><h4 id=\"3-7-NoSql数据库mongodb\"><a href=\"#3-7-NoSql数据库mongodb\" class=\"headerlink\" title=\"3.7 NoSql数据库mongodb\"></a>3.7 NoSql数据库mongodb</h4><h4 id=\"3-8-KV键值系统memcached-redis\"><a href=\"#3-8-KV键值系统memcached-redis\" class=\"headerlink\" title=\"3.8 KV键值系统memcached redis\"></a>3.8 KV键值系统memcached redis</h4><ol>\n<li>redis对客户端的维护和管理，读写缓冲区</li>\n<li>redis事务的实现</li>\n<li>Jedis客户端的实现</li>\n<li>JedisPool以及ShardedJedisPool的实现</li>\n<li>redis epoll实现，循环中的文件事件和时间事件</li>\n<li>redis的RDB持久化，save和bgsave</li>\n<li>redis AOF命令追加、文件写入、文件同步到磁盘</li>\n<li>redis AOF重写，为了减少阻塞时间采取的措施</li>\n<li>redis的LRU内存回收算法</li>\n<li>redis的master slave复制</li>\n<li>redis的sentinel高可用方案</li>\n<li>redis的cluster分片方案</li>\n</ol>\n<h4 id=\"3-9-web服务器tomcat、ngnix的设计原理\"><a href=\"#3-9-web服务器tomcat、ngnix的设计原理\" class=\"headerlink\" title=\"3.9 web服务器tomcat、ngnix的设计原理\"></a>3.9 web服务器tomcat、ngnix的设计原理</h4><ol>\n<li>tomcat的整体架构设计</li>\n<li>tomcat对通信的并发控制</li>\n<li>http请求到达tomcat的整个处理流程</li>\n</ol>\n<h4 id=\"3-10-ELK日志实时处理查询系统\"><a href=\"#3-10-ELK日志实时处理查询系统\" class=\"headerlink\" title=\"3.10 ELK日志实时处理查询系统\"></a>3.10 ELK日志实时处理查询系统</h4><ol>\n<li>Elasticsearch、Logstash、Kibana</li>\n</ol>\n<h4 id=\"3-11-服务方面\"><a href=\"#3-11-服务方面\" class=\"headerlink\" title=\"3.11 服务方面\"></a>3.11 服务方面</h4><ol>\n<li>SOA与微服务</li>\n<li>服务的合并部署、多版本自动快速切换和回滚<br>详见基于Java容器的多应用部署技术实践</li>\n<li>服务的治理：限流、降级<br>具体见 张开涛大神的架构系列<br>服务限流：令牌桶、漏桶<br>服务降级、服务的熔断、服务的隔离：netflix的hystrix组件</li>\n<li>服务的线性扩展<br>无状态的服务如何做线性扩展：<br>如一般的web应用，直接使用硬件或者软件做负载均衡，简单的轮训机制<br>有状态服务如何做线性扩展：<br>如Redis的扩展：一致性hash，迁移工具</li>\n<li>服务链路监控和报警：CAT、Dapper、Pinpoint</li>\n</ol>\n<h4 id=\"3-12-Spring-Cloud\"><a href=\"#3-12-Spring-Cloud\" class=\"headerlink\" title=\"3.12 Spring Cloud\"></a>3.12 Spring Cloud</h4><ol>\n<li>Spring Cloud Zookeeper:用于服务注册和发现</li>\n<li>Spring Cloud Config:分布式配置</li>\n<li>Spring Cloud Netflix Eureka：用于rest服务的注册和发现</li>\n<li>Spring Cloud Netflix Hystrix：服务的隔离、熔断和降级</li>\n<li>Spring Cloud Netflix Zuul:动态路由，API Gateway</li>\n</ol>\n<h4 id=\"3-13-分布式事务\"><a href=\"#3-13-分布式事务\" class=\"headerlink\" title=\"3.13 分布式事务\"></a>3.13 分布式事务</h4><ol>\n<li>JTA分布式事务接口定义，对此与Spring事务体系的整合</li>\n<li>TCC分布式事务概念</li>\n<li>TCC分布式事务实现框架案例1：tcc-transaction<br>13.3.1 TccCompensableAspect切面拦截创建ROOT事务<br>13.3.2 TccTransactionContextAspect切面使远程RPC调用资源加入到上述事务中，作为一个参与者<br>13.3.3 TccCompensableAspect切面根据远程RPC传递的TransactionContext的标记创建出分支事务<br>13.3.4 全部RPC调用完毕，ROOT事务开始提交或者回滚，执行所有参与者的提交或回滚<br>13.3.5 所有参与者的提交或者回滚，还是通过远程RPC调用，provider端开始执行对应分支事务的confirm或者cancel方法<br>13.3.6 事务的存储，集群共享问题<br>13.3.7 事务的恢复，避免集群重复恢复</li>\n<li>TCC分布式事务实现框架案例2：ByteTCC<br>13.4.1 JTA事务管理实现，类比Jotm、Atomikos等JTA实现<br>13.4.2 事务的存储和恢复，集群是否共享问题<br>调用方创建CompensableTransaction事务，并加入资源<br>13.4.3 CompensableMethodInterceptor拦截器向spring事务注入CompensableInvocation资源<br>13.4.4 Spring的分布式事务管理器创建作为协调者CompensableTransaction类型事务，和当前线程进行绑定，同时创建一个jta事务<br>13.4.5 在执行sql等操作的时候，所使用的jdbc等XAResource资源加入上述jta事务<br>13.4.6 dubbo RPC远程调用前，CompensableDubboServiceFilter创建出一个代理XAResource，加入上述CompensableTransaction类型事务，并在RPC调用过程传递TransactionContext<br>参与方创建分支的CompensableTransaction事务，并加入资源，然后提交jta事务<br>13.4.7 RPC远程调用来到provider端，CompensableDubboServiceFilter根据传递过来的TransactionContext创建出对应的CompensableTransaction类型事务<br>13.4.8 provider端，执行时遇见@Transactional和@Compensable，作为一个参与者开启try阶段的事务，即创建了一个jta事务<br>13.4.9 provider端try执行完毕开始准备try的提交，仅仅是提交上述jta事务，返回结果到RPC调用端<br>调用方决定回滚还是提交<br>13.4.10 全部执行完毕后开始事务的提交或者回滚，如果是提交则先对jta事务进行提交（包含jdbc等XAResource资源的提交），提交成功后再对CompensableTransaction类型事务进行提交，如果jta事务提交失败，则需要回滚CompensableTransaction类型事务。<br>13.4.11 CompensableTransaction类型事务的提交就是对CompensableInvocation资源和RPC资源的提交，分别调用每一个CompensableInvocation资源的confirm，以及每一个RPC资源的提交<br>CompensableInvocation资源的提交<br>13.4.12 此时每一个CompensableInvocation资源的confirm又会准备开启一个新的事务，当前线程的CompensableTransaction类型事务已存在，所以这里开启事务仅仅是创建了一个新的jta事务而已<br>13.4.13 针对此，每一个CompensableInvocation资源的confirm开启的事务，又开始重复上述过程，对于jdbc等资源都加入新创建的jta事务中，而RPC资源和CompensableInvocation资源仍然加入到当前线程绑定的CompensableTransaction类型事务<br>13.4.14 当前CompensableInvocation资源的confirm开启的事务执行完毕后，开始执行commit,此时仍然是执行jta事务的提交，提交完毕，一个CompensableInvocation资源的confirm完成，继续执行下一个CompensableInvocation资源的confirm，即又要重新开启一个新的jta事务<br>RPC资源的提交（参与方CompensableTransaction事务的提交）<br>13.4.15 当所有CompensableInvocation资源的confirm执行完毕，开始执行RPC资源的commit，会进行远程调用，执行远程provider分支事务的提交，远程调用过程会传递事务id<br>13.4.16 provider端，根据传递过来的事务id找到对应的CompensableTransaction事务，开始执行提交操作，提交操作完成后返回响应<br>结束<br>13.4.17 协调者收到响应后继续执行下一个RPC资源的提交，当所有RPC资源也完成相应的提交，则协调者算是彻底完成该事务</li>\n</ol>\n<h4 id=\"3-14-一致性算法\"><a href=\"#3-14-一致性算法\" class=\"headerlink\" title=\"3.14 一致性算法\"></a>3.14 一致性算法</h4><ol>\n<li>raft（详见Raft算法赏析）<br>14.1.1 leader选举过程，leader选举约束，要包含所有commited entries，实现上log比过半的log都最新即可<br>14.1.2 log复制过程，leader给所有的follower发送AppendEntries RPC请求，过半follower回复ok，则可提交该entry，然后向客户端响应OK<br>14.1.3 在上述leader收到过半复制之后，挂了，则后续leader不能直接对这些之前term的过半entry进行提交（这一部分有详细的案例来证明，并能说出根本原因），目前做法是在当前term中创建空的entry，然后如果这些新创建的entry被大部分复制了，则此时就可以对之前term的过半entry进行提交了<br>14.1.4 leader一旦认为某个term可以提交了，则更新自己的commitIndex，同时应用entry到状态机中，然后在下一次与follower的heartbeat通信中，将leader的commitIndex带给follower，让他们进行更新，同时应用entry到他们的状态机中<br>14.1.5 从上述流程可以看到，作为client来说，可能会出现这样的情况：leader认为某次client的请求可以提交了（对应的entry已经被过半复制了），此时leader挂了，还没来得及给client回复，也就是说对client来说，请求虽然失败了，但是请求对应的entry却被持久化保存了，但是有的时候却是请求失败了（过半都没复制成功）没有持久化成功，也就是说请求失败了，服务器端可能成功了也可能失败了。所以这时候需要在client端下功夫，即cleint端重试的时候仍然使用之前的请求数据进行重试，而不是采用新的数据进行重试，服务器端也必须要实现幂等。<br>14.1.6 Cluster membership changes</li>\n<li>ZooKeeper使用的ZAB协议（详见ZooKeeper的一致性算法赏析）<br>14.2.1 leader选举过程。要点：对于不同状态下的server的投票的收集，投票是需要选举出一个包含所有日志的server来作为leader<br>14.2.2 leader和follower数据同步过程，全量同步、差异同步、日志之间的纠正和截断，来保证和leader之间的一致性。以及follower加入已经完成选举的系统，此时的同步的要点：阻塞leader处理写请求，完成日志之间的差异同步，还要处理现有进行中的请求的同步，完成同步后，解除阻塞。<br>14.2.3 广播阶段，即正常处理客户端的请求，过半响应即可回复客户端。<br>14.2.4 日志的恢复和持久化。持久化：每隔一定数量的事务日志持久化一次，leader选举前持久化一次。恢复：简单的认为已写入日志的的事务请求都算作已提交的请求（不管之前是否已过半复制），全部执行commit提交。具体的恢复是：先恢复快照日志，然后再应用相应的事务日志</li>\n<li>paxos（详见paxos算法证明过程）<br>14.3.1 paxos的运作过程：<br>Phase 1: (a) 一个proposer选择一个编号为n的议案，向所有的acceptor发送prepare请求<br>Phase 1: (b) 如果acceptor已经响应的prepare请求中议案编号都比n小，则它承诺不再响应prepare请求或者accept请求中议案编号小于n的， 并且找出已经accept的最大议案的value返回给该proposer。如果已响应的编号比n大，则直接忽略该prepare请求。<br>Phase 2：(a) 如果proposer收到了过半的acceptors响应，那么将提出一个议案（n，v）,v就是上述所有acceptor响应中最大accept议案的value，或者是proposer自己的value。然后将该议案发送给所有的acceptor。这个请求叫做accept请求，这一步才是所谓发送议案请求，而前面的prepare请求更多的是一个构建出最终议案(n,v)的过程。<br>Phase 2：(b) acceptor接收到编号为n的议案，如果acceptor还没有对大于n的议案的prepare请求响应过，则acceptor就accept该议案，否则拒绝<br>14.3.2 paxos的证明过程：<br>1 足够多的问题<br>2 acceptor的初始accept<br>3 P2-对结果要求<br>4 P2a-对acceptor的accept要求<br>5 P2b-对proposer提出议案的要求（结果上要求）<br>6 P2c-对proposer提出议案的要求（做法上要求）<br>7 引出prepare过程和P1a<br>8 优化prepare<br>14.3.3 base paxos和multi-paxos</li>\n</ol>\n<h3 id=\"4-大数据方向\"><a href=\"#4-大数据方向\" class=\"headerlink\" title=\"4 大数据方向\"></a>4 大数据方向</h3><h4 id=\"4-1-Hadoop\"><a href=\"#4-1-Hadoop\" class=\"headerlink\" title=\"4.1 Hadoop\"></a>4.1 Hadoop</h4><ol>\n<li>UserGroupInformation源码解读：JAAS认证、user和group关系的维护</li>\n<li>RPC通信的实现</li>\n<li>代理用户的过程</li>\n<li>kerberos认证</li>\n</ol>\n<h4 id=\"4-2-MapReduce\"><a href=\"#4-2-MapReduce\" class=\"headerlink\" title=\"4.2 MapReduce\"></a>4.2 MapReduce</h4><ol>\n<li>MapReduce理论及其对应的接口定义</li>\n</ol>\n<h4 id=\"4-3-HDFS\"><a href=\"#4-3-HDFS\" class=\"headerlink\" title=\"4.3 HDFS\"></a>4.3 HDFS</h4><ol>\n<li>MapFile、SequenceFile</li>\n<li>ACL</li>\n</ol>\n<h4 id=\"4-4-YARN、Mesos-资源调度\"><a href=\"#4-4-YARN、Mesos-资源调度\" class=\"headerlink\" title=\"4.4 YARN、Mesos 资源调度\"></a>4.4 YARN、Mesos 资源调度</h4><h4 id=\"4-5-oozie\"><a href=\"#4-5-oozie\" class=\"headerlink\" title=\"4.5 oozie\"></a>4.5 oozie</h4><ol>\n<li>oozie XCommand设计</li>\n<li>DagEngine的实现原理</li>\n</ol>\n<h4 id=\"4-6-Hive\"><a href=\"#4-6-Hive\" class=\"headerlink\" title=\"4.6 Hive\"></a>4.6 Hive</h4><ol>\n<li>HiveServer2、metatore的thrift RPC通信设计</li>\n<li>Hive的优化过程</li>\n<li>HiveServer2的认证和授权</li>\n<li>metastore的认证和授权</li>\n<li>HiveServer2向metatore的用户传递过程</li>\n</ol>\n<h4 id=\"4-7-Hbase\"><a href=\"#4-7-Hbase\" class=\"headerlink\" title=\"4.7 Hbase\"></a>4.7 Hbase</h4><ol>\n<li>Hbase的整体架构图</li>\n<li>Hbase的WAL和MVCC设计</li>\n<li>client端的异步批量flush寻找RegionServer的过程</li>\n<li>Zookeeper上HBase节点解释</li>\n<li>Hbase中的mini、major合并</li>\n<li>Region的高可用问题对比kafka分区的高可用实现</li>\n<li>RegionServer RPC调用的隔离问题</li>\n<li>数据从内存刷写到HDFS的粒度问题</li>\n<li>rowKey的设计</li>\n<li>MemStore与LSM</li>\n</ol>\n<h4 id=\"4-8-Spark\"><a href=\"#4-8-Spark\" class=\"headerlink\" title=\"4.8 Spark\"></a>4.8 Spark</h4><ol>\n<li>不同的部署方式</li>\n<li>SparkSql的实现方式</li>\n<li>。。。</li>\n</ol>"},{"title":"网络互连参考模型","date":"2017-05-12T01:45:00.000Z","_content":"邮局实例:\n* 邮局对于写信人来说是下层\n* 运输部门是邮局的下层\n －－下层为上层提供服务\n* 写信人与收信人之间使用相同的语言\n* 邮局之间的约定\n－－同层次之间使用相同的协议\n<!--more-->\n\n```\n偶然间发现这篇博客,解释TCP/IP非常生动形象,并且由浅入深,很赞!\nhttp://blog.csdn.net/hguisu/article/details/7249611\n```","source":"_posts/8网络互连参考模型.md","raw":"---\ntitle: 网络互连参考模型\ndate: 2017-05-12 09:45:00\ntags: 计算机网络\ncategories: \"计算机网络\"\n---\n邮局实例:\n* 邮局对于写信人来说是下层\n* 运输部门是邮局的下层\n －－下层为上层提供服务\n* 写信人与收信人之间使用相同的语言\n* 邮局之间的约定\n－－同层次之间使用相同的协议\n<!--more-->\n\n```\n偶然间发现这篇博客,解释TCP/IP非常生动形象,并且由浅入深,很赞!\nhttp://blog.csdn.net/hguisu/article/details/7249611\n```","slug":"8网络互连参考模型","published":1,"updated":"2017-07-20T08:06:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tcaz002ia7xw9zm916bs","content":"<p>邮局实例:</p>\n<ul>\n<li>邮局对于写信人来说是下层</li>\n<li>运输部门是邮局的下层<br>－－下层为上层提供服务</li>\n<li>写信人与收信人之间使用相同的语言</li>\n<li>邮局之间的约定<br>－－同层次之间使用相同的协议<a id=\"more\"></a>\n</li>\n</ul>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">偶然间发现这篇博客,解释TCP/IP非常生动形象,并且由浅入深,很赞!</div><div class=\"line\"><span class=\"symbol\">http:</span>/<span class=\"regexp\">/blog.csdn.net/hguisu</span><span class=\"regexp\">/article/details</span><span class=\"regexp\">/7249611</span></div></pre></td></tr></table></figure>","excerpt":"<p>邮局实例:</p>\n<ul>\n<li>邮局对于写信人来说是下层</li>\n<li>运输部门是邮局的下层<br>－－下层为上层提供服务</li>\n<li>写信人与收信人之间使用相同的语言</li>\n<li>邮局之间的约定<br>－－同层次之间使用相同的协议</li></ul>","more":"\n\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">偶然间发现这篇博客,解释TCP/IP非常生动形象,并且由浅入深,很赞!</div><div class=\"line\"><span class=\"symbol\">http:</span>/<span class=\"regexp\">/blog.csdn.net/hguisu</span><span class=\"regexp\">/article/details</span><span class=\"regexp\">/7249611</span></div></pre></td></tr></table></figure>"},{"title":"Java集合[Array、Collection、Set、List、Map]","date":"2017-07-18T02:38:21.000Z","toc":true,"_content":"大多数真实应用程序都会处理像文件、变量、来自文件的记录或数据库结果集这样的集合。Java 语言有一个复杂的集合框架，您可以使用它创建和管理各种类型的对象集合。本单元将介绍最常用的集合类并帮助您开始使用它们。\n<!--more-->\n### 1.入门\n\n![Java集合类](http://ol5edn32j.bkt.clouddn.com/262238192165666.jpg)\n\n-------------------\n### 2.数组\n下面介绍stackoverflow中12个关于数组操作得票数最多的问题\n#### 2.1 声明数组\n```\nString[] aArray = new String[5];\nString[] bArray = {\"a\",\"b\",\"c\", \"d\", \"e\"};\nString[] cArray = new String[]{\"a\",\"b\",\"c\",\"d\",\"e\"};\n```\n#### 2.2 输出一个数组\n```\nint[] intArray = { 1, 2, 3, 4, 5 };\nString intArrayString = Arrays.toString(intArray);\n// print directly will print reference value\nSystem.out.println(intArray);\n// [I@7150bd4d\nSystem.out.println(intArrayString);\n// [1, 2, 3, 4, 5]\n```\n#### 2.3 从一个数组创建数组列表\n```\nString[] stringArray = { \"a\", \"b\", \"c\", \"d\", \"e\" };\nArrayList<String> arrayList = new ArrayList<String>(Arrays.asList(stringArray));\nSystem.out.println(arrayList);\n// [a, b, c, d, e]\n```\n#### 2.4 检查一个数组是否包含某个值\n```\nString[] stringArray = { \"a\", \"b\", \"c\", \"d\", \"e\" };\nboolean b = Arrays.asList(stringArray).contains(\"a\");\nSystem.out.println(b);\n// true\n```\n#### 2.5 连接连个数组\n```\nint[] intArray = { 1, 2, 3, 4, 5 };\nint[] intArray2 = { 6, 7, 8, 9, 10 };\n// Apache Commons Lang library\nint[] combinedIntArray = ArrayUtils.addAll(intArray, intArray2);\n```\n#### 2.6 声明一个内联数组（Array inline）\n```\nmethod(new String[]{\"a\", \"b\", \"c\", \"d\", \"e\"});\n```\n#### 2.7 把提供的数组元素放入一个字符串\n```\n// containing the provided list of elements\n// Apache common lang\nString j = StringUtils.join(new String[] { \"a\", \"b\", \"c\" }, \"-\");\nSystem.out.println(j);\n// a-b-c\n```\n#### 2.8 将一个数组列表转换为数组\n```\nString[] stringArray = { \"a\", \"b\", \"c\", \"d\", \"e\" };\nArrayList<String> arrayList = new ArrayList<String>(Arrays.asList(stringArray));\nString[] stringArr = new String[arrayList.size()];\narrayList.toArray(stringArr);\nfor (String s : stringArr)\n    System.out.println(s);\n```\n#### 2.9 将一个数组列表转换集(Set)\n```\nString[] stringArray = { \"a\", \"b\", \"c\", \"d\", \"e\" };\nArrayList<String> arrayList = new ArrayList<String>(Arrays.asList(stringArray));\nString[] stringArr = new String[arrayList.size()];\narrayList.toArray(stringArr);\nfor (String s : stringArr)\n    System.out.println(s);\n```\n#### 2.10 逆向一个数组\n```\nint[] intArray = { 1, 2, 3, 4, 5 };\nArrayUtils.reverse(intArray);\nSystem.out.println(Arrays.toString(intArray));\n//[5, 4, 3, 2, 1]\n```\n#### 2.11 移除数组中的元素\n```\nint[] intArray = { 1, 2, 3, 4, 5 };\nint[] removed = ArrayUtils.removeElement(intArray, 3);//create a new array\nSystem.out.println(Arrays.toString(removed));\n```\n#### 2.12 移除数组中的元素\n```\nbyte[] bytes = ByteBuffer.allocate(4).putInt(8).array();\nfor (byte t : bytes) {\n   System.out.format(\"0x%x \", t);\n}\n```\n#### 2.12 数组其他知识\n1. [for和foreach的性能对比](http://www.cnblogs.com/suneryong/p/6520442.html)\n\n### 3.Collection\n\n\n### 4.Map\n\n\n### 5.List\n\n\n#### 6.Set\n\n","source":"_posts/9Java集合.md","raw":"---\ntitle: Java集合[Array、Collection、Set、List、Map]\ndate: 2017-07-18 10:38:21\ntags: Java\ncategories: \"Java\"\ntoc: true\n---\n大多数真实应用程序都会处理像文件、变量、来自文件的记录或数据库结果集这样的集合。Java 语言有一个复杂的集合框架，您可以使用它创建和管理各种类型的对象集合。本单元将介绍最常用的集合类并帮助您开始使用它们。\n<!--more-->\n### 1.入门\n\n![Java集合类](http://ol5edn32j.bkt.clouddn.com/262238192165666.jpg)\n\n-------------------\n### 2.数组\n下面介绍stackoverflow中12个关于数组操作得票数最多的问题\n#### 2.1 声明数组\n```\nString[] aArray = new String[5];\nString[] bArray = {\"a\",\"b\",\"c\", \"d\", \"e\"};\nString[] cArray = new String[]{\"a\",\"b\",\"c\",\"d\",\"e\"};\n```\n#### 2.2 输出一个数组\n```\nint[] intArray = { 1, 2, 3, 4, 5 };\nString intArrayString = Arrays.toString(intArray);\n// print directly will print reference value\nSystem.out.println(intArray);\n// [I@7150bd4d\nSystem.out.println(intArrayString);\n// [1, 2, 3, 4, 5]\n```\n#### 2.3 从一个数组创建数组列表\n```\nString[] stringArray = { \"a\", \"b\", \"c\", \"d\", \"e\" };\nArrayList<String> arrayList = new ArrayList<String>(Arrays.asList(stringArray));\nSystem.out.println(arrayList);\n// [a, b, c, d, e]\n```\n#### 2.4 检查一个数组是否包含某个值\n```\nString[] stringArray = { \"a\", \"b\", \"c\", \"d\", \"e\" };\nboolean b = Arrays.asList(stringArray).contains(\"a\");\nSystem.out.println(b);\n// true\n```\n#### 2.5 连接连个数组\n```\nint[] intArray = { 1, 2, 3, 4, 5 };\nint[] intArray2 = { 6, 7, 8, 9, 10 };\n// Apache Commons Lang library\nint[] combinedIntArray = ArrayUtils.addAll(intArray, intArray2);\n```\n#### 2.6 声明一个内联数组（Array inline）\n```\nmethod(new String[]{\"a\", \"b\", \"c\", \"d\", \"e\"});\n```\n#### 2.7 把提供的数组元素放入一个字符串\n```\n// containing the provided list of elements\n// Apache common lang\nString j = StringUtils.join(new String[] { \"a\", \"b\", \"c\" }, \"-\");\nSystem.out.println(j);\n// a-b-c\n```\n#### 2.8 将一个数组列表转换为数组\n```\nString[] stringArray = { \"a\", \"b\", \"c\", \"d\", \"e\" };\nArrayList<String> arrayList = new ArrayList<String>(Arrays.asList(stringArray));\nString[] stringArr = new String[arrayList.size()];\narrayList.toArray(stringArr);\nfor (String s : stringArr)\n    System.out.println(s);\n```\n#### 2.9 将一个数组列表转换集(Set)\n```\nString[] stringArray = { \"a\", \"b\", \"c\", \"d\", \"e\" };\nArrayList<String> arrayList = new ArrayList<String>(Arrays.asList(stringArray));\nString[] stringArr = new String[arrayList.size()];\narrayList.toArray(stringArr);\nfor (String s : stringArr)\n    System.out.println(s);\n```\n#### 2.10 逆向一个数组\n```\nint[] intArray = { 1, 2, 3, 4, 5 };\nArrayUtils.reverse(intArray);\nSystem.out.println(Arrays.toString(intArray));\n//[5, 4, 3, 2, 1]\n```\n#### 2.11 移除数组中的元素\n```\nint[] intArray = { 1, 2, 3, 4, 5 };\nint[] removed = ArrayUtils.removeElement(intArray, 3);//create a new array\nSystem.out.println(Arrays.toString(removed));\n```\n#### 2.12 移除数组中的元素\n```\nbyte[] bytes = ByteBuffer.allocate(4).putInt(8).array();\nfor (byte t : bytes) {\n   System.out.format(\"0x%x \", t);\n}\n```\n#### 2.12 数组其他知识\n1. [for和foreach的性能对比](http://www.cnblogs.com/suneryong/p/6520442.html)\n\n### 3.Collection\n\n\n### 4.Map\n\n\n### 5.List\n\n\n#### 6.Set\n\n","slug":"9Java集合","published":1,"updated":"2017-07-20T08:08:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpv4tcb1002ma7xw20dwofxx","content":"<p>大多数真实应用程序都会处理像文件、变量、来自文件的记录或数据库结果集这样的集合。Java 语言有一个复杂的集合框架，您可以使用它创建和管理各种类型的对象集合。本单元将介绍最常用的集合类并帮助您开始使用它们。<br><a id=\"more\"></a></p>\n<h3 id=\"1-入门\"><a href=\"#1-入门\" class=\"headerlink\" title=\"1.入门\"></a>1.入门</h3><p><img src=\"http://ol5edn32j.bkt.clouddn.com/262238192165666.jpg\" alt=\"Java集合类\"></p>\n<hr>\n<h3 id=\"2-数组\"><a href=\"#2-数组\" class=\"headerlink\" title=\"2.数组\"></a>2.数组</h3><p>下面介绍stackoverflow中12个关于数组操作得票数最多的问题</p>\n<h4 id=\"2-1-声明数组\"><a href=\"#2-1-声明数组\" class=\"headerlink\" title=\"2.1 声明数组\"></a>2.1 声明数组</h4><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">String</span>[] aArray = <span class=\"keyword\">new</span> <span class=\"keyword\">String</span>[<span class=\"number\">5</span>];</div><div class=\"line\"><span class=\"keyword\">String</span>[] bArray = &#123;<span class=\"string\">\"a\"</span>,<span class=\"string\">\"b\"</span>,<span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"e\"</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">String</span>[] cArray = <span class=\"keyword\">new</span> <span class=\"keyword\">String</span>[]&#123;<span class=\"string\">\"a\"</span>,<span class=\"string\">\"b\"</span>,<span class=\"string\">\"c\"</span>,<span class=\"string\">\"d\"</span>,<span class=\"string\">\"e\"</span>&#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"2-2-输出一个数组\"><a href=\"#2-2-输出一个数组\" class=\"headerlink\" title=\"2.2 输出一个数组\"></a>2.2 输出一个数组</h4><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">int[] intArray = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</div><div class=\"line\">String intArrayString = Arrays.toString(intArray);</div><div class=\"line\"><span class=\"comment\">// print directly will print reference value</span></div><div class=\"line\">System.out.println(intArray);</div><div class=\"line\"><span class=\"comment\">// [I@7150bd4d</span></div><div class=\"line\">System.out.println(intArrayString);</div><div class=\"line\"><span class=\"comment\">// [1, 2, 3, 4, 5]</span></div></pre></td></tr></table></figure>\n<h4 id=\"2-3-从一个数组创建数组列表\"><a href=\"#2-3-从一个数组创建数组列表\" class=\"headerlink\" title=\"2.3 从一个数组创建数组列表\"></a>2.3 从一个数组创建数组列表</h4><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">String</span>[] stringArray = &#123; <span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"e\"</span> &#125;;</div><div class=\"line\">ArrayList&lt;<span class=\"keyword\">String</span>&gt; arrayList = <span class=\"keyword\">new</span> ArrayList&lt;<span class=\"keyword\">String</span>&gt;(Arrays.asList(stringArray));</div><div class=\"line\">System.out.<span class=\"built_in\">println</span>(arrayList);</div><div class=\"line\"><span class=\"comment\">// [a, b, c, d, e]</span></div></pre></td></tr></table></figure>\n<h4 id=\"2-4-检查一个数组是否包含某个值\"><a href=\"#2-4-检查一个数组是否包含某个值\" class=\"headerlink\" title=\"2.4 检查一个数组是否包含某个值\"></a>2.4 检查一个数组是否包含某个值</h4><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">String[] </span><span class=\"keyword\">stringArray </span>= &#123; <span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"e\"</span> &#125;<span class=\"comment\">;</span></div><div class=\"line\"><span class=\"keyword\">boolean </span><span class=\"keyword\">b </span>= Arrays.asList(<span class=\"keyword\">stringArray).contains(\"a\");</span></div><div class=\"line\"><span class=\"symbol\">System.out.println</span>(<span class=\"keyword\">b);</span></div><div class=\"line\">// true</div></pre></td></tr></table></figure>\n<h4 id=\"2-5-连接连个数组\"><a href=\"#2-5-连接连个数组\" class=\"headerlink\" title=\"2.5 连接连个数组\"></a>2.5 连接连个数组</h4><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">int[] intArray = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</div><div class=\"line\">int[] intArray2 = &#123; <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span> &#125;;</div><div class=\"line\"><span class=\"comment\">// Apache Commons Lang library</span></div><div class=\"line\">int[] combinedIntArray = ArrayUtils.addAll(intArray, intArray2);</div></pre></td></tr></table></figure>\n<h4 id=\"2-6-声明一个内联数组（Array-inline）\"><a href=\"#2-6-声明一个内联数组（Array-inline）\" class=\"headerlink\" title=\"2.6 声明一个内联数组（Array inline）\"></a>2.6 声明一个内联数组（Array inline）</h4><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">method</span><span class=\"params\">(<span class=\"keyword\">new</span> String[]&#123;\"a\", \"b\", \"c\", \"d\", \"e\"&#125;)</span>;</span></div></pre></td></tr></table></figure>\n<h4 id=\"2-7-把提供的数组元素放入一个字符串\"><a href=\"#2-7-把提供的数组元素放入一个字符串\" class=\"headerlink\" title=\"2.7 把提供的数组元素放入一个字符串\"></a>2.7 把提供的数组元素放入一个字符串</h4><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// containing the provided list of elements</span></div><div class=\"line\"><span class=\"comment\">// Apache common lang</span></div><div class=\"line\"><span class=\"keyword\">String</span> j = StringUtils.<span class=\"built_in\">join</span>(<span class=\"keyword\">new</span> <span class=\"keyword\">String</span>[] &#123; <span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span> &#125;, <span class=\"string\">\"-\"</span>);</div><div class=\"line\">System.out.<span class=\"built_in\">println</span>(j);</div><div class=\"line\"><span class=\"comment\">// a-b-c</span></div></pre></td></tr></table></figure>\n<h4 id=\"2-8-将一个数组列表转换为数组\"><a href=\"#2-8-将一个数组列表转换为数组\" class=\"headerlink\" title=\"2.8 将一个数组列表转换为数组\"></a>2.8 将一个数组列表转换为数组</h4><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">String</span>[] stringArray = &#123; <span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"e\"</span> &#125;;</div><div class=\"line\">ArrayList&lt;<span class=\"keyword\">String</span>&gt; arrayList = <span class=\"keyword\">new</span> ArrayList&lt;<span class=\"keyword\">String</span>&gt;(Arrays.asList(stringArray));</div><div class=\"line\"><span class=\"keyword\">String</span>[] stringArr = <span class=\"keyword\">new</span> <span class=\"keyword\">String</span>[arrayList.<span class=\"built_in\">size</span>()];</div><div class=\"line\">arrayList.toArray(stringArr);</div><div class=\"line\"><span class=\"built_in\">for</span> (<span class=\"keyword\">String</span> s : stringArr)</div><div class=\"line\">    System.out.<span class=\"built_in\">println</span>(s);</div></pre></td></tr></table></figure>\n<h4 id=\"2-9-将一个数组列表转换集-Set\"><a href=\"#2-9-将一个数组列表转换集-Set\" class=\"headerlink\" title=\"2.9 将一个数组列表转换集(Set)\"></a>2.9 将一个数组列表转换集(Set)</h4><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">String</span>[] stringArray = &#123; <span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"e\"</span> &#125;;</div><div class=\"line\">ArrayList&lt;<span class=\"keyword\">String</span>&gt; arrayList = <span class=\"keyword\">new</span> ArrayList&lt;<span class=\"keyword\">String</span>&gt;(Arrays.asList(stringArray));</div><div class=\"line\"><span class=\"keyword\">String</span>[] stringArr = <span class=\"keyword\">new</span> <span class=\"keyword\">String</span>[arrayList.<span class=\"built_in\">size</span>()];</div><div class=\"line\">arrayList.toArray(stringArr);</div><div class=\"line\"><span class=\"built_in\">for</span> (<span class=\"keyword\">String</span> s : stringArr)</div><div class=\"line\">    System.out.<span class=\"built_in\">println</span>(s);</div></pre></td></tr></table></figure>\n<h4 id=\"2-10-逆向一个数组\"><a href=\"#2-10-逆向一个数组\" class=\"headerlink\" title=\"2.10 逆向一个数组\"></a>2.10 逆向一个数组</h4><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">int[] intArray = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</div><div class=\"line\">ArrayUtils.reverse(intArray);</div><div class=\"line\">System.out.println(Arrays.toString(intArray));</div><div class=\"line\"><span class=\"comment\">//[5, 4, 3, 2, 1]</span></div></pre></td></tr></table></figure>\n<h4 id=\"2-11-移除数组中的元素\"><a href=\"#2-11-移除数组中的元素\" class=\"headerlink\" title=\"2.11 移除数组中的元素\"></a>2.11 移除数组中的元素</h4><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">int[] intArray = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</div><div class=\"line\">int[] removed = ArrayUtils.removeElement(intArray, <span class=\"number\">3</span>);<span class=\"comment\">//create a new array</span></div><div class=\"line\">System.out.println(Arrays.toString(removed));</div></pre></td></tr></table></figure>\n<h4 id=\"2-12-移除数组中的元素\"><a href=\"#2-12-移除数组中的元素\" class=\"headerlink\" title=\"2.12 移除数组中的元素\"></a>2.12 移除数组中的元素</h4><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">byte[] </span><span class=\"keyword\">bytes </span>= <span class=\"keyword\">ByteBuffer.allocate(4).putInt(8).array();</span></div><div class=\"line\">for (<span class=\"keyword\">byte </span>t : <span class=\"keyword\">bytes) </span>&#123;</div><div class=\"line\">   System.out.format(<span class=\"string\">\"0x%x \"</span>, t)<span class=\"comment\">;</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-12-数组其他知识\"><a href=\"#2-12-数组其他知识\" class=\"headerlink\" title=\"2.12 数组其他知识\"></a>2.12 数组其他知识</h4><ol>\n<li><a href=\"http://www.cnblogs.com/suneryong/p/6520442.html\" target=\"_blank\" rel=\"external\">for和foreach的性能对比</a></li>\n</ol>\n<h3 id=\"3-Collection\"><a href=\"#3-Collection\" class=\"headerlink\" title=\"3.Collection\"></a>3.Collection</h3><h3 id=\"4-Map\"><a href=\"#4-Map\" class=\"headerlink\" title=\"4.Map\"></a>4.Map</h3><h3 id=\"5-List\"><a href=\"#5-List\" class=\"headerlink\" title=\"5.List\"></a>5.List</h3><h4 id=\"6-Set\"><a href=\"#6-Set\" class=\"headerlink\" title=\"6.Set\"></a>6.Set</h4>","excerpt":"<p>大多数真实应用程序都会处理像文件、变量、来自文件的记录或数据库结果集这样的集合。Java 语言有一个复杂的集合框架，您可以使用它创建和管理各种类型的对象集合。本单元将介绍最常用的集合类并帮助您开始使用它们。<br></p>","more":"<p></p>\n<h3 id=\"1-入门\"><a href=\"#1-入门\" class=\"headerlink\" title=\"1.入门\"></a>1.入门</h3><p><img src=\"http://ol5edn32j.bkt.clouddn.com/262238192165666.jpg\" alt=\"Java集合类\"></p>\n<hr>\n<h3 id=\"2-数组\"><a href=\"#2-数组\" class=\"headerlink\" title=\"2.数组\"></a>2.数组</h3><p>下面介绍stackoverflow中12个关于数组操作得票数最多的问题</p>\n<h4 id=\"2-1-声明数组\"><a href=\"#2-1-声明数组\" class=\"headerlink\" title=\"2.1 声明数组\"></a>2.1 声明数组</h4><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">String</span>[] aArray = <span class=\"keyword\">new</span> <span class=\"keyword\">String</span>[<span class=\"number\">5</span>];</div><div class=\"line\"><span class=\"keyword\">String</span>[] bArray = &#123;<span class=\"string\">\"a\"</span>,<span class=\"string\">\"b\"</span>,<span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"e\"</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">String</span>[] cArray = <span class=\"keyword\">new</span> <span class=\"keyword\">String</span>[]&#123;<span class=\"string\">\"a\"</span>,<span class=\"string\">\"b\"</span>,<span class=\"string\">\"c\"</span>,<span class=\"string\">\"d\"</span>,<span class=\"string\">\"e\"</span>&#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"2-2-输出一个数组\"><a href=\"#2-2-输出一个数组\" class=\"headerlink\" title=\"2.2 输出一个数组\"></a>2.2 输出一个数组</h4><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">int[] intArray = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</div><div class=\"line\">String intArrayString = Arrays.toString(intArray);</div><div class=\"line\"><span class=\"comment\">// print directly will print reference value</span></div><div class=\"line\">System.out.println(intArray);</div><div class=\"line\"><span class=\"comment\">// [I@7150bd4d</span></div><div class=\"line\">System.out.println(intArrayString);</div><div class=\"line\"><span class=\"comment\">// [1, 2, 3, 4, 5]</span></div></pre></td></tr></table></figure>\n<h4 id=\"2-3-从一个数组创建数组列表\"><a href=\"#2-3-从一个数组创建数组列表\" class=\"headerlink\" title=\"2.3 从一个数组创建数组列表\"></a>2.3 从一个数组创建数组列表</h4><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">String</span>[] stringArray = &#123; <span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"e\"</span> &#125;;</div><div class=\"line\">ArrayList&lt;<span class=\"keyword\">String</span>&gt; arrayList = <span class=\"keyword\">new</span> ArrayList&lt;<span class=\"keyword\">String</span>&gt;(Arrays.asList(stringArray));</div><div class=\"line\">System.out.<span class=\"built_in\">println</span>(arrayList);</div><div class=\"line\"><span class=\"comment\">// [a, b, c, d, e]</span></div></pre></td></tr></table></figure>\n<h4 id=\"2-4-检查一个数组是否包含某个值\"><a href=\"#2-4-检查一个数组是否包含某个值\" class=\"headerlink\" title=\"2.4 检查一个数组是否包含某个值\"></a>2.4 检查一个数组是否包含某个值</h4><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">String[] </span><span class=\"keyword\">stringArray </span>= &#123; <span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"e\"</span> &#125;<span class=\"comment\">;</span></div><div class=\"line\"><span class=\"keyword\">boolean </span><span class=\"keyword\">b </span>= Arrays.asList(<span class=\"keyword\">stringArray).contains(\"a\");</span></div><div class=\"line\"><span class=\"symbol\">System.out.println</span>(<span class=\"keyword\">b);</span></div><div class=\"line\">// true</div></pre></td></tr></table></figure>\n<h4 id=\"2-5-连接连个数组\"><a href=\"#2-5-连接连个数组\" class=\"headerlink\" title=\"2.5 连接连个数组\"></a>2.5 连接连个数组</h4><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">int[] intArray = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</div><div class=\"line\">int[] intArray2 = &#123; <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span> &#125;;</div><div class=\"line\"><span class=\"comment\">// Apache Commons Lang library</span></div><div class=\"line\">int[] combinedIntArray = ArrayUtils.addAll(intArray, intArray2);</div></pre></td></tr></table></figure>\n<h4 id=\"2-6-声明一个内联数组（Array-inline）\"><a href=\"#2-6-声明一个内联数组（Array-inline）\" class=\"headerlink\" title=\"2.6 声明一个内联数组（Array inline）\"></a>2.6 声明一个内联数组（Array inline）</h4><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">method</span><span class=\"params\">(<span class=\"keyword\">new</span> String[]&#123;\"a\", \"b\", \"c\", \"d\", \"e\"&#125;)</span>;</span></div></pre></td></tr></table></figure>\n<h4 id=\"2-7-把提供的数组元素放入一个字符串\"><a href=\"#2-7-把提供的数组元素放入一个字符串\" class=\"headerlink\" title=\"2.7 把提供的数组元素放入一个字符串\"></a>2.7 把提供的数组元素放入一个字符串</h4><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// containing the provided list of elements</span></div><div class=\"line\"><span class=\"comment\">// Apache common lang</span></div><div class=\"line\"><span class=\"keyword\">String</span> j = StringUtils.<span class=\"built_in\">join</span>(<span class=\"keyword\">new</span> <span class=\"keyword\">String</span>[] &#123; <span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span> &#125;, <span class=\"string\">\"-\"</span>);</div><div class=\"line\">System.out.<span class=\"built_in\">println</span>(j);</div><div class=\"line\"><span class=\"comment\">// a-b-c</span></div></pre></td></tr></table></figure>\n<h4 id=\"2-8-将一个数组列表转换为数组\"><a href=\"#2-8-将一个数组列表转换为数组\" class=\"headerlink\" title=\"2.8 将一个数组列表转换为数组\"></a>2.8 将一个数组列表转换为数组</h4><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">String</span>[] stringArray = &#123; <span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"e\"</span> &#125;;</div><div class=\"line\">ArrayList&lt;<span class=\"keyword\">String</span>&gt; arrayList = <span class=\"keyword\">new</span> ArrayList&lt;<span class=\"keyword\">String</span>&gt;(Arrays.asList(stringArray));</div><div class=\"line\"><span class=\"keyword\">String</span>[] stringArr = <span class=\"keyword\">new</span> <span class=\"keyword\">String</span>[arrayList.<span class=\"built_in\">size</span>()];</div><div class=\"line\">arrayList.toArray(stringArr);</div><div class=\"line\"><span class=\"built_in\">for</span> (<span class=\"keyword\">String</span> s : stringArr)</div><div class=\"line\">    System.out.<span class=\"built_in\">println</span>(s);</div></pre></td></tr></table></figure>\n<h4 id=\"2-9-将一个数组列表转换集-Set\"><a href=\"#2-9-将一个数组列表转换集-Set\" class=\"headerlink\" title=\"2.9 将一个数组列表转换集(Set)\"></a>2.9 将一个数组列表转换集(Set)</h4><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">String</span>[] stringArray = &#123; <span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"e\"</span> &#125;;</div><div class=\"line\">ArrayList&lt;<span class=\"keyword\">String</span>&gt; arrayList = <span class=\"keyword\">new</span> ArrayList&lt;<span class=\"keyword\">String</span>&gt;(Arrays.asList(stringArray));</div><div class=\"line\"><span class=\"keyword\">String</span>[] stringArr = <span class=\"keyword\">new</span> <span class=\"keyword\">String</span>[arrayList.<span class=\"built_in\">size</span>()];</div><div class=\"line\">arrayList.toArray(stringArr);</div><div class=\"line\"><span class=\"built_in\">for</span> (<span class=\"keyword\">String</span> s : stringArr)</div><div class=\"line\">    System.out.<span class=\"built_in\">println</span>(s);</div></pre></td></tr></table></figure>\n<h4 id=\"2-10-逆向一个数组\"><a href=\"#2-10-逆向一个数组\" class=\"headerlink\" title=\"2.10 逆向一个数组\"></a>2.10 逆向一个数组</h4><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">int[] intArray = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</div><div class=\"line\">ArrayUtils.reverse(intArray);</div><div class=\"line\">System.out.println(Arrays.toString(intArray));</div><div class=\"line\"><span class=\"comment\">//[5, 4, 3, 2, 1]</span></div></pre></td></tr></table></figure>\n<h4 id=\"2-11-移除数组中的元素\"><a href=\"#2-11-移除数组中的元素\" class=\"headerlink\" title=\"2.11 移除数组中的元素\"></a>2.11 移除数组中的元素</h4><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">int[] intArray = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</div><div class=\"line\">int[] removed = ArrayUtils.removeElement(intArray, <span class=\"number\">3</span>);<span class=\"comment\">//create a new array</span></div><div class=\"line\">System.out.println(Arrays.toString(removed));</div></pre></td></tr></table></figure>\n<h4 id=\"2-12-移除数组中的元素\"><a href=\"#2-12-移除数组中的元素\" class=\"headerlink\" title=\"2.12 移除数组中的元素\"></a>2.12 移除数组中的元素</h4><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">byte[] </span><span class=\"keyword\">bytes </span>= <span class=\"keyword\">ByteBuffer.allocate(4).putInt(8).array();</span></div><div class=\"line\">for (<span class=\"keyword\">byte </span>t : <span class=\"keyword\">bytes) </span>&#123;</div><div class=\"line\">   System.out.format(<span class=\"string\">\"0x%x \"</span>, t)<span class=\"comment\">;</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-12-数组其他知识\"><a href=\"#2-12-数组其他知识\" class=\"headerlink\" title=\"2.12 数组其他知识\"></a>2.12 数组其他知识</h4><ol>\n<li><a href=\"http://www.cnblogs.com/suneryong/p/6520442.html\">for和foreach的性能对比</a></li>\n</ol>\n<h3 id=\"3-Collection\"><a href=\"#3-Collection\" class=\"headerlink\" title=\"3.Collection\"></a>3.Collection</h3><h3 id=\"4-Map\"><a href=\"#4-Map\" class=\"headerlink\" title=\"4.Map\"></a>4.Map</h3><h3 id=\"5-List\"><a href=\"#5-List\" class=\"headerlink\" title=\"5.List\"></a>5.List</h3><h4 id=\"6-Set\"><a href=\"#6-Set\" class=\"headerlink\" title=\"6.Set\"></a>6.Set</h4>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjpv4tc960001a7xw8sbeduqi","category_id":"cjpv4tc9g0004a7xwzidsscpq","_id":"cjpv4tc9u000da7xwgv5qv3gt"},{"post_id":"cjpv4tc9t000ca7xwzscoyunn","category_id":"cjpv4tc9r0009a7xw0lii1r53","_id":"cjpv4tc9x000ja7xwurreztxw"},{"post_id":"cjpv4tc9c0003a7xwkyak16sq","category_id":"cjpv4tc9r0009a7xw0lii1r53","_id":"cjpv4tca0000oa7xwo7ic6h8r"},{"post_id":"cjpv4tc9j0006a7xwy999qv15","category_id":"cjpv4tc9w000fa7xwxx7mwsqh","_id":"cjpv4tca3000sa7xw0r1q9csi"},{"post_id":"cjpv4tc9y000la7xwvibqcd8x","category_id":"cjpv4tc9r0009a7xw0lii1r53","_id":"cjpv4tca5000xa7xw81g8xdiq"},{"post_id":"cjpv4tc9m0007a7xwlqnvvxiv","category_id":"cjpv4tc9r0009a7xw0lii1r53","_id":"cjpv4tca70010a7xw9rv38f27"},{"post_id":"cjpv4tc9n0008a7xwx5uhtrtj","category_id":"cjpv4tc9r0009a7xw0lii1r53","_id":"cjpv4tca90017a7xw61hp8ze7"},{"post_id":"cjpv4tc9u000ea7xwzudssshb","category_id":"cjpv4tca70011a7xwbqzyrcrn","_id":"cjpv4tcad001da7xwq4ystcnk"},{"post_id":"cjpv4tca90016a7xwcdtb4y0z","category_id":"cjpv4tc9r0009a7xw0lii1r53","_id":"cjpv4tcaf001ia7xwra780zq4"},{"post_id":"cjpv4tc9w000ia7xw44nw0agx","category_id":"cjpv4tcaa0018a7xwxjhdsoej","_id":"cjpv4tcah001la7xwnv2zquve"},{"post_id":"cjpv4tca1000pa7xwu68rz61d","category_id":"cjpv4tcae001ga7xwmlxepqrj","_id":"cjpv4tcam001sa7xw0vz1r2im"},{"post_id":"cjpv4tca2000ra7xwcxfsqx5n","category_id":"cjpv4tca70011a7xwbqzyrcrn","_id":"cjpv4tcao001ya7xw4s27l4ic"},{"post_id":"cjpv4tca4000wa7xwtw2bymk3","category_id":"cjpv4tcam001ta7xw6bqjw4ii","_id":"cjpv4tcas0024a7xw3rc7on35"},{"post_id":"cjpv4tca5000za7xwu5cvduxr","category_id":"cjpv4tcap001za7xw65b1r0tu","_id":"cjpv4tcav002aa7xwx3fiw57n"},{"post_id":"cjpv4tcaq0023a7xwcitunhm5","category_id":"cjpv4tca70011a7xwbqzyrcrn","_id":"cjpv4tcaw002da7xwxa64de7y"},{"post_id":"cjpv4tcas0026a7xwet91yfx6","category_id":"cjpv4tc9r0009a7xw0lii1r53","_id":"cjpv4tcaz002ha7xwhe18agh8"},{"post_id":"cjpv4tcau0028a7xwymk59ul4","category_id":"cjpv4tc9r0009a7xw0lii1r53","_id":"cjpv4tcb0002ka7xw7h2m7a0b"},{"post_id":"cjpv4tca80014a7xwqgsqcu1h","category_id":"cjpv4tcas0025a7xw7hodrfaf","_id":"cjpv4tcb2002na7xwvbkbgagk"},{"post_id":"cjpv4tcav002ba7xwfybgdloo","category_id":"cjpv4tca70011a7xwbqzyrcrn","_id":"cjpv4tcb2002qa7xwhgausne7"},{"post_id":"cjpv4tcaw002fa7xwqjevjhfg","category_id":"cjpv4tc9w000fa7xwxx7mwsqh","_id":"cjpv4tcb3002ta7xws2exng66"},{"post_id":"cjpv4tcaa0019a7xw2gh0w2w2","category_id":"cjpv4tcaw002ca7xwzwtq2wr9","_id":"cjpv4tcb4002wa7xwjh765xv7"},{"post_id":"cjpv4tcb1002ma7xw20dwofxx","category_id":"cjpv4tc9r0009a7xw0lii1r53","_id":"cjpv4tcb4002ya7xw2mucrjcn"},{"post_id":"cjpv4tcac001ca7xw2c2xa729","category_id":"cjpv4tcb0002ja7xwb1xnfoaf","_id":"cjpv4tcb40030a7xwhmehwrp3"},{"post_id":"cjpv4tcag001ja7xwm04wgz2j","category_id":"cjpv4tcaw002ca7xwzwtq2wr9","_id":"cjpv4tcb40032a7xwpjoak7n2"},{"post_id":"cjpv4tcaz002ia7xw9zm916bs","category_id":"cjpv4tcb3002va7xwn2zs3a5x","_id":"cjpv4tcb40034a7xw3d4htuoo"}],"PostTag":[{"post_id":"cjpv4tc960001a7xw8sbeduqi","tag_id":"cjpv4tc9j0005a7xwdeo6hl4j","_id":"cjpv4tc9s000ba7xwxsikkff0"},{"post_id":"cjpv4tc9t000ca7xwzscoyunn","tag_id":"cjpv4tc9r000aa7xww9cvroj7","_id":"cjpv4tc9w000ha7xwd84lrxdw"},{"post_id":"cjpv4tc9c0003a7xwkyak16sq","tag_id":"cjpv4tc9r000aa7xww9cvroj7","_id":"cjpv4tc9x000ka7xw9sr07u8c"},{"post_id":"cjpv4tc9j0006a7xwy999qv15","tag_id":"cjpv4tc9w000ga7xwug9jirnm","_id":"cjpv4tca2000qa7xw6qkdgpya"},{"post_id":"cjpv4tc9y000la7xwvibqcd8x","tag_id":"cjpv4tc9r000aa7xww9cvroj7","_id":"cjpv4tca3000ta7xwmwx21bd9"},{"post_id":"cjpv4tc9m0007a7xwlqnvvxiv","tag_id":"cjpv4tc9r000aa7xww9cvroj7","_id":"cjpv4tca5000ya7xwx24shh22"},{"post_id":"cjpv4tca4000wa7xwtw2bymk3","tag_id":"cjpv4tc9w000ga7xwug9jirnm","_id":"cjpv4tca70012a7xwlijv9wc1"},{"post_id":"cjpv4tc9n0008a7xwx5uhtrtj","tag_id":"cjpv4tca4000va7xwoocoxsy7","_id":"cjpv4tca80015a7xw99hglmed"},{"post_id":"cjpv4tca90016a7xwcdtb4y0z","tag_id":"cjpv4tc9w000ga7xwug9jirnm","_id":"cjpv4tcac001ba7xwj3xv0z5t"},{"post_id":"cjpv4tc9u000ea7xwzudssshb","tag_id":"cjpv4tca70013a7xw1fitg12u","_id":"cjpv4tcad001ea7xwcoqdj4sq"},{"post_id":"cjpv4tc9w000ia7xw44nw0agx","tag_id":"cjpv4tcaa001aa7xwvt8k3ik4","_id":"cjpv4tcah001ka7xwhupyzx5c"},{"post_id":"cjpv4tca1000pa7xwu68rz61d","tag_id":"cjpv4tcaf001ha7xw5j77ccnm","_id":"cjpv4tcal001qa7xw066cxpq8"},{"post_id":"cjpv4tca2000ra7xwcxfsqx5n","tag_id":"cjpv4tcak001oa7xwesj47kqa","_id":"cjpv4tcan001wa7xwx8sduu02"},{"post_id":"cjpv4tca5000za7xwu5cvduxr","tag_id":"cjpv4tcam001ua7xwrjeao22d","_id":"cjpv4tcaq0022a7xwcshar4rj"},{"post_id":"cjpv4tca80014a7xwqgsqcu1h","tag_id":"cjpv4tcaq0021a7xwgay8ablz","_id":"cjpv4tcav0029a7xwxcwlm62a"},{"post_id":"cjpv4tcaa0019a7xw2gh0w2w2","tag_id":"cjpv4tcau0027a7xwh9rwe1qm","_id":"cjpv4tcaz002ga7xw4e0z2op1"},{"post_id":"cjpv4tcac001ca7xw2c2xa729","tag_id":"cjpv4tcaw002ea7xwl304x3yo","_id":"cjpv4tcb2002oa7xwpsi4q3h7"},{"post_id":"cjpv4tcb1002ma7xw20dwofxx","tag_id":"cjpv4tc9r000aa7xww9cvroj7","_id":"cjpv4tcb2002ra7xw6hvqjhi1"},{"post_id":"cjpv4tcag001ja7xwm04wgz2j","tag_id":"cjpv4tcau0027a7xwh9rwe1qm","_id":"cjpv4tcb3002ua7xwxvion9uo"},{"post_id":"cjpv4tcaq0023a7xwcitunhm5","tag_id":"cjpv4tcb3002sa7xw0zufgd1q","_id":"cjpv4tcb4002za7xwoyiver32"},{"post_id":"cjpv4tcas0026a7xwet91yfx6","tag_id":"cjpv4tcb4002xa7xwchjyce8j","_id":"cjpv4tcb40033a7xwg5w0njxo"},{"post_id":"cjpv4tcau0028a7xwymk59ul4","tag_id":"cjpv4tcb4002xa7xwchjyce8j","_id":"cjpv4tcb50036a7xwpt2do4pn"},{"post_id":"cjpv4tcav002ba7xwfybgdloo","tag_id":"cjpv4tcb50035a7xwx62nsgy3","_id":"cjpv4tcb50038a7xwzwgk59cg"},{"post_id":"cjpv4tcaw002fa7xwqjevjhfg","tag_id":"cjpv4tcb50037a7xw81bysh40","_id":"cjpv4tcb6003aa7xwym6afvwc"},{"post_id":"cjpv4tcaz002ia7xw9zm916bs","tag_id":"cjpv4tcb50039a7xw5be74tpc","_id":"cjpv4tcb6003ba7xw7ewmpv6o"}],"Tag":[{"name":"Temp","_id":"cjpv4tc9j0005a7xwdeo6hl4j"},{"name":"Java","_id":"cjpv4tc9r000aa7xww9cvroj7"},{"name":"面试 Java","_id":"cjpv4tc9w000ga7xwug9jirnm"},{"name":"Java JVM 虚拟机","_id":"cjpv4tca4000va7xwoocoxsy7"},{"name":"Java 专业术语","_id":"cjpv4tca70013a7xw1fitg12u"},{"name":"Java Paxos Zookeeper","_id":"cjpv4tcaa001aa7xwvt8k3ik4"},{"name":"Java Guava","_id":"cjpv4tcaf001ha7xw5j77ccnm"},{"name":"算法","_id":"cjpv4tcak001oa7xwesj47kqa"},{"name":"RPC","_id":"cjpv4tcam001ua7xwrjeao22d"},{"name":"Book","_id":"cjpv4tcaq0021a7xwgay8ablz"},{"name":"Tech","_id":"cjpv4tcau0027a7xwh9rwe1qm"},{"name":"缓存 架构","_id":"cjpv4tcaw002ea7xwl304x3yo"},{"name":"Paxos","_id":"cjpv4tcb3002sa7xw0zufgd1q"},{"name":"Java 对比","_id":"cjpv4tcb4002xa7xwchjyce8j"},{"name":"Markdown","_id":"cjpv4tcb50035a7xwx62nsgy3"},{"name":"Java 面试","_id":"cjpv4tcb50037a7xw81bysh40"},{"name":"计算机网络","_id":"cjpv4tcb50039a7xw5be74tpc"}]}}